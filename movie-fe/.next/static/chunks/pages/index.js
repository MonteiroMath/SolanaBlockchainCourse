/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/@coral-xyz/borsh/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@coral-xyz/borsh/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.map = exports.array = exports.rustEnum = exports.str = exports.vecU8 = exports.tagged = exports.vec = exports.bool = exports.option = exports.publicKey = exports.i256 = exports.u256 = exports.i128 = exports.u128 = exports.i64 = exports.u64 = exports.struct = exports.f64 = exports.f32 = exports.i32 = exports.u32 = exports.i16 = exports.u16 = exports.i8 = exports.u8 = void 0;\nconst buffer_layout_1 = __webpack_require__(/*! buffer-layout */ \"./node_modules/buffer-layout/lib/Layout.js\");\nconst web3_js_1 = __webpack_require__(/*! @solana/web3.js */ \"./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\"));\nvar buffer_layout_2 = __webpack_require__(/*! buffer-layout */ \"./node_modules/buffer-layout/lib/Layout.js\");\nObject.defineProperty(exports, \"u8\", ({ enumerable: true, get: function () { return buffer_layout_2.u8; } }));\nObject.defineProperty(exports, \"i8\", ({ enumerable: true, get: function () { return buffer_layout_2.s8; } }));\nObject.defineProperty(exports, \"u16\", ({ enumerable: true, get: function () { return buffer_layout_2.u16; } }));\nObject.defineProperty(exports, \"i16\", ({ enumerable: true, get: function () { return buffer_layout_2.s16; } }));\nObject.defineProperty(exports, \"u32\", ({ enumerable: true, get: function () { return buffer_layout_2.u32; } }));\nObject.defineProperty(exports, \"i32\", ({ enumerable: true, get: function () { return buffer_layout_2.s32; } }));\nObject.defineProperty(exports, \"f32\", ({ enumerable: true, get: function () { return buffer_layout_2.f32; } }));\nObject.defineProperty(exports, \"f64\", ({ enumerable: true, get: function () { return buffer_layout_2.f64; } }));\nObject.defineProperty(exports, \"struct\", ({ enumerable: true, get: function () { return buffer_layout_2.struct; } }));\nclass BNLayout extends buffer_layout_1.Layout {\n    constructor(span, signed, property) {\n        super(span, property);\n        this.blob = (0, buffer_layout_1.blob)(span);\n        this.signed = signed;\n    }\n    decode(b, offset = 0) {\n        const num = new bn_js_1.default(this.blob.decode(b, offset), 10, \"le\");\n        if (this.signed) {\n            return num.fromTwos(this.span * 8).clone();\n        }\n        return num;\n    }\n    encode(src, b, offset = 0) {\n        if (this.signed) {\n            src = src.toTwos(this.span * 8);\n        }\n        return this.blob.encode(src.toArrayLike(Buffer, \"le\", this.span), b, offset);\n    }\n}\nfunction u64(property) {\n    return new BNLayout(8, false, property);\n}\nexports.u64 = u64;\nfunction i64(property) {\n    return new BNLayout(8, true, property);\n}\nexports.i64 = i64;\nfunction u128(property) {\n    return new BNLayout(16, false, property);\n}\nexports.u128 = u128;\nfunction i128(property) {\n    return new BNLayout(16, true, property);\n}\nexports.i128 = i128;\nfunction u256(property) {\n    return new BNLayout(32, false, property);\n}\nexports.u256 = u256;\nfunction i256(property) {\n    return new BNLayout(32, true, property);\n}\nexports.i256 = i256;\nclass WrappedLayout extends buffer_layout_1.Layout {\n    constructor(layout, decoder, encoder, property) {\n        super(layout.span, property);\n        this.layout = layout;\n        this.decoder = decoder;\n        this.encoder = encoder;\n    }\n    decode(b, offset) {\n        return this.decoder(this.layout.decode(b, offset));\n    }\n    encode(src, b, offset) {\n        return this.layout.encode(this.encoder(src), b, offset);\n    }\n    getSpan(b, offset) {\n        return this.layout.getSpan(b, offset);\n    }\n}\nfunction publicKey(property) {\n    return new WrappedLayout((0, buffer_layout_1.blob)(32), (b) => new web3_js_1.PublicKey(b), (key) => key.toBuffer(), property);\n}\nexports.publicKey = publicKey;\nclass OptionLayout extends buffer_layout_1.Layout {\n    constructor(layout, property) {\n        super(-1, property);\n        this.layout = layout;\n        this.discriminator = (0, buffer_layout_1.u8)();\n    }\n    encode(src, b, offset = 0) {\n        if (src === null || src === undefined) {\n            return this.discriminator.encode(0, b, offset);\n        }\n        this.discriminator.encode(1, b, offset);\n        return this.layout.encode(src, b, offset + 1) + 1;\n    }\n    decode(b, offset = 0) {\n        const discriminator = this.discriminator.decode(b, offset);\n        if (discriminator === 0) {\n            return null;\n        }\n        else if (discriminator === 1) {\n            return this.layout.decode(b, offset + 1);\n        }\n        throw new Error(\"Invalid option \" + this.property);\n    }\n    getSpan(b, offset = 0) {\n        const discriminator = this.discriminator.decode(b, offset);\n        if (discriminator === 0) {\n            return 1;\n        }\n        else if (discriminator === 1) {\n            return this.layout.getSpan(b, offset + 1) + 1;\n        }\n        throw new Error(\"Invalid option \" + this.property);\n    }\n}\nfunction option(layout, property) {\n    return new OptionLayout(layout, property);\n}\nexports.option = option;\nfunction bool(property) {\n    return new WrappedLayout((0, buffer_layout_1.u8)(), decodeBool, encodeBool, property);\n}\nexports.bool = bool;\nfunction decodeBool(value) {\n    if (value === 0) {\n        return false;\n    }\n    else if (value === 1) {\n        return true;\n    }\n    throw new Error(\"Invalid bool: \" + value);\n}\nfunction encodeBool(value) {\n    return value ? 1 : 0;\n}\nfunction vec(elementLayout, property) {\n    const length = (0, buffer_layout_1.u32)(\"length\");\n    const layout = (0, buffer_layout_1.struct)([\n        length,\n        (0, buffer_layout_1.seq)(elementLayout, (0, buffer_layout_1.offset)(length, -length.span), \"values\"),\n    ]);\n    return new WrappedLayout(layout, ({ values }) => values, (values) => ({ values }), property);\n}\nexports.vec = vec;\nfunction tagged(tag, layout, property) {\n    const wrappedLayout = (0, buffer_layout_1.struct)([\n        u64(\"tag\"),\n        layout.replicate(\"data\"),\n    ]);\n    function decodeTag({ tag: receivedTag, data }) {\n        if (!receivedTag.eq(tag)) {\n            throw new Error(\"Invalid tag, expected: \" +\n                tag.toString(\"hex\") +\n                \", got: \" +\n                receivedTag.toString(\"hex\"));\n        }\n        return data;\n    }\n    return new WrappedLayout(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);\n}\nexports.tagged = tagged;\nfunction vecU8(property) {\n    const length = (0, buffer_layout_1.u32)(\"length\");\n    const layout = (0, buffer_layout_1.struct)([\n        length,\n        (0, buffer_layout_1.blob)((0, buffer_layout_1.offset)(length, -length.span), \"data\"),\n    ]);\n    return new WrappedLayout(layout, ({ data }) => data, (data) => ({ data }), property);\n}\nexports.vecU8 = vecU8;\nfunction str(property) {\n    return new WrappedLayout(vecU8(), (data) => data.toString(\"utf-8\"), (s) => Buffer.from(s, \"utf-8\"), property);\n}\nexports.str = str;\nfunction rustEnum(variants, property, discriminant) {\n    const unionLayout = (0, buffer_layout_1.union)(discriminant !== null && discriminant !== void 0 ? discriminant : (0, buffer_layout_1.u8)(), property);\n    variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));\n    return unionLayout;\n}\nexports.rustEnum = rustEnum;\nfunction array(elementLayout, length, property) {\n    const layout = (0, buffer_layout_1.struct)([\n        (0, buffer_layout_1.seq)(elementLayout, length, \"values\"),\n    ]);\n    return new WrappedLayout(layout, ({ values }) => values, (values) => ({ values }), property);\n}\nexports.array = array;\nclass MapEntryLayout extends buffer_layout_1.Layout {\n    constructor(keyLayout, valueLayout, property) {\n        super(keyLayout.span + valueLayout.span, property);\n        this.keyLayout = keyLayout;\n        this.valueLayout = valueLayout;\n    }\n    decode(b, offset) {\n        offset = offset || 0;\n        const key = this.keyLayout.decode(b, offset);\n        const value = this.valueLayout.decode(b, offset + this.keyLayout.getSpan(b, offset));\n        return [key, value];\n    }\n    encode(src, b, offset) {\n        offset = offset || 0;\n        const keyBytes = this.keyLayout.encode(src[0], b, offset);\n        const valueBytes = this.valueLayout.encode(src[1], b, offset + keyBytes);\n        return keyBytes + valueBytes;\n    }\n    getSpan(b, offset) {\n        return (this.keyLayout.getSpan(b, offset) + this.valueLayout.getSpan(b, offset));\n    }\n}\nfunction map(keyLayout, valueLayout, property) {\n    const length = (0, buffer_layout_1.u32)(\"length\");\n    const layout = (0, buffer_layout_1.struct)([\n        length,\n        (0, buffer_layout_1.seq)(new MapEntryLayout(keyLayout, valueLayout), (0, buffer_layout_1.offset)(length, -length.span), \"values\"),\n    ]);\n    return new WrappedLayout(layout, ({ values }) => new Map(values), (values) => ({ values: Array.from(values.entries()) }), property);\n}\nexports.map = map;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvcmFsLXh5ei9ib3JzaC9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVcsR0FBRyxhQUFhLEdBQUcsZ0JBQWdCLEdBQUcsV0FBVyxHQUFHLGFBQWEsR0FBRyxjQUFjLEdBQUcsV0FBVyxHQUFHLFlBQVksR0FBRyxjQUFjLEdBQUcsaUJBQWlCLEdBQUcsWUFBWSxHQUFHLFlBQVksR0FBRyxZQUFZLEdBQUcsWUFBWSxHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsY0FBYyxHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsV0FBVyxHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsV0FBVyxHQUFHLFVBQVUsR0FBRyxVQUFVO0FBQ3RYLHdCQUF3QixtQkFBTyxDQUFDLGlFQUFlO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFpQjtBQUMzQyxnQ0FBZ0MsbUJBQU8sQ0FBQyw2Q0FBTztBQUMvQyxzQkFBc0IsbUJBQU8sQ0FBQyxpRUFBZTtBQUM3QyxzQ0FBcUMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDM0csc0NBQXFDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQzNHLHVDQUFzQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUM3Ryx1Q0FBc0MsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDN0csdUNBQXNDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQzdHLHVDQUFzQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUM3Ryx1Q0FBc0MsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDN0csdUNBQXNDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQzdHLDBDQUF5QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRLDRCQUE0QixRQUFRO0FBQ3BGO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsV0FBVztBQUMvRTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsTUFBTSx3QkFBd0IsTUFBTTtBQUM1RTtBQUNBLGFBQWE7QUFDYjtBQUNBLCtFQUErRSxNQUFNO0FBQ3JGO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUSw0QkFBNEIsUUFBUTtBQUNwRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRLHFDQUFxQyxzQ0FBc0M7QUFDM0g7QUFDQSxXQUFXO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb3JhbC14eXovYm9yc2gvZGlzdC9pbmRleC5qcz8yZTNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYXAgPSBleHBvcnRzLmFycmF5ID0gZXhwb3J0cy5ydXN0RW51bSA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy52ZWNVOCA9IGV4cG9ydHMudGFnZ2VkID0gZXhwb3J0cy52ZWMgPSBleHBvcnRzLmJvb2wgPSBleHBvcnRzLm9wdGlvbiA9IGV4cG9ydHMucHVibGljS2V5ID0gZXhwb3J0cy5pMjU2ID0gZXhwb3J0cy51MjU2ID0gZXhwb3J0cy5pMTI4ID0gZXhwb3J0cy51MTI4ID0gZXhwb3J0cy5pNjQgPSBleHBvcnRzLnU2NCA9IGV4cG9ydHMuc3RydWN0ID0gZXhwb3J0cy5mNjQgPSBleHBvcnRzLmYzMiA9IGV4cG9ydHMuaTMyID0gZXhwb3J0cy51MzIgPSBleHBvcnRzLmkxNiA9IGV4cG9ydHMudTE2ID0gZXhwb3J0cy5pOCA9IGV4cG9ydHMudTggPSB2b2lkIDA7XG5jb25zdCBidWZmZXJfbGF5b3V0XzEgPSByZXF1aXJlKFwiYnVmZmVyLWxheW91dFwiKTtcbmNvbnN0IHdlYjNfanNfMSA9IHJlcXVpcmUoXCJAc29sYW5hL3dlYjMuanNcIik7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG52YXIgYnVmZmVyX2xheW91dF8yID0gcmVxdWlyZShcImJ1ZmZlci1sYXlvdXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1OFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyX2xheW91dF8yLnU4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaThcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ1ZmZlcl9sYXlvdXRfMi5zODsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInUxNlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyX2xheW91dF8yLnUxNjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImkxNlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyX2xheW91dF8yLnMxNjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInUzMlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyX2xheW91dF8yLnUzMjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImkzMlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyX2xheW91dF8yLnMzMjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImYzMlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyX2xheW91dF8yLmYzMjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImY2NFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyX2xheW91dF8yLmY2NDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cnVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyX2xheW91dF8yLnN0cnVjdDsgfSB9KTtcbmNsYXNzIEJOTGF5b3V0IGV4dGVuZHMgYnVmZmVyX2xheW91dF8xLkxheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc2lnbmVkLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMuYmxvYiA9ICgwLCBidWZmZXJfbGF5b3V0XzEuYmxvYikoc3Bhbik7XG4gICAgICAgIHRoaXMuc2lnbmVkID0gc2lnbmVkO1xuICAgIH1cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBudW0gPSBuZXcgYm5fanNfMS5kZWZhdWx0KHRoaXMuYmxvYi5kZWNvZGUoYiwgb2Zmc2V0KSwgMTAsIFwibGVcIik7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bS5mcm9tVHdvcyh0aGlzLnNwYW4gKiA4KS5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICBzcmMgPSBzcmMudG9Ud29zKHRoaXMuc3BhbiAqIDgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2IuZW5jb2RlKHNyYy50b0FycmF5TGlrZShCdWZmZXIsIFwibGVcIiwgdGhpcy5zcGFuKSwgYiwgb2Zmc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiB1NjQocHJvcGVydHkpIHtcbiAgICByZXR1cm4gbmV3IEJOTGF5b3V0KDgsIGZhbHNlLCBwcm9wZXJ0eSk7XG59XG5leHBvcnRzLnU2NCA9IHU2NDtcbmZ1bmN0aW9uIGk2NChwcm9wZXJ0eSkge1xuICAgIHJldHVybiBuZXcgQk5MYXlvdXQoOCwgdHJ1ZSwgcHJvcGVydHkpO1xufVxuZXhwb3J0cy5pNjQgPSBpNjQ7XG5mdW5jdGlvbiB1MTI4KHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG5ldyBCTkxheW91dCgxNiwgZmFsc2UsIHByb3BlcnR5KTtcbn1cbmV4cG9ydHMudTEyOCA9IHUxMjg7XG5mdW5jdGlvbiBpMTI4KHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG5ldyBCTkxheW91dCgxNiwgdHJ1ZSwgcHJvcGVydHkpO1xufVxuZXhwb3J0cy5pMTI4ID0gaTEyODtcbmZ1bmN0aW9uIHUyNTYocHJvcGVydHkpIHtcbiAgICByZXR1cm4gbmV3IEJOTGF5b3V0KDMyLCBmYWxzZSwgcHJvcGVydHkpO1xufVxuZXhwb3J0cy51MjU2ID0gdTI1NjtcbmZ1bmN0aW9uIGkyNTYocHJvcGVydHkpIHtcbiAgICByZXR1cm4gbmV3IEJOTGF5b3V0KDMyLCB0cnVlLCBwcm9wZXJ0eSk7XG59XG5leHBvcnRzLmkyNTYgPSBpMjU2O1xuY2xhc3MgV3JhcHBlZExheW91dCBleHRlbmRzIGJ1ZmZlcl9sYXlvdXRfMS5MYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGxheW91dCwgZGVjb2RlciwgZW5jb2RlciwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIobGF5b3V0LnNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IGRlY29kZXI7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IGVuY29kZXI7XG4gICAgfVxuICAgIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2Rlcih0aGlzLmxheW91dC5kZWNvZGUoYiwgb2Zmc2V0KSk7XG4gICAgfVxuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZW5jb2RlKHRoaXMuZW5jb2RlcihzcmMpLCBiLCBvZmZzZXQpO1xuICAgIH1cbiAgICBnZXRTcGFuKGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1YmxpY0tleShwcm9wZXJ0eSkge1xuICAgIHJldHVybiBuZXcgV3JhcHBlZExheW91dCgoMCwgYnVmZmVyX2xheW91dF8xLmJsb2IpKDMyKSwgKGIpID0+IG5ldyB3ZWIzX2pzXzEuUHVibGljS2V5KGIpLCAoa2V5KSA9PiBrZXkudG9CdWZmZXIoKSwgcHJvcGVydHkpO1xufVxuZXhwb3J0cy5wdWJsaWNLZXkgPSBwdWJsaWNLZXk7XG5jbGFzcyBPcHRpb25MYXlvdXQgZXh0ZW5kcyBidWZmZXJfbGF5b3V0XzEuTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKC0xLCBwcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICB0aGlzLmRpc2NyaW1pbmF0b3IgPSAoMCwgYnVmZmVyX2xheW91dF8xLnU4KSgpO1xuICAgIH1cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmIChzcmMgPT09IG51bGwgfHwgc3JjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc2NyaW1pbmF0b3IuZW5jb2RlKDAsIGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNjcmltaW5hdG9yLmVuY29kZSgxLCBiLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZW5jb2RlKHNyYywgYiwgb2Zmc2V0ICsgMSkgKyAxO1xuICAgIH1cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICBpZiAoZGlzY3JpbWluYXRvciA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvciA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBcIiArIHRoaXMucHJvcGVydHkpO1xuICAgIH1cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHRoaXMuZGlzY3JpbWluYXRvci5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGRpc2NyaW1pbmF0b3IgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3IgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC5nZXRTcGFuKGIsIG9mZnNldCArIDEpICsgMTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBcIiArIHRoaXMucHJvcGVydHkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG9wdGlvbihsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25MYXlvdXQobGF5b3V0LCBwcm9wZXJ0eSk7XG59XG5leHBvcnRzLm9wdGlvbiA9IG9wdGlvbjtcbmZ1bmN0aW9uIGJvb2wocHJvcGVydHkpIHtcbiAgICByZXR1cm4gbmV3IFdyYXBwZWRMYXlvdXQoKDAsIGJ1ZmZlcl9sYXlvdXRfMS51OCkoKSwgZGVjb2RlQm9vbCwgZW5jb2RlQm9vbCwgcHJvcGVydHkpO1xufVxuZXhwb3J0cy5ib29sID0gYm9vbDtcbmZ1bmN0aW9uIGRlY29kZUJvb2wodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBib29sOiBcIiArIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUJvb2wodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPyAxIDogMDtcbn1cbmZ1bmN0aW9uIHZlYyhlbGVtZW50TGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IGxlbmd0aCA9ICgwLCBidWZmZXJfbGF5b3V0XzEudTMyKShcImxlbmd0aFwiKTtcbiAgICBjb25zdCBsYXlvdXQgPSAoMCwgYnVmZmVyX2xheW91dF8xLnN0cnVjdCkoW1xuICAgICAgICBsZW5ndGgsXG4gICAgICAgICgwLCBidWZmZXJfbGF5b3V0XzEuc2VxKShlbGVtZW50TGF5b3V0LCAoMCwgYnVmZmVyX2xheW91dF8xLm9mZnNldCkobGVuZ3RoLCAtbGVuZ3RoLnNwYW4pLCBcInZhbHVlc1wiKSxcbiAgICBdKTtcbiAgICByZXR1cm4gbmV3IFdyYXBwZWRMYXlvdXQobGF5b3V0LCAoeyB2YWx1ZXMgfSkgPT4gdmFsdWVzLCAodmFsdWVzKSA9PiAoeyB2YWx1ZXMgfSksIHByb3BlcnR5KTtcbn1cbmV4cG9ydHMudmVjID0gdmVjO1xuZnVuY3Rpb24gdGFnZ2VkKHRhZywgbGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IHdyYXBwZWRMYXlvdXQgPSAoMCwgYnVmZmVyX2xheW91dF8xLnN0cnVjdCkoW1xuICAgICAgICB1NjQoXCJ0YWdcIiksXG4gICAgICAgIGxheW91dC5yZXBsaWNhdGUoXCJkYXRhXCIpLFxuICAgIF0pO1xuICAgIGZ1bmN0aW9uIGRlY29kZVRhZyh7IHRhZzogcmVjZWl2ZWRUYWcsIGRhdGEgfSkge1xuICAgICAgICBpZiAoIXJlY2VpdmVkVGFnLmVxKHRhZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdGFnLCBleHBlY3RlZDogXCIgK1xuICAgICAgICAgICAgICAgIHRhZy50b1N0cmluZyhcImhleFwiKSArXG4gICAgICAgICAgICAgICAgXCIsIGdvdDogXCIgK1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkVGFnLnRvU3RyaW5nKFwiaGV4XCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBXcmFwcGVkTGF5b3V0KHdyYXBwZWRMYXlvdXQsIGRlY29kZVRhZywgKGRhdGEpID0+ICh7IHRhZywgZGF0YSB9KSwgcHJvcGVydHkpO1xufVxuZXhwb3J0cy50YWdnZWQgPSB0YWdnZWQ7XG5mdW5jdGlvbiB2ZWNVOChwcm9wZXJ0eSkge1xuICAgIGNvbnN0IGxlbmd0aCA9ICgwLCBidWZmZXJfbGF5b3V0XzEudTMyKShcImxlbmd0aFwiKTtcbiAgICBjb25zdCBsYXlvdXQgPSAoMCwgYnVmZmVyX2xheW91dF8xLnN0cnVjdCkoW1xuICAgICAgICBsZW5ndGgsXG4gICAgICAgICgwLCBidWZmZXJfbGF5b3V0XzEuYmxvYikoKDAsIGJ1ZmZlcl9sYXlvdXRfMS5vZmZzZXQpKGxlbmd0aCwgLWxlbmd0aC5zcGFuKSwgXCJkYXRhXCIpLFxuICAgIF0pO1xuICAgIHJldHVybiBuZXcgV3JhcHBlZExheW91dChsYXlvdXQsICh7IGRhdGEgfSkgPT4gZGF0YSwgKGRhdGEpID0+ICh7IGRhdGEgfSksIHByb3BlcnR5KTtcbn1cbmV4cG9ydHMudmVjVTggPSB2ZWNVODtcbmZ1bmN0aW9uIHN0cihwcm9wZXJ0eSkge1xuICAgIHJldHVybiBuZXcgV3JhcHBlZExheW91dCh2ZWNVOCgpLCAoZGF0YSkgPT4gZGF0YS50b1N0cmluZyhcInV0Zi04XCIpLCAocykgPT4gQnVmZmVyLmZyb20ocywgXCJ1dGYtOFwiKSwgcHJvcGVydHkpO1xufVxuZXhwb3J0cy5zdHIgPSBzdHI7XG5mdW5jdGlvbiBydXN0RW51bSh2YXJpYW50cywgcHJvcGVydHksIGRpc2NyaW1pbmFudCkge1xuICAgIGNvbnN0IHVuaW9uTGF5b3V0ID0gKDAsIGJ1ZmZlcl9sYXlvdXRfMS51bmlvbikoZGlzY3JpbWluYW50ICE9PSBudWxsICYmIGRpc2NyaW1pbmFudCAhPT0gdm9pZCAwID8gZGlzY3JpbWluYW50IDogKDAsIGJ1ZmZlcl9sYXlvdXRfMS51OCkoKSwgcHJvcGVydHkpO1xuICAgIHZhcmlhbnRzLmZvckVhY2goKHZhcmlhbnQsIGluZGV4KSA9PiB1bmlvbkxheW91dC5hZGRWYXJpYW50KGluZGV4LCB2YXJpYW50LCB2YXJpYW50LnByb3BlcnR5KSk7XG4gICAgcmV0dXJuIHVuaW9uTGF5b3V0O1xufVxuZXhwb3J0cy5ydXN0RW51bSA9IHJ1c3RFbnVtO1xuZnVuY3Rpb24gYXJyYXkoZWxlbWVudExheW91dCwgbGVuZ3RoLCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IGxheW91dCA9ICgwLCBidWZmZXJfbGF5b3V0XzEuc3RydWN0KShbXG4gICAgICAgICgwLCBidWZmZXJfbGF5b3V0XzEuc2VxKShlbGVtZW50TGF5b3V0LCBsZW5ndGgsIFwidmFsdWVzXCIpLFxuICAgIF0pO1xuICAgIHJldHVybiBuZXcgV3JhcHBlZExheW91dChsYXlvdXQsICh7IHZhbHVlcyB9KSA9PiB2YWx1ZXMsICh2YWx1ZXMpID0+ICh7IHZhbHVlcyB9KSwgcHJvcGVydHkpO1xufVxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuY2xhc3MgTWFwRW50cnlMYXlvdXQgZXh0ZW5kcyBidWZmZXJfbGF5b3V0XzEuTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihrZXlMYXlvdXQsIHZhbHVlTGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihrZXlMYXlvdXQuc3BhbiArIHZhbHVlTGF5b3V0LnNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5rZXlMYXlvdXQgPSBrZXlMYXlvdXQ7XG4gICAgICAgIHRoaXMudmFsdWVMYXlvdXQgPSB2YWx1ZUxheW91dDtcbiAgICB9XG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXlMYXlvdXQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZUxheW91dC5kZWNvZGUoYiwgb2Zmc2V0ICsgdGhpcy5rZXlMYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQpKTtcbiAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbiAgICB9XG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBrZXlCeXRlcyA9IHRoaXMua2V5TGF5b3V0LmVuY29kZShzcmNbMF0sIGIsIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHZhbHVlQnl0ZXMgPSB0aGlzLnZhbHVlTGF5b3V0LmVuY29kZShzcmNbMV0sIGIsIG9mZnNldCArIGtleUJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIGtleUJ5dGVzICsgdmFsdWVCeXRlcztcbiAgICB9XG4gICAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmtleUxheW91dC5nZXRTcGFuKGIsIG9mZnNldCkgKyB0aGlzLnZhbHVlTGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwKGtleUxheW91dCwgdmFsdWVMYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gKDAsIGJ1ZmZlcl9sYXlvdXRfMS51MzIpKFwibGVuZ3RoXCIpO1xuICAgIGNvbnN0IGxheW91dCA9ICgwLCBidWZmZXJfbGF5b3V0XzEuc3RydWN0KShbXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgKDAsIGJ1ZmZlcl9sYXlvdXRfMS5zZXEpKG5ldyBNYXBFbnRyeUxheW91dChrZXlMYXlvdXQsIHZhbHVlTGF5b3V0KSwgKDAsIGJ1ZmZlcl9sYXlvdXRfMS5vZmZzZXQpKGxlbmd0aCwgLWxlbmd0aC5zcGFuKSwgXCJ2YWx1ZXNcIiksXG4gICAgXSk7XG4gICAgcmV0dXJuIG5ldyBXcmFwcGVkTGF5b3V0KGxheW91dCwgKHsgdmFsdWVzIH0pID0+IG5ldyBNYXAodmFsdWVzKSwgKHZhbHVlcykgPT4gKHsgdmFsdWVzOiBBcnJheS5mcm9tKHZhbHVlcy5lbnRyaWVzKCkpIH0pLCBwcm9wZXJ0eSk7XG59XG5leHBvcnRzLm1hcCA9IG1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@coral-xyz/borsh/dist/index.js\n");

/***/ }),

/***/ "./node_modules/buffer-layout/lib/Layout.js":
/*!**************************************************!*\
  !*** ./node_modules/buffer-layout/lib/Layout.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Support for translating between Buffer instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */\n\n\n\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */\nclass Layout {\n  constructor(span, property) {\n    if (!Number.isInteger(span)) {\n      throw new TypeError('span must be an integer');\n    }\n\n    /** The span of the layout in bytes.\n     *\n     * Positive values are generally expected.\n     *\n     * Zero will only appear in {@link Constant}s and in {@link\n     * Sequence}s where the {@link Sequence#count|count} is zero.\n     *\n     * A negative value indicates that the span is value-specific, and\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\n    this.span = span;\n\n    /** The property name used when this layout is represented in an\n     * Object.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances.  If left undefined the span of the unnamed layout will\n     * be treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Function to create an Object into which decoded properties will\n   * be written.\n   *\n   * Used only for layouts that {@link Layout#decode|decode} to Object\n   * instances, which means:\n   * * {@link Structure}\n   * * {@link Union}\n   * * {@link VariantLayout}\n   * * {@link BitStructure}\n   *\n   * If left undefined the JavaScript representation of these layouts\n   * will be Object instances.\n   *\n   * See {@link bindConstructorLayout}.\n   */\n  makeDestinationObject() {\n    return {};\n  }\n\n  /**\n   * Decode from a Buffer into an JavaScript value.\n   *\n   * @param {Buffer} b - the buffer from which encoded data is read.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {(Number|Array|Object)} - the value of the decoded data.\n   *\n   * @abstract\n   */\n  decode(b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Encode a JavaScript value into a Buffer.\n   *\n   * @param {(Number|Array|Object)} src - the value to be encoded into\n   * the buffer.  The type accepted depends on the (sub-)type of {@link\n   * Layout}.\n   *\n   * @param {Buffer} b - the buffer into which encoded data will be\n   * written.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {Number} - the number of bytes encoded, including the\n   * space skipped for internal padding, but excluding data such as\n   * {@link Sequence#count|lengths} when stored {@link\n   * ExternalLayout|externally}.  This is the adjustment to `offset`\n   * producing the offset where data for the next layout would be\n   * written.\n   *\n   * @abstract\n   */\n  encode(src, b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Calculate the span of a specific instance of a layout.\n   *\n   * @param {Buffer} b - the buffer that contains an encoded instance.\n   *\n   * @param {Number} [offset] - the offset at which the encoded instance\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @return {Number} - the number of bytes covered by the layout\n   * instance.  If this method is not overridden in a subclass the\n   * definition-time constant {@link Layout#span|span} will be\n   * returned.\n   *\n   * @throws {RangeError} - if the length of the value cannot be\n   * determined.\n   */\n  getSpan(b, offset) {\n    if (0 > this.span) {\n      throw new RangeError('indeterminate span');\n    }\n    return this.span;\n  }\n\n  /**\n   * Replicate the layout using a new property.\n   *\n   * This function must be used to get a structurally-equivalent layout\n   * with a different name since all {@link Layout} instances are\n   * immutable.\n   *\n   * **NOTE** This is a shallow copy.  All fields except {@link\n   * Layout#property|property} are strictly equal to the origin layout.\n   *\n   * @param {String} property - the value for {@link\n   * Layout#property|property} in the replica.\n   *\n   * @returns {Layout} - the copy with {@link Layout#property|property}\n   * set to `property`.\n   */\n  replicate(property) {\n    const rv = Object.create(this.constructor.prototype);\n    Object.assign(rv, this);\n    rv.property = property;\n    return rv;\n  }\n\n  /**\n   * Create an object from layout properties and an array of values.\n   *\n   * **NOTE** This function returns `undefined` if invoked on a layout\n   * that does not return its value as an Object.  Objects are\n   * returned for things that are a {@link Structure}, which includes\n   * {@link VariantLayout|variant layouts} if they are structures, and\n   * excludes {@link Union}s.  If you want this feature for a union\n   * you must use {@link Union.getVariant|getVariant} to select the\n   * desired layout.\n   *\n   * @param {Array} values - an array of values that correspond to the\n   * default order for properties.  As with {@link Layout#decode|decode}\n   * layout elements that have no property name are skipped when\n   * iterating over the array values.  Only the top-level properties are\n   * assigned; arguments are not assigned to properties of contained\n   * layouts.  Any unused values are ignored.\n   *\n   * @return {(Object|undefined)}\n   */\n  fromArray(values) {\n    return undefined;\n  }\n}\nexports.Layout = Layout;\n\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */\nfunction nameWithProperty(name, lo) {\n  if (lo.property) {\n    return name + '[' + lo.property + ']';\n  }\n  return name;\n}\nexports.nameWithProperty = nameWithProperty;\n\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */\nfunction bindConstructorLayout(Class, layout) {\n  if ('function' !== typeof Class) {\n    throw new TypeError('Class must be constructor');\n  }\n  if (Class.hasOwnProperty('layout_')) {\n    throw new Error('Class is already bound to a layout');\n  }\n  if (!(layout && (layout instanceof Layout))) {\n    throw new TypeError('layout must be a Layout');\n  }\n  if (layout.hasOwnProperty('boundConstructor_')) {\n    throw new Error('layout is already bound to a constructor');\n  }\n  Class.layout_ = layout;\n  layout.boundConstructor_ = Class;\n  layout.makeDestinationObject = (() => new Class());\n  Object.defineProperty(Class.prototype, 'encode', {\n    value: function(b, offset) {\n      return layout.encode(this, b, offset);\n    },\n    writable: true,\n  });\n  Object.defineProperty(Class, 'decode', {\n    value: function(b, offset) {\n      return layout.decode(b, offset);\n    },\n    writable: true,\n  });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */\nclass ExternalLayout extends Layout {\n  /**\n   * Return `true` iff the external layout decodes to an unsigned\n   * integer layout.\n   *\n   * In that case it can be used as the source of {@link\n   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n   * or as {@link UnionLayoutDiscriminator#layout|external union\n   * discriminators}.\n   *\n   * @abstract\n   */\n  isCount() {\n    throw new Error('ExternalLayout is abstract');\n  }\n}\n\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */\nclass GreedyCount extends ExternalLayout {\n  constructor(elementSpan, property) {\n    if (undefined === elementSpan) {\n      elementSpan = 1;\n    }\n    if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {\n      throw new TypeError('elementSpan must be a (positive) integer');\n    }\n    super(-1, property);\n\n    /** The layout for individual elements of the sequence.  The value\n     * must be a positive integer.  If not provided, the value will be\n     * 1. */\n    this.elementSpan = elementSpan;\n  }\n\n  /** @override */\n  isCount() {\n    return true;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const rem = b.length - offset;\n    return Math.floor(rem / this.elementSpan);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    return 0;\n  }\n}\n\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */\nclass OffsetLayout extends ExternalLayout {\n  constructor(layout, offset, property) {\n    if (!(layout instanceof Layout)) {\n      throw new TypeError('layout must be a Layout');\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    } else if (!Number.isInteger(offset)) {\n      throw new TypeError('offset must be integer or undefined');\n    }\n\n    super(layout.span, property || layout.property);\n\n    /** The subordinated layout. */\n    this.layout = layout;\n\n    /** The location of {@link OffsetLayout#layout} relative to the\n     * start of another layout.\n     *\n     * The value may be positive or negative, but an error will thrown\n     * if at the point of use it goes outside the span of the Buffer\n     * being accessed.  */\n    this.offset = offset;\n  }\n\n  /** @override */\n  isCount() {\n    return ((this.layout instanceof UInt)\n            || (this.layout instanceof UIntBE));\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.decode(b, offset + this.offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.encode(src, b, offset + this.offset);\n  }\n}\n\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UInt extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntLE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UIntBE extends Layout {\n  constructor(span, property) {\n    super( span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntBE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Int extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readIntLE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass IntBE extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readIntBE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\n\nconst V2E32 = Math.pow(2, 32);\n\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */\nfunction divmodInt64(src) {\n  const hi32 = Math.floor(src / V2E32);\n  const lo32 = src - (hi32 * V2E32);\n  return {hi32, lo32};\n}\n/* Reconstruct Number from quotient and non-negative remainder */\nfunction roundedInt64(hi32, lo32) {\n  return hi32 * V2E32 + lo32;\n}\n\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readUInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeUInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const hi32 = b.readUInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const hi32 = b.readInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Float extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readFloatLE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeFloatLE(src, offset);\n    return 4;\n  }\n}\n\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass FloatBE extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readFloatBE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeFloatBE(src, offset);\n    return 4;\n  }\n}\n\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Double extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readDoubleLE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeDoubleLE(src, offset);\n    return 8;\n  }\n}\n\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass DoubleBE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readDoubleBE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeDoubleBE(src, offset);\n    return 8;\n  }\n}\n\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Sequence extends Layout {\n  constructor(elementLayout, count, property) {\n    if (!(elementLayout instanceof Layout)) {\n      throw new TypeError('elementLayout must be a Layout');\n    }\n    if (!(((count instanceof ExternalLayout) && count.isCount())\n          || (Number.isInteger(count) && (0 <= count)))) {\n      throw new TypeError('count must be non-negative integer '\n                          + 'or an unsigned integer ExternalLayout');\n    }\n    let span = -1;\n    if ((!(count instanceof ExternalLayout))\n        && (0 < elementLayout.span)) {\n      span = count * elementLayout.span;\n    }\n\n    super(span, property);\n\n    /** The layout for individual elements of the sequence. */\n    this.elementLayout = elementLayout;\n\n    /** The number of elements in the sequence.\n     *\n     * This will be either a non-negative integer or an instance of\n     * {@link ExternalLayout} for which {@link\n     * ExternalLayout#isCount|isCount()} is `true`. */\n    this.count = count;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    if (0 < this.elementLayout.span) {\n      span = count * this.elementLayout.span;\n    } else {\n      let idx = 0;\n      while (idx < count) {\n        span += this.elementLayout.getSpan(b, offset + span);\n        ++idx;\n      }\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const rv = [];\n    let i = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    while (i < count) {\n      rv.push(this.elementLayout.decode(b, offset));\n      offset += this.elementLayout.getSpan(b, offset);\n      i += 1;\n    }\n    return rv;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n   *\n   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n   * the unused space in the buffer is left unchanged.  If `src` is\n   * longer than {@link Sequence#count|count} the unneeded elements are\n   * ignored.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const elo = this.elementLayout;\n    const span = src.reduce((span, v) => {\n      return span + elo.encode(v, b, offset + span);\n    }, 0);\n    if (this.count instanceof ExternalLayout) {\n      this.count.encode(src.length, b, offset);\n    }\n    return span;\n  }\n}\n\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */\nclass Structure extends Layout {\n  constructor(fields, property, decodePrefixes) {\n    if (!(Array.isArray(fields)\n          && fields.reduce((acc, v) => acc && (v instanceof Layout), true))) {\n      throw new TypeError('fields must be array of Layout instances');\n    }\n    if (('boolean' === typeof property)\n        && (undefined === decodePrefixes)) {\n      decodePrefixes = property;\n      property = undefined;\n    }\n\n    /* Verify absence of unnamed variable-length fields. */\n    for (const fd of fields) {\n      if ((0 > fd.span)\n          && (undefined === fd.property)) {\n        throw new Error('fields cannot contain unnamed variable-length layout');\n      }\n    }\n\n    let span = -1;\n    try {\n      span = fields.reduce((span, fd) => span + fd.getSpan(), 0);\n    } catch (e) {\n    }\n    super(span, property);\n\n    /** The sequence of {@link Layout} values that comprise the\n     * structure.\n     *\n     * The individual elements need not be the same type, and may be\n     * either scalar or aggregate layouts.  If a member layout leaves\n     * its {@link Layout#property|property} undefined the\n     * corresponding region of the buffer associated with the element\n     * will not be mutated.\n     *\n     * @type {Layout[]} */\n    this.fields = fields;\n\n    /** Control behavior of {@link Layout#decode|decode()} given short\n     * buffers.\n     *\n     * In some situations a structure many be extended with additional\n     * fields over time, with older installations providing only a\n     * prefix of the full structure.  If this property is `true`\n     * decoding will accept those buffers and leave subsequent fields\n     * undefined, as long as the buffer ends at a field boundary.\n     * Defaults to `false`. */\n    this.decodePrefixes = !!decodePrefixes;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = 0;\n    try {\n      span = this.fields.reduce((span, fd) => {\n        const fsp = fd.getSpan(b, offset);\n        offset += fsp;\n        return span + fsp;\n      }, 0);\n    } catch (e) {\n      throw new RangeError('indeterminate span');\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(b, offset);\n      }\n      offset += fd.getSpan(b, offset);\n      if (this.decodePrefixes\n          && (b.length === offset)) {\n        break;\n      }\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Structure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the buffer is\n   * left unmodified. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const firstOffset = offset;\n    let lastOffset = 0;\n    let lastWrote = 0;\n    for (const fd of this.fields) {\n      let span = fd.span;\n      lastWrote = (0 < span) ? span : 0;\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          lastWrote = fd.encode(fv, b, offset);\n          if (0 > span) {\n            /* Read the as-encoded span, which is not necessarily the\n             * same as what we wrote. */\n            span = fd.getSpan(b, offset);\n          }\n        }\n      }\n      lastOffset = offset;\n      offset += span;\n    }\n    /* Use (lastOffset + lastWrote) instead of offset because the last\n     * item may have had a dynamic length and we don't want to include\n     * the padding between it and the end of the space reserved for\n     * it. */\n    return (lastOffset + lastWrote) - firstOffset;\n  }\n\n  /** @override */\n  fromArray(values) {\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if ((undefined !== fd.property)\n          && (0 < values.length)) {\n        dest[fd.property] = values.shift();\n      }\n    }\n    return dest;\n  }\n\n  /**\n   * Get access to the layout of a given property.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Layout} - the layout associated with `property`, or\n   * undefined if there is no such property.\n   */\n  layoutFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n\n  /**\n   * Get the offset of a structure member.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Number} - the offset in bytes to the start of `property`\n   * within the structure, or undefined if `property` is not a field\n   * within the structure.  If the property is a member but follows a\n   * variable-length structure member a negative number will be\n   * returned.\n   */\n  offsetOf(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    let offset = 0;\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return offset;\n      }\n      if (0 > fd.span) {\n        offset = -1;\n      } else if (0 <= offset) {\n        offset += fd.span;\n      }\n    }\n  }\n}\n\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */\nclass UnionDiscriminator {\n  constructor(property) {\n    /** The {@link Layout#property|property} to be used when the\n     * discriminator is referenced in isolation (generally when {@link\n     * Union#decode|Union decode} cannot delegate to a specific\n     * variant). */\n    this.property = property;\n  }\n\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n   *\n   * The implementation of this method need not reference the buffer if\n   * variant information is available through other means. */\n  decode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n\n  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n   *\n   * The implementation of this method need not store the value if\n   * variant information is maintained through other means. */\n  encode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n}\n\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */\nclass UnionLayoutDiscriminator extends UnionDiscriminator {\n  constructor(layout, property) {\n    if (!((layout instanceof ExternalLayout)\n          && layout.isCount())) {\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\n    }\n\n    super(property || layout.property || 'variant');\n\n    /** The {@link ExternalLayout} used to access the discriminator\n     * value. */\n    this.layout = layout;\n  }\n\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  decode(b, offset) {\n    return this.layout.decode(b, offset);\n  }\n\n  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  encode(src, b, offset) {\n    return this.layout.encode(src, b, offset);\n  }\n}\n\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Union extends Layout {\n  constructor(discr, defaultLayout, property) {\n    const upv = ((discr instanceof UInt)\n               || (discr instanceof UIntBE));\n    if (upv) {\n      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n    } else if ((discr instanceof ExternalLayout)\n               && discr.isCount()) {\n      discr = new UnionLayoutDiscriminator(discr);\n    } else if (!(discr instanceof UnionDiscriminator)) {\n      throw new TypeError('discr must be a UnionDiscriminator '\n                          + 'or an unsigned integer layout');\n    }\n    if (undefined === defaultLayout) {\n      defaultLayout = null;\n    }\n    if (!((null === defaultLayout)\n          || (defaultLayout instanceof Layout))) {\n      throw new TypeError('defaultLayout must be null or a Layout');\n    }\n    if (null !== defaultLayout) {\n      if (0 > defaultLayout.span) {\n        throw new Error('defaultLayout must have constant span');\n      }\n      if (undefined === defaultLayout.property) {\n        defaultLayout = defaultLayout.replicate('content');\n      }\n    }\n\n    /* The union span can be estimated only if there's a default\n     * layout.  The union spans its default layout, plus any prefix\n     * variant layout.  By construction both layouts, if present, have\n     * non-negative span. */\n    let span = -1;\n    if (defaultLayout) {\n      span = defaultLayout.span;\n      if ((0 <= span) && upv) {\n        span += discr.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The interface for the discriminator value in isolation.\n     *\n     * This a {@link UnionDiscriminator} either passed to the\n     * constructor or synthesized from the `discr` constructor\n     * argument.  {@link\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n     * `true` iff the `discr` parameter was a non-offset {@link\n     * Layout} instance. */\n    this.discriminator = discr;\n\n    /** `true` if the {@link Union#discriminator|discriminator} is the\n     * first field in the union.\n     *\n     * If `false` the discriminator is obtained from somewhere\n     * else. */\n    this.usesPrefixDiscriminator = upv;\n\n    /** The layout for non-discriminator content when the value of the\n     * discriminator is not recognized.\n     *\n     * This is the value passed to the constructor.  It is\n     * structurally equivalent to the second component of {@link\n     * Union#layout|layout} but may have a different property\n     * name. */\n    this.defaultLayout = defaultLayout;\n\n    /** A registry of allowed variants.\n     *\n     * The keys are unsigned integers which should be compatible with\n     * {@link Union.discriminator|discriminator}.  The property value\n     * is the corresponding {@link VariantLayout} instances assigned\n     * to this union by {@link Union#addVariant|addVariant}.\n     *\n     * **NOTE** The registry remains mutable so that variants can be\n     * {@link Union#addVariant|added} at any time.  Users should not\n     * manipulate the content of this property. */\n    this.registry = {};\n\n    /* Private variable used when invoking getSourceVariant */\n    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n\n    /** Function to infer the variant selected by a source object.\n     *\n     * Defaults to {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n     * be overridden using {@link\n     * Union#configGetSourceVariant|configGetSourceVariant}.\n     *\n     * @param {Object} src - as with {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * @returns {(undefined|VariantLayout)} The default variant\n     * (`undefined`) or first registered variant that uses a property\n     * available in `src`. */\n    this.getSourceVariant = function(src) {\n      return boundGetSourceVariant(src);\n    };\n\n    /** Function to override the implementation of {@link\n     * Union#getSourceVariant|getSourceVariant}.\n     *\n     * Use this if the desired variant cannot be identified using the\n     * algorithm of {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * **NOTE** The provided function will be invoked bound to this\n     * Union instance, providing local access to {@link\n     * Union#registry|registry}.\n     *\n     * @param {Function} gsv - a function that follows the API of\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n    this.configGetSourceVariant = function(gsv) {\n      boundGetSourceVariant = gsv.bind(this);\n    };\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Default layouts always have non-negative span, so we don't have\n     * one and we have to recognize the variant which will in turn\n     * determine the span. */\n    const vlo = this.getVariant(b, offset);\n    if (!vlo) {\n      throw new Error('unable to determine span for unrecognized variant');\n    }\n    return vlo.getSpan(b, offset);\n  }\n\n  /**\n   * Method to infer a registered Union variant compatible with `src`.\n   *\n   * The first satisified rule in the following sequence defines the\n   * return value:\n   * * If `src` has properties matching the Union discriminator and\n   *   the default layout, `undefined` is returned regardless of the\n   *   value of the discriminator property (this ensures the default\n   *   layout will be used);\n   * * If `src` has a property matching the Union discriminator, the\n   *   value of the discriminator identifies a registered variant, and\n   *   either (a) the variant has no layout, or (b) `src` has the\n   *   variant's property, then the variant is returned (because the\n   *   source satisfies the constraints of the variant it identifies);\n   * * If `src` does not have a property matching the Union\n   *   discriminator, but does have a property matching a registered\n   *   variant, then the variant is returned (because the source\n   *   matches a variant without an explicit conflict);\n   * * An error is thrown (because we either can't identify a variant,\n   *   or we were explicitly told the variant but can't satisfy it).\n   *\n   * @param {Object} src - an object presumed to be compatible with\n   * the content of the Union.\n   *\n   * @return {(undefined|VariantLayout)} - as described above.\n   *\n   * @throws {Error} - if `src` cannot be associated with a default or\n   * registered variant.\n   */\n  defaultGetSourceVariant(src) {\n    if (src.hasOwnProperty(this.discriminator.property)) {\n      if (this.defaultLayout\n          && src.hasOwnProperty(this.defaultLayout.property)) {\n        return undefined;\n      }\n      const vlo = this.registry[src[this.discriminator.property]];\n      if (vlo\n          && ((!vlo.layout)\n              || src.hasOwnProperty(vlo.property))) {\n        return vlo;\n      }\n    } else {\n      for (const tag in this.registry) {\n        const vlo = this.registry[tag];\n        if (src.hasOwnProperty(vlo.property)) {\n          return vlo;\n        }\n      }\n    }\n    throw new Error('unable to infer src variant');\n  }\n\n  /** Implement {@link Layout#decode|decode} for {@link Union}.\n   *\n   * If the variant is {@link Union#addVariant|registered} the return\n   * value is an instance of that variant, with no explicit\n   * discriminator.  Otherwise the {@link Union#defaultLayout|default\n   * layout} is used to decode the content. */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let dest;\n    const dlo = this.discriminator;\n    const discr = dlo.decode(b, offset);\n    let clo = this.registry[discr];\n    if (undefined === clo) {\n      let contentOffset = 0;\n      clo = this.defaultLayout;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dest = this.makeDestinationObject();\n      dest[dlo.property] = discr;\n      dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);\n    } else {\n      dest = clo.decode(b, offset);\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Union}.\n   *\n   * This API assumes the `src` object is consistent with the union's\n   * {@link Union#defaultLayout|default layout}.  To encode variants\n   * use the appropriate variant-specific {@link VariantLayout#encode}\n   * method. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const vlo = this.getSourceVariant(src);\n    if (undefined === vlo) {\n      const dlo = this.discriminator;\n      const clo = this.defaultLayout;\n      let contentOffset = 0;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dlo.encode(src[dlo.property], b, offset);\n      return contentOffset + clo.encode(src[clo.property], b,\n                                        offset + contentOffset);\n    }\n    return vlo.encode(src, b, offset);\n  }\n\n  /** Register a new variant structure within a union.  The newly\n   * created variant is returned.\n   *\n   * @param {Number} variant - initializer for {@link\n   * VariantLayout#variant|variant}.\n   *\n   * @param {Layout} layout - initializer for {@link\n   * VariantLayout#layout|layout}.\n   *\n   * @param {String} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {VariantLayout} */\n  addVariant(variant, layout, property) {\n    const rv = new VariantLayout(this, variant, layout, property);\n    this.registry[variant] = rv;\n    return rv;\n  }\n\n  /**\n   * Get the layout associated with a registered variant.\n   *\n   * If `vb` does not produce a registered variant the function returns\n   * `undefined`.\n   *\n   * @param {(Number|Buffer)} vb - either the variant number, or a\n   * buffer from which the discriminator is to be read.\n   *\n   * @param {Number} offset - offset into `vb` for the start of the\n   * union.  Used only when `vb` is an instance of {Buffer}.\n   *\n   * @return {({VariantLayout}|undefined)}\n   */\n  getVariant(vb, offset) {\n    let variant = vb;\n    if (Buffer.isBuffer(vb)) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      variant = this.discriminator.decode(vb, offset);\n    }\n    return this.registry[variant];\n  }\n}\n\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */\nclass VariantLayout extends Layout {\n  constructor(union, variant, layout, property) {\n    if (!(union instanceof Union)) {\n      throw new TypeError('union must be a Union');\n    }\n    if ((!Number.isInteger(variant)) || (0 > variant)) {\n      throw new TypeError('variant must be a (non-negative) integer');\n    }\n    if (('string' === typeof layout)\n        && (undefined === property)) {\n      property = layout;\n      layout = null;\n    }\n    if (layout) {\n      if (!(layout instanceof Layout)) {\n        throw new TypeError('layout must be a Layout');\n      }\n      if ((null !== union.defaultLayout)\n          && (0 <= layout.span)\n          && (layout.span > union.defaultLayout.span)) {\n        throw new Error('variant span exceeds span of containing union');\n      }\n      if ('string' !== typeof property) {\n        throw new TypeError('variant must have a String property');\n      }\n    }\n    let span = union.span;\n    if (0 > union.span) {\n      span = layout ? layout.span : 0;\n      if ((0 <= span) && union.usesPrefixDiscriminator) {\n        span += union.discriminator.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The {@link Union} to which this variant belongs. */\n    this.union = union;\n\n    /** The unsigned integral value identifying this variant within\n     * the {@link Union#discriminator|discriminator} of the containing\n     * union. */\n    this.variant = variant;\n\n    /** The {@link Layout} to be used when reading/writing the\n     * non-discriminator part of the {@link\n     * VariantLayout#union|union}.  If `null` the variant carries no\n     * data. */\n    this.layout = layout || null;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      /* Will be equal to the containing union span if that is not\n       * variable. */\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    /* Span is defined solely by the variant (and prefix discriminator) */\n    return contentOffset + this.layout.getSpan(b, offset + contentOffset);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n    if (undefined === offset) {\n      offset = 0;\n    }\n    if (this !== this.union.getVariant(b, offset)) {\n      throw new Error('variant mismatch');\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout) {\n      dest[this.property] = this.layout.decode(b, offset + contentOffset);\n    } else if (this.property) {\n      dest[this.property] = true;\n    } else if (this.union.usesPrefixDiscriminator) {\n      dest[this.union.discriminator.property] = this.variant;\n    }\n    return dest;\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout\n        && (!src.hasOwnProperty(this.property))) {\n      throw new TypeError('variant lacks property ' + this.property);\n    }\n    this.union.discriminator.encode(this.variant, b, offset);\n    let span = contentOffset;\n    if (this.layout) {\n      this.layout.encode(src[this.property], b, offset + contentOffset);\n      span += this.layout.getSpan(b, offset + contentOffset);\n      if ((0 <= this.union.span)\n          && (span > this.union.span)) {\n        throw new Error('encoded variant overruns containing union');\n      }\n    }\n    return span;\n  }\n\n  /** Delegate {@link Layout#fromArray|fromArray} to {@link\n   * VariantLayout#layout|layout}. */\n  fromArray(values) {\n    if (this.layout) {\n      return this.layout.fromArray(values);\n    }\n  }\n}\n\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */\nfunction fixBitwiseResult(v) {\n  if (0 > v) {\n    v += 0x100000000;\n  }\n  return v;\n}\n\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass BitStructure extends Layout {\n  constructor(word, msb, property) {\n    if (!((word instanceof UInt)\n          || (word instanceof UIntBE))) {\n      throw new TypeError('word must be a UInt or UIntBE layout');\n    }\n    if (('string' === typeof msb)\n        && (undefined === property)) {\n      property = msb;\n      msb = undefined;\n    }\n    if (4 < word.span) {\n      throw new RangeError('word cannot exceed 32 bits');\n    }\n    super(word.span, property);\n\n    /** The layout used for the packed value.  {@link BitField}\n     * instances are packed sequentially depending on {@link\n     * BitStructure#msb|msb}. */\n    this.word = word;\n\n    /** Whether the bit sequences are packed starting at the most\n     * significant bit growing down (`true`), or the least significant\n     * bit growing up (`false`).\n     *\n     * **NOTE** Regardless of this value, the least significant bit of\n     * any {@link BitField} value is the least significant bit of the\n     * corresponding section of the packed value. */\n    this.msb = !!msb;\n\n    /** The sequence of {@link BitField} layouts that comprise the\n     * packed structure.\n     *\n     * **NOTE** The array remains mutable to allow fields to be {@link\n     * BitStructure#addField|added} after construction.  Users should\n     * not manipulate the content of this property.*/\n    this.fields = [];\n\n    /* Storage for the value.  Capture a variable instead of using an\n     * instance property because we don't want anything to change the\n     * value without going through the mutator. */\n    let value = 0;\n    this._packedSetValue = function(v) {\n      value = fixBitwiseResult(v);\n      return this;\n    };\n    this._packedGetValue = function() {\n      return value;\n    };\n  }\n\n  /** @override */\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(value);\n      }\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the packed\n   * value is left unmodified.  Unused bits are also left unmodified. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          fd.encode(fv);\n        }\n      }\n    }\n    return this.word.encode(this._packedGetValue(), b, offset);\n  }\n\n  /** Register a new bitfield with a containing bit structure.  The\n   * resulting bitfield is returned.\n   *\n   * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {BitField} */\n  addField(bits, property) {\n    const bf = new BitField(this, bits, property);\n    this.fields.push(bf);\n    return bf;\n  }\n\n  /** As with {@link BitStructure#addField|addField} for single-bit\n   * fields with `boolean` value representation.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {Boolean} */\n  addBoolean(property) {\n    // This is my Boolean, not the Javascript one.\n    // eslint-disable-next-line no-new-wrappers\n    const bf = new Boolean(this, property);\n    this.fields.push(bf);\n    return bf;\n  }\n\n  /**\n   * Get access to the bit field for a given property.\n   *\n   * @param {String} property - the bit field of interest.\n   *\n   * @return {BitField} - the field associated with `property`, or\n   * undefined if there is no such property.\n   */\n  fieldFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n}\n\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */\nclass BitField {\n  constructor(container, bits, property) {\n    if (!(container instanceof BitStructure)) {\n      throw new TypeError('container must be a BitStructure');\n    }\n    if ((!Number.isInteger(bits)) || (0 >= bits)) {\n      throw new TypeError('bits must be positive integer');\n    }\n    const totalBits = 8 * container.span;\n    const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);\n    if ((bits + usedBits) > totalBits) {\n      throw new Error('bits too long for span remainder ('\n                      + (totalBits - usedBits) + ' of '\n                      + totalBits + ' remain)');\n    }\n\n    /** The {@link BitStructure} instance to which this bit field\n     * belongs. */\n    this.container = container;\n\n    /** The span of this value in bits. */\n    this.bits = bits;\n\n    /** A mask of {@link BitField#bits|bits} bits isolating value bits\n     * that fit within the field.\n     *\n     * That is, it masks a value that has not yet been shifted into\n     * position within its containing packed integer. */\n    this.valueMask = (1 << bits) - 1;\n    if (32 === bits) { // shifted value out of range\n      this.valueMask = 0xFFFFFFFF;\n    }\n\n    /** The offset of the value within the containing packed unsigned\n     * integer.  The least significant bit of the packed value is at\n     * offset zero, regardless of bit ordering used. */\n    this.start = usedBits;\n    if (this.container.msb) {\n      this.start = totalBits - usedBits - bits;\n    }\n\n    /** A mask of {@link BitField#bits|bits} isolating the field value\n     * within the containing packed unsigned integer. */\n    this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n\n    /** The property name used when this bitfield is represented in an\n     * Object.\n     *\n     * Intended to be functionally equivalent to {@link\n     * Layout#property}.\n     *\n     * If left undefined the corresponding span of bits will be\n     * treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field. */\n  decode() {\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(word & this.wordMask);\n    const value = wordValue >>> this.start;\n    return value;\n  }\n\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field.\n   *\n   * **NOTE** This is not a specialization of {@link\n   * Layout#encode|Layout.encode} and there is no return value. */\n  encode(value) {\n    if ((!Number.isInteger(value))\n        || (value !== fixBitwiseResult(value & this.valueMask))) {\n      throw new TypeError(nameWithProperty('BitField.encode', this)\n                          + ' value must be integer not exceeding ' + this.valueMask);\n    }\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(value << this.start);\n    this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask)\n                                   | wordValue);\n  };\n}\n\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */\n/* eslint-disable no-extend-native */\nclass Boolean extends BitField {\n  constructor(container, property) {\n    super(container, 1, property);\n  }\n\n  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n   *\n   * @returns {boolean} */\n  decode(b, offset) {\n    return !!BitField.prototype.decode.call(this, b, offset);\n  }\n\n  /** @override */\n  encode(value) {\n    if ('boolean' === typeof value) {\n      // BitField requires integer values\n      value = +value;\n    }\n    return BitField.prototype.encode.call(this, value);\n  }\n}\n/* eslint-enable no-extend-native */\n\n/**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Buffer.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Blob extends Layout {\n  constructor(length, property) {\n    if (!(((length instanceof ExternalLayout) && length.isCount())\n          || (Number.isInteger(length) && (0 <= length)))) {\n      throw new TypeError('length must be positive integer '\n                          + 'or an unsigned integer ExternalLayout');\n    }\n\n    let span = -1;\n    if (!(length instanceof ExternalLayout)) {\n      span = length;\n    }\n    super(span, property);\n\n    /** The number of bytes in the blob.\n     *\n     * This may be a non-negative integer, or an instance of {@link\n     * ExternalLayout} that satisfies {@link\n     * ExternalLayout#isCount|isCount()}. */\n    this.length = length;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return b.slice(offset, offset + span);\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Blob}.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    let span = this.length;\n    if (this.length instanceof ExternalLayout) {\n      span = src.length;\n    }\n    if (!(Buffer.isBuffer(src)\n          && (span === src.length))) {\n      throw new TypeError(nameWithProperty('Blob.encode', this)\n                          + ' requires (length ' + span + ') Buffer as src');\n    }\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    b.write(src.toString('hex'), offset, span, 'hex');\n    if (this.length instanceof ExternalLayout) {\n      this.length.encode(span, b, offset);\n    }\n    return span;\n  }\n}\n\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass CString extends Layout {\n  constructor(property) {\n    super(-1, property);\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (!Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let idx = offset;\n    while ((idx < b.length) && (0 !== b[idx])) {\n      idx += 1;\n    }\n    return 1 + idx - offset;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.getSpan(b, offset);\n    return b.slice(offset, offset + span - 1).toString('utf-8');\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n    const srcb = new Buffer(src, 'utf8');\n    const span = srcb.length;\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(b, offset);\n    b[offset + span] = 0;\n    return span + 1;\n  }\n}\n\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UTF8 extends Layout {\n  constructor(maxSpan, property) {\n    if (('string' === typeof maxSpan)\n        && (undefined === property)) {\n      property = maxSpan;\n      maxSpan = undefined;\n    }\n    if (undefined === maxSpan) {\n      maxSpan = -1;\n    } else if (!Number.isInteger(maxSpan)) {\n      throw new TypeError('maxSpan must be an integer');\n    }\n\n    super(-1, property);\n\n    /** The maximum span of the layout in bytes.\n     *\n     * Positive values are generally expected.  Zero is abnormal.\n     * Attempts to encode or decode a value that exceeds this length\n     * will throw a `RangeError`.\n     *\n     * A negative value indicates that there is no bound on the length\n     * of the content. */\n    this.maxSpan = maxSpan;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (!Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.length - offset;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.getSpan(b, offset);\n    if ((0 <= this.maxSpan)\n        && (this.maxSpan < span)) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    return b.slice(offset, offset + span).toString('utf-8');\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n    const srcb = new Buffer(src, 'utf8');\n    const span = srcb.length;\n    if ((0 <= this.maxSpan)\n        && (this.maxSpan < span)) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(b, offset);\n    return span;\n  }\n}\n\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Constant extends Layout {\n  constructor(value, property) {\n    super(0, property);\n\n    /** The value produced by this constant when the layout is {@link\n     * Constant#decode|decoded}.\n     *\n     * Any JavaScript value including `null` and `undefined` is\n     * permitted.\n     *\n     * **WARNING** If `value` passed in the constructor was not\n     * frozen, it is possible for users of decoded values to change\n     * the content of the value. */\n    this.value = value;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    return this.value;\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    /* Constants take no space */\n    return 0;\n  }\n}\n\nexports.ExternalLayout = ExternalLayout;\nexports.GreedyCount = GreedyCount;\nexports.OffsetLayout = OffsetLayout;\nexports.UInt = UInt;\nexports.UIntBE = UIntBE;\nexports.Int = Int;\nexports.IntBE = IntBE;\nexports.Float = Float;\nexports.FloatBE = FloatBE;\nexports.Double = Double;\nexports.DoubleBE = DoubleBE;\nexports.Sequence = Sequence;\nexports.Structure = Structure;\nexports.UnionDiscriminator = UnionDiscriminator;\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\nexports.Union = Union;\nexports.VariantLayout = VariantLayout;\nexports.BitStructure = BitStructure;\nexports.BitField = BitField;\nexports.Boolean = Boolean;\nexports.Blob = Blob;\nexports.CString = CString;\nexports.UTF8 = UTF8;\nexports.Constant = Constant;\n\n/** Factory for {@link GreedyCount}. */\nexports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));\n\n/** Factory for {@link OffsetLayout}. */\nexports.offset = ((layout, offset, property) => new OffsetLayout(layout, offset, property));\n\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */\nexports.u8 = (property => new UInt(1, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16 = (property => new UInt(2, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24 = (property => new UInt(3, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32 = (property => new UInt(4, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40 = (property => new UInt(5, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48 = (property => new UInt(6, property));\n\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64 = (property => new NearUInt64(property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16be = (property => new UIntBE(2, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24be = (property => new UIntBE(3, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32be = (property => new UIntBE(4, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40be = (property => new UIntBE(5, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48be = (property => new UIntBE(6, property));\n\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64be = (property => new NearUInt64BE(property));\n\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */\nexports.s8 = (property => new Int(1, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */\nexports.s16 = (property => new Int(2, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */\nexports.s24 = (property => new Int(3, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */\nexports.s32 = (property => new Int(4, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */\nexports.s40 = (property => new Int(5, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */\nexports.s48 = (property => new Int(6, property));\n\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64 = (property => new NearInt64(property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */\nexports.s16be = (property => new IntBE(2, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */\nexports.s24be = (property => new IntBE(3, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */\nexports.s32be = (property => new IntBE(4, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */\nexports.s40be = (property => new IntBE(5, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */\nexports.s48be = (property => new IntBE(6, property));\n\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64be = (property => new NearInt64BE(property));\n\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\nexports.f32 = (property => new Float(property));\n\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\nexports.f32be = (property => new FloatBE(property));\n\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\nexports.f64 = (property => new Double(property));\n\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\nexports.f64be = (property => new DoubleBE(property));\n\n/** Factory for {@link Structure} values. */\nexports.struct = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));\n\n/** Factory for {@link BitStructure} values. */\nexports.bits = ((word, msb, property) => new BitStructure(word, msb, property));\n\n/** Factory for {@link Sequence} values. */\nexports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));\n\n/** Factory for {@link Union} values. */\nexports.union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));\n\n/** Factory for {@link UnionLayoutDiscriminator} values. */\nexports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator(layout, property));\n\n/** Factory for {@link Blob} values. */\nexports.blob = ((length, property) => new Blob(length, property));\n\n/** Factory for {@link CString} values. */\nexports.cstr = (property => new CString(property));\n\n/** Factory for {@link UTF8} values. */\nexports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));\n\n/** Factory for {@link Constant} values. */\nexports[\"const\"] = ((value, property) => new Constant(value, property));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVmZmVyLWxheW91dC9saWIvTGF5b3V0LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUNBQW1DO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGFBQWEsTUFBTSw2QkFBNkIsR0FBRztBQUNuRCw4QkFBOEIsR0FBRywrQkFBK0I7QUFDaEUsTUFBTSwrQkFBK0IsR0FBRztBQUN4Qyw4QkFBOEIsT0FBTztBQUNyQztBQUNBLE1BQU07QUFDTixhQUFhLE1BQU0saUNBQWlDLEdBQUc7QUFDdkQsZ0NBQWdDLEdBQUcsaUNBQWlDO0FBQ3BFLE1BQU0saUNBQWlDLE9BQU87QUFDOUMsaUNBQWlDO0FBQ2pDLE1BQU07QUFDTixhQUFhLE1BQU0sNkJBQTZCLEdBQUc7QUFDbkQsOEJBQThCLEdBQUcsK0JBQStCO0FBQ2hFLE1BQU0sK0JBQStCLEdBQUc7QUFDeEMsOEJBQThCLE9BQU87QUFDckM7QUFDQSxNQUFNO0FBQ04sV0FBVyxpQ0FBaUMsR0FBRztBQUMvQyxnQ0FBZ0MsR0FBRyxpQ0FBaUM7QUFDcEUsTUFBTSxpQ0FBaUMsT0FBTztBQUM5QyxpQ0FBaUM7QUFDakM7QUFDQSxtREFBbUQ7QUFDbkQsK0NBQStDLEdBQUc7QUFDbEQsOENBQThDLEdBQUc7QUFDakQsNkNBQTZDLE9BQU87QUFDcEQsK0NBQStDO0FBQy9DLHdDQUF3QztBQUN4QyxzQ0FBc0MsS0FBSztBQUMzQyxxQ0FBcUM7QUFDckMsd0NBQXdDO0FBQ3hDLHNDQUFzQyxLQUFLO0FBQzNDLHFDQUFxQztBQUNyQyxNQUFNLHFDQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxNQUFNLGlDQUFpQyxxQkFBcUI7QUFDNUQsaUNB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QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVcsUUFBUSw4QkFBOEI7QUFDakQsNEJBQTRCO0FBQzVCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVcsUUFBUSw4QkFBOEI7QUFDakQsNEJBQTRCO0FBQzVCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVcsUUFBUSw4QkFBOEI7QUFDakQsNEJBQTRCO0FBQzVCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVcsUUFBUSw4QkFBOEI7QUFDakQsNEJBQTRCO0FBQzVCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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Q0EsYUFBYTs7QUFFYixpQkFBaUI7QUFDakI7QUFDQSxhQUFhOztBQUViLGlCQUFpQjtBQUNqQjtBQUNBLGNBQWM7O0FBRWQsaUJBQWlCLGlEQUFpRDtBQUNsRSxXQUFXOztBQUVYLGlCQUFpQixnREFBZ0Q7QUFDakUsYUFBYTs7QUFFYixpQkFBaUIsa0RBQWtEO0FBQ25FLFdBQVc7O0FBRVgsaUJBQWlCLGlEQUFpRDtBQUNsRSxhQUFhOztBQUViLGlCQUFpQixpQkFBaUI7QUFDbEMsY0FBYzs7QUFFZCxpQkFBaUIsb0JBQW9CO0FBQ3JDLFlBQVk7O0FBRVosaUJBQWlCLGdCQUFnQjtBQUNqQyxXQUFXOztBQUVYLGlCQUFpQixhQUFhO0FBQzlCLGFBQWE7O0FBRWIsaUJBQWlCLGdDQUFnQztBQUNqRCxnQ0FBZ0M7O0FBRWhDLGlCQUFpQixZQUFZO0FBQzdCLFlBQVk7O0FBRVosaUJBQWlCLGVBQWU7QUFDaEMsWUFBWTs7QUFFWixpQkFBaUIsWUFBWTtBQUM3QixZQUFZOztBQUVaLGlCQUFpQixnQkFBZ0I7QUFDakMsZ0JBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci1sYXlvdXQvbGliL0xheW91dC5qcz9iNzZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggUGV0ZXIgQS4gQmlnb3RcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogU3VwcG9ydCBmb3IgdHJhbnNsYXRpbmcgYmV0d2VlbiBCdWZmZXIgaW5zdGFuY2VzIGFuZCBKYXZhU2NyaXB0XG4gKiBuYXRpdmUgdHlwZXMuXG4gKlxuICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+TGF5b3V0fExheW91dH0gaXMgdGhlIGJhc2lzIG9mIGEgY2xhc3NcbiAqIGhpZXJhcmNoeSB0aGF0IGFzc29jaWF0ZXMgcHJvcGVydHkgbmFtZXMgd2l0aCBzZXF1ZW5jZXMgb2YgZW5jb2RlZFxuICogYnl0ZXMuXG4gKlxuICogTGF5b3V0cyBhcmUgc3VwcG9ydGVkIGZvciB0aGVzZSBzY2FsYXIgKG51bWVyaWMpIHR5cGVzOlxuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dH5VSW50fFVuc2lnbmVkIGludGVnZXJzIGluIGxpdHRsZS1lbmRpYW5cbiAqICAgZm9ybWF0fSB3aXRoIHtAbGluayBtb2R1bGU6TGF5b3V0LnU4fDgtYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudTE2fDE2LWJpdH0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnUyNHwyNC1iaXR9LFxuICogICB7QGxpbmsgbW9kdWxlOkxheW91dC51MzJ8MzItYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudTQwfDQwLWJpdH0sIGFuZCB7QGxpbmsgbW9kdWxlOkxheW91dC51NDh8NDgtYml0fVxuICogICByZXByZXNlbnRhdGlvbiByYW5nZXM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0flVJbnRCRXxVbnNpZ25lZCBpbnRlZ2VycyBpbiBiaWctZW5kaWFuXG4gKiAgIGZvcm1hdH0gd2l0aCB7QGxpbmsgbW9kdWxlOkxheW91dC51MTZiZXwxNi1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51MjRiZXwyNC1iaXR9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MzJiZXwzMi1iaXR9LFxuICogICB7QGxpbmsgbW9kdWxlOkxheW91dC51NDBiZXw0MC1iaXR9LCBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudTQ4YmV8NDgtYml0fSByZXByZXNlbnRhdGlvbiByYW5nZXM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0fkludHxTaWduZWQgaW50ZWdlcnMgaW4gbGl0dGxlLWVuZGlhblxuICogICBmb3JtYXR9IHdpdGgge0BsaW5rIG1vZHVsZTpMYXlvdXQuczh8OC1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5zMTZ8MTYtYml0fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczI0fDI0LWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnMzMnwzMi1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5zNDB8NDAtYml0fSwgYW5kIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0OHw0OC1iaXR9XG4gKiAgIHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+SW50QkV8U2lnbmVkIGludGVnZXJzIGluIGJpZy1lbmRpYW4gZm9ybWF0fVxuICogICB3aXRoIHtAbGluayBtb2R1bGU6TGF5b3V0LnMxNmJlfDE2LWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnMyNGJlfDI0LWJpdH0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnMzMmJlfDMyLWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0MGJlfDQwLWJpdH0sIGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5zNDhiZXw0OC1iaXR9IHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICogNjQtYml0IGludGVncmFsIHZhbHVlcyB0aGF0IGRlY29kZSB0byBhbiBleGFjdCAoaWYgbWFnbml0dWRlIGlzXG4gKiAgIGxlc3MgdGhhbiAyXjUzKSBvciBuZWFyYnkgaW50ZWdyYWwgTnVtYmVyIGluIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0Lm51NjR8dW5zaWduZWQgbGl0dGxlLWVuZGlhbn0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0Lm51NjRiZXx1bnNpZ25lZCBiaWctZW5kaWFufSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQubnM2NHxzaWduZWQgbGl0dGxlLWVuZGlhbn0sIGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5uczY0YmV8dW5zaWduZWQgYmlnLWVuZGlhbn0gZW5jb2RpbmdzO1xuICogKiAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgdmFsdWVzIHdpdGgge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuZjMyfGxpdHRsZS1lbmRpYW59IGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5mMzJiZXxiaWctZW5kaWFufSByZXByZXNlbnRhdGlvbnM7XG4gKiAqIDY0LWJpdCBmbG9hdGluZyBwb2ludCB2YWx1ZXMgd2l0aCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5mNjR8bGl0dGxlLWVuZGlhbn0gYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LmY2NGJlfGJpZy1lbmRpYW59IHJlcHJlc2VudGF0aW9ucztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuY29uc3R8Q29uc3RhbnRzfSB0aGF0IHRha2Ugbm8gc3BhY2UgaW4gdGhlXG4gKiAgIGVuY29kZWQgZXhwcmVzc2lvbi5cbiAqXG4gKiBhbmQgZm9yIHRoZXNlIGFnZ3JlZ2F0ZSB0eXBlczpcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuc2VxfFNlcXVlbmNlfXMgb2YgaW5zdGFuY2VzIG9mIGEge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+TGF5b3V0fExheW91dH0sIHdpdGggSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBhc1xuICogICBhbiBBcnJheSBhbmQgY29uc3RhbnQgb3IgZGF0YS1kZXBlbmRlbnQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+U2VxdWVuY2UjY291bnR8bGVuZ3RofTtcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuc3RydWN0fFN0cnVjdHVyZX1zIHRoYXQgYWdncmVnYXRlIGFcbiAqICAgaGV0ZXJvZ2VuZW91cyBzZXF1ZW5jZSBvZiB7QGxpbmsgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fVxuICogICBpbnN0YW5jZXMsIHdpdGggSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBhcyBhbiBPYmplY3Q7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnVuaW9ufFVuaW9ufXMgdGhhdCBzdXBwb3J0IG11bHRpcGxlIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0flZhcmlhbnRMYXlvdXR8dmFyaWFudCBsYXlvdXRzfSBvdmVyIGEgZml4ZWRcbiAqICAgKHBhZGRlZCkgb3IgdmFyaWFibGUgKG5vdCBwYWRkZWQpIHNwYW4gb2YgYnl0ZXMsIHVzaW5nIGFuXG4gKiAgIHVuc2lnbmVkIGludGVnZXIgYXQgdGhlIHN0YXJ0IG9mIHRoZSBkYXRhIG9yIGEgc2VwYXJhdGUge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudW5pb25MYXlvdXREaXNjcmltaW5hdG9yfGxheW91dCBlbGVtZW50fSB0b1xuICogICBkZXRlcm1pbmUgd2hpY2ggbGF5b3V0IHRvIHVzZSB3aGVuIGludGVycHJldGluZyB0aGUgYnVmZmVyXG4gKiAgIGNvbnRlbnRzO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5iaXRzfEJpdFN0cnVjdHVyZX1zIHRoYXQgY29udGFpbiBhIHNlcXVlbmNlXG4gKiAgIG9mIGluZGl2aWR1YWwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+Qml0U3RydWN0dXJlI2FkZEZpZWxkfEJpdEZpZWxkfXMgcGFja2VkIGludG8gYW4gOCxcbiAqICAgMTYsIDI0LCBvciAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciBzdGFydGluZyBhdCB0aGUgbGVhc3QtIG9yXG4gKiAgIG1vc3Qtc2lnbmlmaWNhbnQgYml0O1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5jc3RyfEMgc3RyaW5nc30gb2YgdmFyeWluZyBsZW5ndGg7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LmJsb2J8QmxvYnN9IG9mIGZpeGVkLSBvciB2YXJpYWJsZS17QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5CbG9iI2xlbmd0aHxsZW5ndGh9IHJhdyBkYXRhLlxuICpcbiAqIEFsbCB7QGxpbmsgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fSBpbnN0YW5jZXMgYXJlIGltbXV0YWJsZVxuICogYWZ0ZXIgY29uc3RydWN0aW9uLCB0byBwcmV2ZW50IGludGVybmFsIHN0YXRlIGZyb20gYmVjb21pbmdcbiAqIGluY29uc2lzdGVudC5cbiAqXG4gKiBAbG9jYWwgTGF5b3V0XG4gKiBAbG9jYWwgRXh0ZXJuYWxMYXlvdXRcbiAqIEBsb2NhbCBHcmVlZHlDb3VudFxuICogQGxvY2FsIE9mZnNldExheW91dFxuICogQGxvY2FsIFVJbnRcbiAqIEBsb2NhbCBVSW50QkVcbiAqIEBsb2NhbCBJbnRcbiAqIEBsb2NhbCBJbnRCRVxuICogQGxvY2FsIE5lYXJVSW50NjRcbiAqIEBsb2NhbCBOZWFyVUludDY0QkVcbiAqIEBsb2NhbCBOZWFySW50NjRcbiAqIEBsb2NhbCBOZWFySW50NjRCRVxuICogQGxvY2FsIEZsb2F0XG4gKiBAbG9jYWwgRmxvYXRCRVxuICogQGxvY2FsIERvdWJsZVxuICogQGxvY2FsIERvdWJsZUJFXG4gKiBAbG9jYWwgU2VxdWVuY2VcbiAqIEBsb2NhbCBTdHJ1Y3R1cmVcbiAqIEBsb2NhbCBVbmlvbkRpc2NyaW1pbmF0b3JcbiAqIEBsb2NhbCBVbmlvbkxheW91dERpc2NyaW1pbmF0b3JcbiAqIEBsb2NhbCBVbmlvblxuICogQGxvY2FsIFZhcmlhbnRMYXlvdXRcbiAqIEBsb2NhbCBCaXRTdHJ1Y3R1cmVcbiAqIEBsb2NhbCBCaXRGaWVsZFxuICogQGxvY2FsIEJvb2xlYW5cbiAqIEBsb2NhbCBCbG9iXG4gKiBAbG9jYWwgQ1N0cmluZ1xuICogQGxvY2FsIENvbnN0YW50XG4gKiBAbG9jYWwgYmluZENvbnN0cnVjdG9yTGF5b3V0XG4gKiBAbW9kdWxlIExheW91dFxuICogQGxpY2Vuc2UgTUlUXG4gKiBAYXV0aG9yIFBldGVyIEEuIEJpZ290XG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGFiaWdvdC9idWZmZXItbGF5b3V0fGJ1ZmZlci1sYXlvdXQgb24gR2l0SHVifVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsYXlvdXQgb2JqZWN0cy5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB0aGUge0BsaW5rXG4gKiBMYXlvdXQjZW5jb2RlfGVuY29kZX0gb3Ige0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBJbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LiAgVGhlXG4gKiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnRlZ2VyOyBhIG5lZ2F0aXZlIHZhbHVlIHNpZ25pZmllcyB0aGF0IHRoZVxuICogc3BhbiBpcyB7QGxpbmsgTGF5b3V0I2dldFNwYW58dmFsdWUtc3BlY2lmaWN9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gSW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgTGF5b3V0IHtcbiAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc3BhbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NwYW4gbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuXG4gICAgLyoqIFRoZSBzcGFuIG9mIHRoZSBsYXlvdXQgaW4gYnl0ZXMuXG4gICAgICpcbiAgICAgKiBQb3NpdGl2ZSB2YWx1ZXMgYXJlIGdlbmVyYWxseSBleHBlY3RlZC5cbiAgICAgKlxuICAgICAqIFplcm8gd2lsbCBvbmx5IGFwcGVhciBpbiB7QGxpbmsgQ29uc3RhbnR9cyBhbmQgaW4ge0BsaW5rXG4gICAgICogU2VxdWVuY2V9cyB3aGVyZSB0aGUge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSBpcyB6ZXJvLlxuICAgICAqXG4gICAgICogQSBuZWdhdGl2ZSB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgc3BhbiBpcyB2YWx1ZS1zcGVjaWZpYywgYW5kXG4gICAgICogbXVzdCBiZSBvYnRhaW5lZCB1c2luZyB7QGxpbmsgTGF5b3V0I2dldFNwYW58Z2V0U3Bhbn0uICovXG4gICAgdGhpcy5zcGFuID0gc3BhbjtcblxuICAgIC8qKiBUaGUgcHJvcGVydHkgbmFtZSB1c2VkIHdoZW4gdGhpcyBsYXlvdXQgaXMgcmVwcmVzZW50ZWQgaW4gYW5cbiAgICAgKiBPYmplY3QuXG4gICAgICpcbiAgICAgKiBVc2VkIG9ubHkgZm9yIGxheW91dHMgdGhhdCB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9IHRvIE9iamVjdFxuICAgICAqIGluc3RhbmNlcy4gIElmIGxlZnQgdW5kZWZpbmVkIHRoZSBzcGFuIG9mIHRoZSB1bm5hbWVkIGxheW91dCB3aWxsXG4gICAgICogYmUgdHJlYXRlZCBhcyBwYWRkaW5nOiBpdCB3aWxsIG5vdCBiZSBtdXRhdGVkIGJ5IHtAbGlua1xuICAgICAqIExheW91dCNlbmNvZGV8ZW5jb2RlfSBub3IgcmVwcmVzZW50ZWQgYXMgYSBwcm9wZXJ0eSBpbiB0aGVcbiAgICAgKiBkZWNvZGVkIE9iamVjdC4gKi9cbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gIH1cblxuICAvKiogRnVuY3Rpb24gdG8gY3JlYXRlIGFuIE9iamVjdCBpbnRvIHdoaWNoIGRlY29kZWQgcHJvcGVydGllcyB3aWxsXG4gICAqIGJlIHdyaXR0ZW4uXG4gICAqXG4gICAqIFVzZWQgb25seSBmb3IgbGF5b3V0cyB0aGF0IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gdG8gT2JqZWN0XG4gICAqIGluc3RhbmNlcywgd2hpY2ggbWVhbnM6XG4gICAqICoge0BsaW5rIFN0cnVjdHVyZX1cbiAgICogKiB7QGxpbmsgVW5pb259XG4gICAqICoge0BsaW5rIFZhcmlhbnRMYXlvdXR9XG4gICAqICoge0BsaW5rIEJpdFN0cnVjdHVyZX1cbiAgICpcbiAgICogSWYgbGVmdCB1bmRlZmluZWQgdGhlIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgdGhlc2UgbGF5b3V0c1xuICAgKiB3aWxsIGJlIE9iamVjdCBpbnN0YW5jZXMuXG4gICAqXG4gICAqIFNlZSB7QGxpbmsgYmluZENvbnN0cnVjdG9yTGF5b3V0fS5cbiAgICovXG4gIG1ha2VEZXN0aW5hdGlvbk9iamVjdCgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGZyb20gYSBCdWZmZXIgaW50byBhbiBKYXZhU2NyaXB0IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYiAtIHRoZSBidWZmZXIgZnJvbSB3aGljaCBlbmNvZGVkIGRhdGEgaXMgcmVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgZW5jb2RlZCBkYXRhXG4gICAqIHN0YXJ0cy4gIElmIGFic2VudCBhIHplcm8gb2Zmc2V0IGlzIGluZmVycmVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7KE51bWJlcnxBcnJheXxPYmplY3QpfSAtIHRoZSB2YWx1ZSBvZiB0aGUgZGVjb2RlZCBkYXRhLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xheW91dCBpcyBhYnN0cmFjdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhIEphdmFTY3JpcHQgdmFsdWUgaW50byBhIEJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHsoTnVtYmVyfEFycmF5fE9iamVjdCl9IHNyYyAtIHRoZSB2YWx1ZSB0byBiZSBlbmNvZGVkIGludG9cbiAgICogdGhlIGJ1ZmZlci4gIFRoZSB0eXBlIGFjY2VwdGVkIGRlcGVuZHMgb24gdGhlIChzdWItKXR5cGUgb2Yge0BsaW5rXG4gICAqIExheW91dH0uXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBiIC0gdGhlIGJ1ZmZlciBpbnRvIHdoaWNoIGVuY29kZWQgZGF0YSB3aWxsIGJlXG4gICAqIHdyaXR0ZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0XSAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIGVuY29kZWQgZGF0YVxuICAgKiBzdGFydHMuICBJZiBhYnNlbnQgYSB6ZXJvIG9mZnNldCBpcyBpbmZlcnJlZC5cbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGVuY29kZWQsIGluY2x1ZGluZyB0aGVcbiAgICogc3BhY2Ugc2tpcHBlZCBmb3IgaW50ZXJuYWwgcGFkZGluZywgYnV0IGV4Y2x1ZGluZyBkYXRhIHN1Y2ggYXNcbiAgICoge0BsaW5rIFNlcXVlbmNlI2NvdW50fGxlbmd0aHN9IHdoZW4gc3RvcmVkIHtAbGlua1xuICAgKiBFeHRlcm5hbExheW91dHxleHRlcm5hbGx5fS4gIFRoaXMgaXMgdGhlIGFkanVzdG1lbnQgdG8gYG9mZnNldGBcbiAgICogcHJvZHVjaW5nIHRoZSBvZmZzZXQgd2hlcmUgZGF0YSBmb3IgdGhlIG5leHQgbGF5b3V0IHdvdWxkIGJlXG4gICAqIHdyaXR0ZW4uXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMYXlvdXQgaXMgYWJzdHJhY3QnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHNwYW4gb2YgYSBzcGVjaWZpYyBpbnN0YW5jZSBvZiBhIGxheW91dC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGIgLSB0aGUgYnVmZmVyIHRoYXQgY29udGFpbnMgYW4gZW5jb2RlZCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgZW5jb2RlZCBpbnN0YW5jZVxuICAgKiBzdGFydHMuICBJZiBhYnNlbnQgYSB6ZXJvIG9mZnNldCBpcyBpbmZlcnJlZC5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSAtIHRoZSBudW1iZXIgb2YgYnl0ZXMgY292ZXJlZCBieSB0aGUgbGF5b3V0XG4gICAqIGluc3RhbmNlLiAgSWYgdGhpcyBtZXRob2QgaXMgbm90IG92ZXJyaWRkZW4gaW4gYSBzdWJjbGFzcyB0aGVcbiAgICogZGVmaW5pdGlvbi10aW1lIGNvbnN0YW50IHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSB3aWxsIGJlXG4gICAqIHJldHVybmVkLlxuICAgKlxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSAtIGlmIHRoZSBsZW5ndGggb2YgdGhlIHZhbHVlIGNhbm5vdCBiZVxuICAgKiBkZXRlcm1pbmVkLlxuICAgKi9cbiAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICBpZiAoMCA+IHRoaXMuc3Bhbikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV0ZXJtaW5hdGUgc3BhbicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGFuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxpY2F0ZSB0aGUgbGF5b3V0IHVzaW5nIGEgbmV3IHByb3BlcnR5LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZCB0byBnZXQgYSBzdHJ1Y3R1cmFsbHktZXF1aXZhbGVudCBsYXlvdXRcbiAgICogd2l0aCBhIGRpZmZlcmVudCBuYW1lIHNpbmNlIGFsbCB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZXMgYXJlXG4gICAqIGltbXV0YWJsZS5cbiAgICpcbiAgICogKipOT1RFKiogVGhpcyBpcyBhIHNoYWxsb3cgY29weS4gIEFsbCBmaWVsZHMgZXhjZXB0IHtAbGlua1xuICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IGFyZSBzdHJpY3RseSBlcXVhbCB0byB0aGUgb3JpZ2luIGxheW91dC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHZhbHVlIGZvciB7QGxpbmtcbiAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSBpbiB0aGUgcmVwbGljYS5cbiAgICpcbiAgICogQHJldHVybnMge0xheW91dH0gLSB0aGUgY29weSB3aXRoIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9XG4gICAqIHNldCB0byBgcHJvcGVydHlgLlxuICAgKi9cbiAgcmVwbGljYXRlKHByb3BlcnR5KSB7XG4gICAgY29uc3QgcnYgPSBPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICBPYmplY3QuYXNzaWduKHJ2LCB0aGlzKTtcbiAgICBydi5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIHJldHVybiBydjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gb2JqZWN0IGZyb20gbGF5b3V0IHByb3BlcnRpZXMgYW5kIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICpcbiAgICogKipOT1RFKiogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgIGlmIGludm9rZWQgb24gYSBsYXlvdXRcbiAgICogdGhhdCBkb2VzIG5vdCByZXR1cm4gaXRzIHZhbHVlIGFzIGFuIE9iamVjdC4gIE9iamVjdHMgYXJlXG4gICAqIHJldHVybmVkIGZvciB0aGluZ3MgdGhhdCBhcmUgYSB7QGxpbmsgU3RydWN0dXJlfSwgd2hpY2ggaW5jbHVkZXNcbiAgICoge0BsaW5rIFZhcmlhbnRMYXlvdXR8dmFyaWFudCBsYXlvdXRzfSBpZiB0aGV5IGFyZSBzdHJ1Y3R1cmVzLCBhbmRcbiAgICogZXhjbHVkZXMge0BsaW5rIFVuaW9ufXMuICBJZiB5b3Ugd2FudCB0aGlzIGZlYXR1cmUgZm9yIGEgdW5pb25cbiAgICogeW91IG11c3QgdXNlIHtAbGluayBVbmlvbi5nZXRWYXJpYW50fGdldFZhcmlhbnR9IHRvIHNlbGVjdCB0aGVcbiAgICogZGVzaXJlZCBsYXlvdXQuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAtIGFuIGFycmF5IG9mIHZhbHVlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlXG4gICAqIGRlZmF1bHQgb3JkZXIgZm9yIHByb3BlcnRpZXMuICBBcyB3aXRoIHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX1cbiAgICogbGF5b3V0IGVsZW1lbnRzIHRoYXQgaGF2ZSBubyBwcm9wZXJ0eSBuYW1lIGFyZSBza2lwcGVkIHdoZW5cbiAgICogaXRlcmF0aW5nIG92ZXIgdGhlIGFycmF5IHZhbHVlcy4gIE9ubHkgdGhlIHRvcC1sZXZlbCBwcm9wZXJ0aWVzIGFyZVxuICAgKiBhc3NpZ25lZDsgYXJndW1lbnRzIGFyZSBub3QgYXNzaWduZWQgdG8gcHJvcGVydGllcyBvZiBjb250YWluZWRcbiAgICogbGF5b3V0cy4gIEFueSB1bnVzZWQgdmFsdWVzIGFyZSBpZ25vcmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoT2JqZWN0fHVuZGVmaW5lZCl9XG4gICAqL1xuICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuZXhwb3J0cy5MYXlvdXQgPSBMYXlvdXQ7XG5cbi8qIFByb3ZpZGUgdGV4dCB0aGF0IGNhcnJpZXMgYSBuYW1lIChzdWNoIGFzIGZvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbFxuICogYmUgdGhyb3dpbmcgYW4gZXJyb3IpIGFubm90YXRlZCB3aXRoIHRoZSBwcm9wZXJ0eSBvZiBhIGdpdmVuIGxheW91dFxuICogKHN1Y2ggYXMgb25lIGZvciB3aGljaCB0aGUgdmFsdWUgd2FzIHVuYWNjZXB0YWJsZSkuXG4gKlxuICogQGlnbm9yZSAqL1xuZnVuY3Rpb24gbmFtZVdpdGhQcm9wZXJ0eShuYW1lLCBsbykge1xuICBpZiAobG8ucHJvcGVydHkpIHtcbiAgICByZXR1cm4gbmFtZSArICdbJyArIGxvLnByb3BlcnR5ICsgJ10nO1xuICB9XG4gIHJldHVybiBuYW1lO1xufVxuZXhwb3J0cy5uYW1lV2l0aFByb3BlcnR5ID0gbmFtZVdpdGhQcm9wZXJ0eTtcblxuLyoqXG4gKiBBdWdtZW50IGEgY2xhc3Mgc28gdGhhdCBpbnN0YW5jZXMgY2FuIGJlIGVuY29kZWQvZGVjb2RlZCB1c2luZyBhXG4gKiBnaXZlbiBsYXlvdXQuXG4gKlxuICogQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIGNvdXBsZXMgYENsYXNzYCB3aXRoIGBsYXlvdXRgIGluIHNldmVyYWwgd2F5czpcbiAqXG4gKiAqIGBDbGFzcy5sYXlvdXRfYCBiZWNvbWVzIGEgc3RhdGljIG1lbWJlciBwcm9wZXJ0eSBlcXVhbCB0byBgbGF5b3V0YDtcbiAqICogYGxheW91dC5ib3VuZENvbnN0cnVjdG9yX2AgYmVjb21lcyBhIHN0YXRpYyBtZW1iZXIgcHJvcGVydHkgZXF1YWxcbiAqICAgIHRvIGBDbGFzc2A7XG4gKiAqIFRoZSB7QGxpbmsgTGF5b3V0I21ha2VEZXN0aW5hdGlvbk9iamVjdHxtYWtlRGVzdGluYXRpb25PYmplY3QoKX1cbiAqICAgcHJvcGVydHkgb2YgYGxheW91dGAgaXMgc2V0IHRvIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYG5ld1xuICogICBDbGFzcygpYDtcbiAqICogYENsYXNzLmRlY29kZShiLCBvZmZzZXQpYCBiZWNvbWVzIGEgc3RhdGljIG1lbWJlciBmdW5jdGlvbiB0aGF0XG4gKiAgIGRlbGVnYXRlcyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxsYXlvdXQuZGVjb2RlfS4gIFRoZVxuICogICBzeW50aGVzaXplZCBmdW5jdGlvbiBtYXkgYmUgY2FwdHVyZWQgYW5kIGV4dGVuZGVkLlxuICogKiBgQ2xhc3MucHJvdG90eXBlLmVuY29kZShiLCBvZmZzZXQpYCBwcm92aWRlcyBhbiBpbnN0YW5jZSBtZW1iZXJcbiAqICAgZnVuY3Rpb24gdGhhdCBkZWxlZ2F0ZXMgdG8ge0BsaW5rIExheW91dCNlbmNvZGV8bGF5b3V0LmVuY29kZX1cbiAqICAgd2l0aCBgc3JjYCBzZXQgdG8gYHRoaXNgLiAgVGhlIHN5bnRoZXNpemVkIGZ1bmN0aW9uIG1heSBiZVxuICogICBjYXB0dXJlZCBhbmQgZXh0ZW5kZWQsIGJ1dCB3aGVuIHRoZSBleHRlbnNpb24gaXMgaW52b2tlZCBgdGhpc2BcbiAqICAgbXVzdCBiZSBleHBsaWNpdGx5IGJvdW5kIHRvIHRoZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge2NsYXNzfSBDbGFzcyAtIGEgSmF2YVNjcmlwdCBjbGFzcyB3aXRoIGEgbnVsbGFyeVxuICogY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dCAtIHRoZSB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZSB1c2VkIHRvIGVuY29kZVxuICogaW5zdGFuY2VzIG9mIGBDbGFzc2AuXG4gKi9cbmZ1bmN0aW9uIGJpbmRDb25zdHJ1Y3RvckxheW91dChDbGFzcywgbGF5b3V0KSB7XG4gIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgQ2xhc3MpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDbGFzcyBtdXN0IGJlIGNvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKENsYXNzLmhhc093blByb3BlcnR5KCdsYXlvdXRfJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsYXNzIGlzIGFscmVhZHkgYm91bmQgdG8gYSBsYXlvdXQnKTtcbiAgfVxuICBpZiAoIShsYXlvdXQgJiYgKGxheW91dCBpbnN0YW5jZW9mIExheW91dCkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF5b3V0IG11c3QgYmUgYSBMYXlvdXQnKTtcbiAgfVxuICBpZiAobGF5b3V0Lmhhc093blByb3BlcnR5KCdib3VuZENvbnN0cnVjdG9yXycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsYXlvdXQgaXMgYWxyZWFkeSBib3VuZCB0byBhIGNvbnN0cnVjdG9yJyk7XG4gIH1cbiAgQ2xhc3MubGF5b3V0XyA9IGxheW91dDtcbiAgbGF5b3V0LmJvdW5kQ29uc3RydWN0b3JfID0gQ2xhc3M7XG4gIGxheW91dC5tYWtlRGVzdGluYXRpb25PYmplY3QgPSAoKCkgPT4gbmV3IENsYXNzKCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCAnZW5jb2RlJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbihiLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBsYXlvdXQuZW5jb2RlKHRoaXMsIGIsIG9mZnNldCk7XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcywgJ2RlY29kZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oYiwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gbGF5b3V0LmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWUsXG4gIH0pO1xufVxuZXhwb3J0cy5iaW5kQ29uc3RydWN0b3JMYXlvdXQgPSBiaW5kQ29uc3RydWN0b3JMYXlvdXQ7XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgYmVoYXZlcyBsaWtlIGEgbGF5b3V0IGJ1dCBkb2VzIG5vdCBjb25zdW1lIHNwYWNlXG4gKiB3aXRoaW4gaXRzIGNvbnRhaW5pbmcgbGF5b3V0LlxuICpcbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gb2J0YWluIG1ldGFkYXRhIGFib3V0IGEgbWVtYmVyLCBzdWNoIGFzIGFcbiAqIHtAbGluayBPZmZzZXRMYXlvdXR9IHRoYXQgY2FuIHByb3ZpZGUgZGF0YSBhYm91dCBhIHtAbGlua1xuICogTGF5b3V0I2dldFNwYW58dmFsdWUtc3BlY2lmaWMgc3Bhbn0uXG4gKlxuICogKipOT1RFKiogVGhpcyBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzOyB5b3UgY2FuIGNyZWF0ZSBpbnN0YW5jZXNcbiAqIGlmIGl0IGFtdXNlcyB5b3UsIGJ1dCB0aGV5IHdvbid0IHN1cHBvcnQge0BsaW5rXG4gKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnR9IG9yIG90aGVyIHtAbGluayBMYXlvdXR9IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBFeHRlcm5hbExheW91dCBleHRlbmRzIExheW91dCB7XG4gIC8qKlxuICAgKiBSZXR1cm4gYHRydWVgIGlmZiB0aGUgZXh0ZXJuYWwgbGF5b3V0IGRlY29kZXMgdG8gYW4gdW5zaWduZWRcbiAgICogaW50ZWdlciBsYXlvdXQuXG4gICAqXG4gICAqIEluIHRoYXQgY2FzZSBpdCBjYW4gYmUgdXNlZCBhcyB0aGUgc291cmNlIG9mIHtAbGlua1xuICAgKiBTZXF1ZW5jZSNjb3VudHxTZXF1ZW5jZSBjb3VudHN9LCB7QGxpbmsgQmxvYiNsZW5ndGh8QmxvYiBsZW5ndGhzfSxcbiAgICogb3IgYXMge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8ZXh0ZXJuYWwgdW5pb25cbiAgICogZGlzY3JpbWluYXRvcnN9LlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGlzQ291bnQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlcm5hbExheW91dCBpcyBhYnN0cmFjdCcpO1xuICB9XG59XG5cbi8qKlxuICogQW4ge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB0aGF0IGRldGVybWluZXMgaXRzIHtAbGlua1xuICogTGF5b3V0I2RlY29kZXx2YWx1ZX0gYmFzZWQgb24gb2Zmc2V0IGludG8gYW5kIGxlbmd0aCBvZiB0aGUgYnVmZmVyXG4gKiBvbiB3aGljaCBpdCBpcyBpbnZva2VkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZ3JlZWR5fGdyZWVkeX1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW2VsZW1lbnRTcGFuXSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEdyZWVkeUNvdW50I2VsZW1lbnRTcGFufGVsZW1lbnRTcGFufS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtFeHRlcm5hbExheW91dH1cbiAqL1xuY2xhc3MgR3JlZWR5Q291bnQgZXh0ZW5kcyBFeHRlcm5hbExheW91dCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnRTcGFuLCBwcm9wZXJ0eSkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IGVsZW1lbnRTcGFuKSB7XG4gICAgICBlbGVtZW50U3BhbiA9IDE7XG4gICAgfVxuICAgIGlmICgoIU51bWJlci5pc0ludGVnZXIoZWxlbWVudFNwYW4pKSB8fCAoMCA+PSBlbGVtZW50U3BhbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VsZW1lbnRTcGFuIG11c3QgYmUgYSAocG9zaXRpdmUpIGludGVnZXInKTtcbiAgICB9XG4gICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUgbGF5b3V0IGZvciBpbmRpdmlkdWFsIGVsZW1lbnRzIG9mIHRoZSBzZXF1ZW5jZS4gIFRoZSB2YWx1ZVxuICAgICAqIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLiAgSWYgbm90IHByb3ZpZGVkLCB0aGUgdmFsdWUgd2lsbCBiZVxuICAgICAqIDEuICovXG4gICAgdGhpcy5lbGVtZW50U3BhbiA9IGVsZW1lbnRTcGFuO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBpc0NvdW50KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCByZW0gPSBiLmxlbmd0aCAtIG9mZnNldDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihyZW0gLyB0aGlzLmVsZW1lbnRTcGFuKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHRoYXQgc3VwcG9ydHMgYWNjZXNzaW5nIGEge0BsaW5rIExheW91dH1cbiAqIGF0IGEgZml4ZWQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIGFub3RoZXIgTGF5b3V0LiAgVGhlIG9mZnNldCBtYXlcbiAqIGJlIGJlZm9yZSwgd2l0aGluLCBvciBhZnRlciB0aGUgYmFzZSBsYXlvdXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5vZmZzZXR8b2Zmc2V0fVxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBPZmZzZXRMYXlvdXQjbGF5b3V0fGxheW91dH0sIG1vZHVsbyBgcHJvcGVydHlgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0XSAtIEluaXRpYWxpemVzIHtAbGlua1xuICogT2Zmc2V0TGF5b3V0I29mZnNldHxvZmZzZXR9LiAgRGVmYXVsdHMgdG8gemVyby5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIE9wdGlvbmFsIG5ldyBwcm9wZXJ0eSBuYW1lIGZvciBhXG4gKiB7QGxpbmsgTGF5b3V0I3JlcGxpY2F0ZXwgcmVwbGljYX0gb2YgYGxheW91dGAgdG8gYmUgdXNlZCBhcyB7QGxpbmtcbiAqIE9mZnNldExheW91dCNsYXlvdXR8bGF5b3V0fS4gIElmIG5vdCBwcm92aWRlZCB0aGUgYGxheW91dGAgaXMgdXNlZFxuICogdW5jaGFuZ2VkLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBPZmZzZXRMYXlvdXQgZXh0ZW5kcyBFeHRlcm5hbExheW91dCB7XG4gIGNvbnN0cnVjdG9yKGxheW91dCwgb2Zmc2V0LCBwcm9wZXJ0eSkge1xuICAgIGlmICghKGxheW91dCBpbnN0YW5jZW9mIExheW91dCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgfVxuXG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH0gZWxzZSBpZiAoIU51bWJlci5pc0ludGVnZXIob2Zmc2V0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2Zmc2V0IG11c3QgYmUgaW50ZWdlciBvciB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICBzdXBlcihsYXlvdXQuc3BhbiwgcHJvcGVydHkgfHwgbGF5b3V0LnByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUgc3Vib3JkaW5hdGVkIGxheW91dC4gKi9cbiAgICB0aGlzLmxheW91dCA9IGxheW91dDtcblxuICAgIC8qKiBUaGUgbG9jYXRpb24gb2Yge0BsaW5rIE9mZnNldExheW91dCNsYXlvdXR9IHJlbGF0aXZlIHRvIHRoZVxuICAgICAqIHN0YXJ0IG9mIGFub3RoZXIgbGF5b3V0LlxuICAgICAqXG4gICAgICogVGhlIHZhbHVlIG1heSBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSwgYnV0IGFuIGVycm9yIHdpbGwgdGhyb3duXG4gICAgICogaWYgYXQgdGhlIHBvaW50IG9mIHVzZSBpdCBnb2VzIG91dHNpZGUgdGhlIHNwYW4gb2YgdGhlIEJ1ZmZlclxuICAgICAqIGJlaW5nIGFjY2Vzc2VkLiAgKi9cbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgaXNDb3VudCgpIHtcbiAgICByZXR1cm4gKCh0aGlzLmxheW91dCBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICB8fCAodGhpcy5sYXlvdXQgaW5zdGFuY2VvZiBVSW50QkUpKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyB0aGlzLm9mZnNldCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0LmVuY29kZShzcmMsIGIsIG9mZnNldCArIHRoaXMub2Zmc2V0KTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudTh8dTh9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnUxNnx1MTZ9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MjR8dTI0fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC51MzJ8dTMyfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQwfHU0MH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQudTQ4fHU0OH1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVUludCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZFVJbnRMRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgYi53cml0ZVVJbnRMRShzcmMsIG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICByZXR1cm4gdGhpcy5zcGFuO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC51OGJlfHU4YmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQudTE2YmV8dTE2YmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MjRiZXx1MjRiZX0sXG4gKiB7QGxpbmsgbW9kdWxlOkxheW91dC51MzJiZXx1MzJiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC51NDBiZXx1NDBiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0OGJlfHU0OGJlfVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVSW50QkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgIHN1cGVyKCBzcGFuLCBwcm9wZXJ0eSk7XG4gICAgaWYgKDYgPCB0aGlzLnNwYW4pIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkVUludEJFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBiLndyaXRlVUludEJFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIHJldHVybiB0aGlzLnNwYW47XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnM4fHM4fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC5zMTZ8czE2fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczI0fHMyNH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQuczMyfHMzMn0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0MHxzNDB9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnM0OHxzNDh9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEludCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZEludExFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBiLndyaXRlSW50TEUoc3JjLCBvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuczhiZXxzOGJlfSwge0BsaW5rXG4gKiBtb2R1bGU6TGF5b3V0LnMxNmJlfHMxNmJlfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczI0YmV8czI0YmV9LFxuICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuczMyYmV8czMyYmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQuczQwYmV8czQwYmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zNDhiZXxzNDhiZX1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgSW50QkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICB9XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBiLnJlYWRJbnRCRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgYi53cml0ZUludEJFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIHJldHVybiB0aGlzLnNwYW47XG4gIH1cbn1cblxuY29uc3QgVjJFMzIgPSBNYXRoLnBvdygyLCAzMik7XG5cbi8qIFRydWUgbW9kdWx1cyBoaWdoIGFuZCBsb3cgMzItYml0IHdvcmRzLCB3aGVyZSBsb3cgd29yZCBpcyBhbHdheXNcbiAqIG5vbi1uZWdhdGl2ZS4gKi9cbmZ1bmN0aW9uIGRpdm1vZEludDY0KHNyYykge1xuICBjb25zdCBoaTMyID0gTWF0aC5mbG9vcihzcmMgLyBWMkUzMik7XG4gIGNvbnN0IGxvMzIgPSBzcmMgLSAoaGkzMiAqIFYyRTMyKTtcbiAgcmV0dXJuIHtoaTMyLCBsbzMyfTtcbn1cbi8qIFJlY29uc3RydWN0IE51bWJlciBmcm9tIHF1b3RpZW50IGFuZCBub24tbmVnYXRpdmUgcmVtYWluZGVyICovXG5mdW5jdGlvbiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMikge1xuICByZXR1cm4gaGkzMiAqIFYyRTMyICsgbG8zMjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYW4gdW5zaWduZWQgNjQtYml0IGludGVnZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm51NjR8bnU2NH1cbiAqXG4gKiAqKk5PVEUqKiBWYWx1ZXMgd2l0aCBtYWduaXR1ZGUgZ3JlYXRlciB0aGFuIDJeNTIgbWF5IG5vdCBkZWNvZGUgdG9cbiAqIHRoZSBleGFjdCB2YWx1ZSBvZiB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgTmVhclVJbnQ2NCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBsbzMyID0gYi5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgICBjb25zdCBoaTMyID0gYi5yZWFkVUludDMyTEUob2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgYi53cml0ZVVJbnQzMkxFKHNwbGl0LmxvMzIsIG9mZnNldCk7XG4gICAgYi53cml0ZVVJbnQzMkxFKHNwbGl0LmhpMzIsIG9mZnNldCArIDQpO1xuICAgIHJldHVybiA4O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdoZW5cbiAqIGVuY29kZWQgYW5kIGFzIGEgbmVhciBpbnRlZ3JhbCBKYXZhU2NyaXB0IE51bWJlciB3aGVuIGRlY29kZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5udTY0YmV8bnU2NGJlfVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFyVUludDY0QkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgaGkzMiA9IGIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gICAgY29uc3QgbG8zMiA9IGIucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3Qgc3BsaXQgPSBkaXZtb2RJbnQ2NChzcmMpO1xuICAgIGIud3JpdGVVSW50MzJCRShzcGxpdC5oaTMyLCBvZmZzZXQpO1xuICAgIGIud3JpdGVVSW50MzJCRShzcGxpdC5sbzMyLCBvZmZzZXQgKyA0KTtcbiAgICByZXR1cm4gODtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnM2NHxuczY0fVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFySW50NjQgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgbG8zMiA9IGIucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gICAgY29uc3QgaGkzMiA9IGIucmVhZEludDMyTEUob2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgYi53cml0ZVVJbnQzMkxFKHNwbGl0LmxvMzIsIG9mZnNldCk7XG4gICAgYi53cml0ZUludDMyTEUoc3BsaXQuaGkzMiwgb2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIDg7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgNjQtYml0IGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm5zNjRiZXxuczY0YmV9XG4gKlxuICogKipOT1RFKiogVmFsdWVzIHdpdGggbWFnbml0dWRlIGdyZWF0ZXIgdGhhbiAyXjUyIG1heSBub3QgZGVjb2RlIHRvXG4gKiB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE5lYXJJbnQ2NEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IGhpMzIgPSBiLnJlYWRJbnQzMkJFKG9mZnNldCk7XG4gICAgY29uc3QgbG8zMiA9IGIucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3Qgc3BsaXQgPSBkaXZtb2RJbnQ2NChzcmMpO1xuICAgIGIud3JpdGVJbnQzMkJFKHNwbGl0LmhpMzIsIG9mZnNldCk7XG4gICAgYi53cml0ZVVJbnQzMkJFKHNwbGl0LmxvMzIsIG9mZnNldCArIDQpO1xuICAgIHJldHVybiA4O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmYzMnxmMzJ9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBGbG9hdCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgc3VwZXIoNCwgcHJvcGVydHkpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkRmxvYXRMRShvZmZzZXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGIud3JpdGVGbG9hdExFKHNyYywgb2Zmc2V0KTtcbiAgICByZXR1cm4gNDtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mMzJiZXxmMzJiZX1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEZsb2F0QkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIHN1cGVyKDQsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZEZsb2F0QkUob2Zmc2V0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBiLndyaXRlRmxvYXRCRShzcmMsIG9mZnNldCk7XG4gICAgcmV0dXJuIDQ7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZjY0fGY2NH1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIERvdWJsZSBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkRG91YmxlTEUob2Zmc2V0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBiLndyaXRlRG91YmxlTEUoc3JjLCBvZmZzZXQpO1xuICAgIHJldHVybiA4O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmY2NGJlfGY2NGJlfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRG91YmxlQkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZERvdWJsZUJFKG9mZnNldCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgYi53cml0ZURvdWJsZUJFKHNyYywgb2Zmc2V0KTtcbiAgICByZXR1cm4gODtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbnRpZ3VvdXMgc2VxdWVuY2Ugb2YgYSBzcGVjaWZpYyBsYXlvdXQgYXMgYW4gQXJyYXkuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5zZXF8c2VxfVxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBlbGVtZW50TGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU2VxdWVuY2UjZWxlbWVudExheW91dHxlbGVtZW50TGF5b3V0fS5cbiAqXG4gKiBAcGFyYW0geyhOdW1iZXJ8RXh0ZXJuYWxMYXlvdXQpfSBjb3VudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFNlcXVlbmNlI2NvdW50fGNvdW50fS4gIFRoZSBwYXJhbWV0ZXIgbXVzdCBiZSBlaXRoZXIgYSBwb3NpdGl2ZVxuICogaW50ZWdlciBvciBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgU2VxdWVuY2UgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50TGF5b3V0LCBjb3VudCwgcHJvcGVydHkpIHtcbiAgICBpZiAoIShlbGVtZW50TGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWxlbWVudExheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgfVxuICAgIGlmICghKCgoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkgJiYgY291bnQuaXNDb3VudCgpKVxuICAgICAgICAgIHx8IChOdW1iZXIuaXNJbnRlZ2VyKGNvdW50KSAmJiAoMCA8PSBjb3VudCkpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY291bnQgbXVzdCBiZSBub24tbmVnYXRpdmUgaW50ZWdlciAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgJ29yIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICB9XG4gICAgbGV0IHNwYW4gPSAtMTtcbiAgICBpZiAoKCEoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkpXG4gICAgICAgICYmICgwIDwgZWxlbWVudExheW91dC5zcGFuKSkge1xuICAgICAgc3BhbiA9IGNvdW50ICogZWxlbWVudExheW91dC5zcGFuO1xuICAgIH1cblxuICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUgbGF5b3V0IGZvciBpbmRpdmlkdWFsIGVsZW1lbnRzIG9mIHRoZSBzZXF1ZW5jZS4gKi9cbiAgICB0aGlzLmVsZW1lbnRMYXlvdXQgPSBlbGVtZW50TGF5b3V0O1xuXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGJlIGVpdGhlciBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIG9yIGFuIGluc3RhbmNlIG9mXG4gICAgICoge0BsaW5rIEV4dGVybmFsTGF5b3V0fSBmb3Igd2hpY2gge0BsaW5rXG4gICAgICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9IGlzIGB0cnVlYC4gKi9cbiAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGxldCBzcGFuID0gMDtcbiAgICBsZXQgY291bnQgPSB0aGlzLmNvdW50O1xuICAgIGlmIChjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICBjb3VudCA9IGNvdW50LmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH1cbiAgICBpZiAoMCA8IHRoaXMuZWxlbWVudExheW91dC5zcGFuKSB7XG4gICAgICBzcGFuID0gY291bnQgKiB0aGlzLmVsZW1lbnRMYXlvdXQuc3BhbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGlkeCA9IDA7XG4gICAgICB3aGlsZSAoaWR4IDwgY291bnQpIHtcbiAgICAgICAgc3BhbiArPSB0aGlzLmVsZW1lbnRMYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQgKyBzcGFuKTtcbiAgICAgICAgKytpZHg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGFuO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBydiA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgY291bnQgPSB0aGlzLmNvdW50O1xuICAgIGlmIChjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICBjb3VudCA9IGNvdW50LmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8IGNvdW50KSB7XG4gICAgICBydi5wdXNoKHRoaXMuZWxlbWVudExheW91dC5kZWNvZGUoYiwgb2Zmc2V0KSk7XG4gICAgICBvZmZzZXQgKz0gdGhpcy5lbGVtZW50TGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgIGkgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xuICB9XG5cbiAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgU2VxdWVuY2V9LlxuICAgKlxuICAgKiAqKk5PVEUqKiBJZiBgc3JjYCBpcyBzaG9ydGVyIHRoYW4ge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSB0aGVuXG4gICAqIHRoZSB1bnVzZWQgc3BhY2UgaW4gdGhlIGJ1ZmZlciBpcyBsZWZ0IHVuY2hhbmdlZC4gIElmIGBzcmNgIGlzXG4gICAqIGxvbmdlciB0aGFuIHtAbGluayBTZXF1ZW5jZSNjb3VudHxjb3VudH0gdGhlIHVubmVlZGVkIGVsZW1lbnRzIGFyZVxuICAgKiBpZ25vcmVkLlxuICAgKlxuICAgKiAqKk5PVEUqKiBJZiB7QGxpbmsgTGF5b3V0I2NvdW50fGNvdW50fSBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICogRXh0ZXJuYWxMYXlvdXR9IHRoZW4gdGhlIGxlbmd0aCBvZiBgc3JjYCB3aWxsIGJlIGVuY29kZWQgYXMgdGhlXG4gICAqIGNvdW50IGFmdGVyIGBzcmNgIGlzIGVuY29kZWQuICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgZWxvID0gdGhpcy5lbGVtZW50TGF5b3V0O1xuICAgIGNvbnN0IHNwYW4gPSBzcmMucmVkdWNlKChzcGFuLCB2KSA9PiB7XG4gICAgICByZXR1cm4gc3BhbiArIGVsby5lbmNvZGUodiwgYiwgb2Zmc2V0ICsgc3Bhbik7XG4gICAgfSwgMCk7XG4gICAgaWYgKHRoaXMuY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgdGhpcy5jb3VudC5lbmNvZGUoc3JjLmxlbmd0aCwgYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNwYW47XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBjb250aWd1b3VzIHNlcXVlbmNlIG9mIGFyYml0cmFyeSBsYXlvdXQgZWxlbWVudHMgYXMgYW5cbiAqIE9iamVjdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnN0cnVjdHxzdHJ1Y3R9XG4gKlxuICogKipOT1RFKiogVGhlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSBvZiB0aGUgc3RydWN0dXJlIGlzIHZhcmlhYmxlXG4gKiBpZiBhbnkgbGF5b3V0IGluIHtAbGluayBTdHJ1Y3R1cmUjZmllbGRzfGZpZWxkc30gaGFzIGEgdmFyaWFibGVcbiAqIHNwYW4uICBXaGVuIHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kaW5nfSB3ZSBtdXN0IGhhdmUgYSB2YWx1ZSBmb3JcbiAqIGFsbCB2YXJpYWJsZS1sZW5ndGggZmllbGRzLCBvciB3ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIGZpZ3VyZSBvdXRcbiAqIGhvdyBtdWNoIHNwYWNlIHRvIHVzZSBmb3Igc3RvcmFnZS4gIFdlIGNhbiBvbmx5IGlkZW50aWZ5IHRoZSB2YWx1ZVxuICogZm9yIGEgZmllbGQgd2hlbiBpdCBoYXMgYSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS4gIEFzXG4gKiBzdWNoLCBhbHRob3VnaCBhIHN0cnVjdHVyZSBtYXkgY29udGFpbiBib3RoIHVubmFtZWQgZmllbGRzIGFuZFxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkcywgaXQgY2Fubm90IGNvbnRhaW4gYW4gdW5uYW1lZFxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkLlxuICpcbiAqIEBwYXJhbSB7TGF5b3V0W119IGZpZWxkcyAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFN0cnVjdHVyZSNmaWVsZHN8ZmllbGRzfS4gIEFuIGVycm9yIGlzIHJhaXNlZCBpZiB0aGlzIGNvbnRhaW5zIGFcbiAqIHZhcmlhYmxlLWxlbmd0aCBmaWVsZCBmb3Igd2hpY2ggYSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fVxuICogaXMgbm90IGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlY29kZVByZWZpeGVzXSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFN0cnVjdHVyZSNkZWNvZGVQcmVmaXhlc3xwcm9wZXJ0eX0uXG4gKlxuICogQHRocm93cyB7RXJyb3J9IC0gaWYgYGZpZWxkc2AgY29udGFpbnMgYW4gdW5uYW1lZCB2YXJpYWJsZS1sZW5ndGhcbiAqIGxheW91dC5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgU3RydWN0dXJlIGV4dGVuZHMgTGF5b3V0IHtcbiAgY29uc3RydWN0b3IoZmllbGRzLCBwcm9wZXJ0eSwgZGVjb2RlUHJlZml4ZXMpIHtcbiAgICBpZiAoIShBcnJheS5pc0FycmF5KGZpZWxkcylcbiAgICAgICAgICAmJiBmaWVsZHMucmVkdWNlKChhY2MsIHYpID0+IGFjYyAmJiAodiBpbnN0YW5jZW9mIExheW91dCksIHRydWUpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmllbGRzIG11c3QgYmUgYXJyYXkgb2YgTGF5b3V0IGluc3RhbmNlcycpO1xuICAgIH1cbiAgICBpZiAoKCdib29sZWFuJyA9PT0gdHlwZW9mIHByb3BlcnR5KVxuICAgICAgICAmJiAodW5kZWZpbmVkID09PSBkZWNvZGVQcmVmaXhlcykpIHtcbiAgICAgIGRlY29kZVByZWZpeGVzID0gcHJvcGVydHk7XG4gICAgICBwcm9wZXJ0eSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKiBWZXJpZnkgYWJzZW5jZSBvZiB1bm5hbWVkIHZhcmlhYmxlLWxlbmd0aCBmaWVsZHMuICovXG4gICAgZm9yIChjb25zdCBmZCBvZiBmaWVsZHMpIHtcbiAgICAgIGlmICgoMCA+IGZkLnNwYW4pXG4gICAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gZmQucHJvcGVydHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGRzIGNhbm5vdCBjb250YWluIHVubmFtZWQgdmFyaWFibGUtbGVuZ3RoIGxheW91dCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzcGFuID0gLTE7XG4gICAgdHJ5IHtcbiAgICAgIHNwYW4gPSBmaWVsZHMucmVkdWNlKChzcGFuLCBmZCkgPT4gc3BhbiArIGZkLmdldFNwYW4oKSwgMCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG5cbiAgICAvKiogVGhlIHNlcXVlbmNlIG9mIHtAbGluayBMYXlvdXR9IHZhbHVlcyB0aGF0IGNvbXByaXNlIHRoZVxuICAgICAqIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqIFRoZSBpbmRpdmlkdWFsIGVsZW1lbnRzIG5lZWQgbm90IGJlIHRoZSBzYW1lIHR5cGUsIGFuZCBtYXkgYmVcbiAgICAgKiBlaXRoZXIgc2NhbGFyIG9yIGFnZ3JlZ2F0ZSBsYXlvdXRzLiAgSWYgYSBtZW1iZXIgbGF5b3V0IGxlYXZlc1xuICAgICAqIGl0cyB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB1bmRlZmluZWQgdGhlXG4gICAgICogY29ycmVzcG9uZGluZyByZWdpb24gb2YgdGhlIGJ1ZmZlciBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAgICAgKiB3aWxsIG5vdCBiZSBtdXRhdGVkLlxuICAgICAqXG4gICAgICogQHR5cGUge0xheW91dFtdfSAqL1xuICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuXG4gICAgLyoqIENvbnRyb2wgYmVoYXZpb3Igb2Yge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlKCl9IGdpdmVuIHNob3J0XG4gICAgICogYnVmZmVycy5cbiAgICAgKlxuICAgICAqIEluIHNvbWUgc2l0dWF0aW9ucyBhIHN0cnVjdHVyZSBtYW55IGJlIGV4dGVuZGVkIHdpdGggYWRkaXRpb25hbFxuICAgICAqIGZpZWxkcyBvdmVyIHRpbWUsIHdpdGggb2xkZXIgaW5zdGFsbGF0aW9ucyBwcm92aWRpbmcgb25seSBhXG4gICAgICogcHJlZml4IG9mIHRoZSBmdWxsIHN0cnVjdHVyZS4gIElmIHRoaXMgcHJvcGVydHkgaXMgYHRydWVgXG4gICAgICogZGVjb2Rpbmcgd2lsbCBhY2NlcHQgdGhvc2UgYnVmZmVycyBhbmQgbGVhdmUgc3Vic2VxdWVudCBmaWVsZHNcbiAgICAgKiB1bmRlZmluZWQsIGFzIGxvbmcgYXMgdGhlIGJ1ZmZlciBlbmRzIGF0IGEgZmllbGQgYm91bmRhcnkuXG4gICAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC4gKi9cbiAgICB0aGlzLmRlY29kZVByZWZpeGVzID0gISFkZWNvZGVQcmVmaXhlcztcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IHNwYW4gPSAwO1xuICAgIHRyeSB7XG4gICAgICBzcGFuID0gdGhpcy5maWVsZHMucmVkdWNlKChzcGFuLCBmZCkgPT4ge1xuICAgICAgICBjb25zdCBmc3AgPSBmZC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBmc3A7XG4gICAgICAgIHJldHVybiBzcGFuICsgZnNwO1xuICAgICAgfSwgMCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV0ZXJtaW5hdGUgc3BhbicpO1xuICAgIH1cbiAgICByZXR1cm4gc3BhbjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgZGVzdFtmZC5wcm9wZXJ0eV0gPSBmZC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIG9mZnNldCArPSBmZC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICBpZiAodGhpcy5kZWNvZGVQcmVmaXhlc1xuICAgICAgICAgICYmIChiLmxlbmd0aCA9PT0gb2Zmc2V0KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBTdHJ1Y3R1cmV9LlxuICAgKlxuICAgKiBJZiBgc3JjYCBpcyBtaXNzaW5nIGEgcHJvcGVydHkgZm9yIGEgbWVtYmVyIHdpdGggYSBkZWZpbmVkIHtAbGlua1xuICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRoZSBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgYnVmZmVyIGlzXG4gICAqIGxlZnQgdW5tb2RpZmllZC4gKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdE9mZnNldCA9IG9mZnNldDtcbiAgICBsZXQgbGFzdE9mZnNldCA9IDA7XG4gICAgbGV0IGxhc3RXcm90ZSA9IDA7XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgbGV0IHNwYW4gPSBmZC5zcGFuO1xuICAgICAgbGFzdFdyb3RlID0gKDAgPCBzcGFuKSA/IHNwYW4gOiAwO1xuICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgY29uc3QgZnYgPSBzcmNbZmQucHJvcGVydHldO1xuICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmdikge1xuICAgICAgICAgIGxhc3RXcm90ZSA9IGZkLmVuY29kZShmdiwgYiwgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoMCA+IHNwYW4pIHtcbiAgICAgICAgICAgIC8qIFJlYWQgdGhlIGFzLWVuY29kZWQgc3Bhbiwgd2hpY2ggaXMgbm90IG5lY2Vzc2FyaWx5IHRoZVxuICAgICAgICAgICAgICogc2FtZSBhcyB3aGF0IHdlIHdyb3RlLiAqL1xuICAgICAgICAgICAgc3BhbiA9IGZkLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgKz0gc3BhbjtcbiAgICB9XG4gICAgLyogVXNlIChsYXN0T2Zmc2V0ICsgbGFzdFdyb3RlKSBpbnN0ZWFkIG9mIG9mZnNldCBiZWNhdXNlIHRoZSBsYXN0XG4gICAgICogaXRlbSBtYXkgaGF2ZSBoYWQgYSBkeW5hbWljIGxlbmd0aCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBpbmNsdWRlXG4gICAgICogdGhlIHBhZGRpbmcgYmV0d2VlbiBpdCBhbmQgdGhlIGVuZCBvZiB0aGUgc3BhY2UgcmVzZXJ2ZWQgZm9yXG4gICAgICogaXQuICovXG4gICAgcmV0dXJuIChsYXN0T2Zmc2V0ICsgbGFzdFdyb3RlKSAtIGZpcnN0T2Zmc2V0O1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgaWYgKCh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KVxuICAgICAgICAgICYmICgwIDwgdmFsdWVzLmxlbmd0aCkpIHtcbiAgICAgICAgZGVzdFtmZC5wcm9wZXJ0eV0gPSB2YWx1ZXMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFjY2VzcyB0byB0aGUgbGF5b3V0IG9mIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBzdHJ1Y3R1cmUgbWVtYmVyIG9mIGludGVyZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtMYXlvdXR9IC0gdGhlIGxheW91dCBhc3NvY2lhdGVkIHdpdGggYHByb3BlcnR5YCwgb3JcbiAgICogdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcHJvcGVydHkuXG4gICAqL1xuICBsYXlvdXRGb3IocHJvcGVydHkpIHtcbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgaWYgKGZkLnByb3BlcnR5ID09PSBwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gZmQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb2Zmc2V0IG9mIGEgc3RydWN0dXJlIG1lbWJlci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHN0cnVjdHVyZSBtZW1iZXIgb2YgaW50ZXJlc3QuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSB0aGUgb2Zmc2V0IGluIGJ5dGVzIHRvIHRoZSBzdGFydCBvZiBgcHJvcGVydHlgXG4gICAqIHdpdGhpbiB0aGUgc3RydWN0dXJlLCBvciB1bmRlZmluZWQgaWYgYHByb3BlcnR5YCBpcyBub3QgYSBmaWVsZFxuICAgKiB3aXRoaW4gdGhlIHN0cnVjdHVyZS4gIElmIHRoZSBwcm9wZXJ0eSBpcyBhIG1lbWJlciBidXQgZm9sbG93cyBhXG4gICAqIHZhcmlhYmxlLWxlbmd0aCBzdHJ1Y3R1cmUgbWVtYmVyIGEgbmVnYXRpdmUgbnVtYmVyIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqL1xuICBvZmZzZXRPZihwcm9wZXJ0eSkge1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZycpO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICBpZiAoZmQucHJvcGVydHkgPT09IHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAoMCA+IGZkLnNwYW4pIHtcbiAgICAgICAgb2Zmc2V0ID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKDAgPD0gb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCArPSBmZC5zcGFuO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBwcm92aWRlIGEge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IEFQSSBmb3Ige0BsaW5rIFVuaW9ufS5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB0aGUge0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjZW5jb2RlfGVuY29kZX0gb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjZGVjb2RlfGRlY29kZX0gZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gRGVmYXVsdCBmb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBVbmlvbkRpc2NyaW1pbmF0b3Ige1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIC8qKiBUaGUge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdG8gYmUgdXNlZCB3aGVuIHRoZVxuICAgICAqIGRpc2NyaW1pbmF0b3IgaXMgcmVmZXJlbmNlZCBpbiBpc29sYXRpb24gKGdlbmVyYWxseSB3aGVuIHtAbGlua1xuICAgICAqIFVuaW9uI2RlY29kZXxVbmlvbiBkZWNvZGV9IGNhbm5vdCBkZWxlZ2F0ZSB0byBhIHNwZWNpZmljXG4gICAgICogdmFyaWFudCkuICovXG4gICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICB9XG5cbiAgLyoqIEFuYWxvZyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxMYXlvdXQgZGVjb2RlfSBmb3IgdW5pb24gZGlzY3JpbWluYXRvcnMuXG4gICAqXG4gICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBuZWVkIG5vdCByZWZlcmVuY2UgdGhlIGJ1ZmZlciBpZlxuICAgKiB2YXJpYW50IGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZSB0aHJvdWdoIG90aGVyIG1lYW5zLiAqL1xuICBkZWNvZGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmlvbkRpc2NyaW1pbmF0b3IgaXMgYWJzdHJhY3QnKTtcbiAgfVxuXG4gIC8qKiBBbmFsb2cgdG8ge0BsaW5rIExheW91dCNkZWNvZGV8TGF5b3V0IGVuY29kZX0gZm9yIHVuaW9uIGRpc2NyaW1pbmF0b3JzLlxuICAgKlxuICAgKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgbmVlZCBub3Qgc3RvcmUgdGhlIHZhbHVlIGlmXG4gICAqIHZhcmlhbnQgaW5mb3JtYXRpb24gaXMgbWFpbnRhaW5lZCB0aHJvdWdoIG90aGVyIG1lYW5zLiAqL1xuICBlbmNvZGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmlvbkRpc2NyaW1pbmF0b3IgaXMgYWJzdHJhY3QnKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBwcm92aWRlIGEge0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvciBBUEl9IGZvciB7QGxpbmsgVW5pb259IHVzaW5nIGFuXG4gKiB1bnNpZ25lZCBpbnRlZ3JhbCB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZSBsb2NhdGVkIGVpdGhlciBpbnNpZGUgb3JcbiAqIG91dHNpZGUgdGhlIHVuaW9uLlxuICpcbiAqIEBwYXJhbSB7RXh0ZXJuYWxMYXlvdXR9IGxheW91dCAtIGluaXRpYWxpemVzIHtAbGlua1xuICogVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxsYXlvdXR9LiAgTXVzdCBzYXRpc2Z5IHtAbGlua1xuICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gRGVmYXVsdCBmb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjcHJvcGVydHl8cHJvcGVydHl9LCBzdXBlcnNlZGluZyB0aGUgcHJvcGVydHlcbiAqIGZyb20gYGxheW91dGAsIGJ1dCBkZWZhdWx0aW5nIHRvIGB2YXJpYW50YCBpZiBuZWl0aGVyIGBwcm9wZXJ0eWBcbiAqIG5vciBsYXlvdXQgcHJvdmlkZSBhIHByb3BlcnR5IG5hbWUuXG4gKlxuICogQGF1Z21lbnRzIHtVbmlvbkRpc2NyaW1pbmF0b3J9XG4gKi9cbmNsYXNzIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciBleHRlbmRzIFVuaW9uRGlzY3JpbWluYXRvciB7XG4gIGNvbnN0cnVjdG9yKGxheW91dCwgcHJvcGVydHkpIHtcbiAgICBpZiAoISgobGF5b3V0IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpXG4gICAgICAgICAgJiYgbGF5b3V0LmlzQ291bnQoKSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICB9XG5cbiAgICBzdXBlcihwcm9wZXJ0eSB8fCBsYXlvdXQucHJvcGVydHkgfHwgJ3ZhcmlhbnQnKTtcblxuICAgIC8qKiBUaGUge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB1c2VkIHRvIGFjY2VzcyB0aGUgZGlzY3JpbWluYXRvclxuICAgICAqIHZhbHVlLiAqL1xuICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB9XG5cbiAgLyoqIERlbGVnYXRlIGRlY29kaW5nIHRvIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGxheW91dH0uICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQuZGVjb2RlKGIsIG9mZnNldCk7XG4gIH1cblxuICAvKiogRGVsZWdhdGUgZW5jb2RpbmcgdG8ge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8bGF5b3V0fS4gKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0LmVuY29kZShzcmMsIGIsIG9mZnNldCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYW55IG51bWJlciBvZiBzcGFuLWNvbXBhdGlibGUgbGF5b3V0cy5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnVuaW9ufHVuaW9ufVxuICpcbiAqIElmIHRoZSB1bmlvbiBoYXMgYSB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0gdGhhdFxuICogbGF5b3V0IG11c3QgaGF2ZSBhIG5vbi1uZWdhdGl2ZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uICBUaGUgc3BhblxuICogb2YgYSBmaXhlZC1zcGFuIHVuaW9uIGluY2x1ZGVzIGl0cyB7QGxpbmtcbiAqIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gaWYgdGhlIHZhcmlhbnQgaXMgYSB7QGxpbmtcbiAqIFVuaW9uI3VzZXNQcmVmaXhEaXNjcmltaW5hdG9yfHByZWZpeCBvZiB0aGUgdW5pb259LCBwbHVzIHRoZSBzcGFuXG4gKiBvZiBpdHMge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9LlxuICpcbiAqIElmIHRoZSB1bmlvbiBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBsYXlvdXQgdGhlbiB0aGUgZW5jb2RlZCBzcGFuXG4gKiBvZiB0aGUgdW5pb24gZGVwZW5kcyBvbiB0aGUgZW5jb2RlZCBzcGFuIG9mIGl0cyB2YXJpYW50ICh3aGljaCBtYXlcbiAqIGJlIGZpeGVkIG9yIHZhcmlhYmxlKS5cbiAqXG4gKiB7QGxpbmsgVmFyaWFudExheW91dCNsYXlvdXR8VmFyaWFudCBsYXlvdXR9cyBhcmUgYWRkZWQgdGhyb3VnaFxuICoge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkVmFyaWFudH0uICBJZiB0aGUgdW5pb24gaGFzIGEgZGVmYXVsdFxuICogbGF5b3V0LCB0aGUgc3BhbiBvZiB0aGUge0BsaW5rIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dFxuICogY29udGFpbmVkIGJ5IHRoZSB2YXJpYW50fSBtdXN0IG5vdCBleGNlZWQgdGhlIHNwYW4gb2YgdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0gKG1pbnVzIHRoZSBzcGFuIG9mIGEge0BsaW5rXG4gKiBVbmlvbiN1c2VzUHJlZml4RGlzY3JpbWluYXRvcnxwcmVmaXggZGlzcmltaW5hdG9yfSwgaWYgdXNlZCkuICBUaGVcbiAqIHNwYW4gb2YgdGhlIHZhcmlhbnQgd2lsbCBlcXVhbCB0aGUgc3BhbiBvZiB0aGUgdW5pb24gaXRzZWxmLlxuICpcbiAqIFRoZSB2YXJpYW50IGZvciBhIGJ1ZmZlciBjYW4gb25seSBiZSBpZGVudGlmaWVkIGZyb20gdGhlIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNwcm9wZXJ0eXxwcm9wZXJ0eX0gKGluIHRoZSBjYXNlIG9mIHRoZSB7QGxpbmtcbiAqIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9KSwgb3IgYnkgdXNpbmcge0BsaW5rXG4gKiBVbmlvbiNnZXRWYXJpYW50fGdldFZhcmlhbnR9IGFuZCBleGFtaW5pbmcgdGhlIHJlc3VsdGluZyB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXR9IGluc3RhbmNlLlxuICpcbiAqIEEgdmFyaWFudCBjb21wYXRpYmxlIHdpdGggYSBKYXZhU2NyaXB0IG9iamVjdCBjYW4gYmUgaWRlbnRpZmllZFxuICogdXNpbmcge0BsaW5rIFVuaW9uI2dldFNvdXJjZVZhcmlhbnR8Z2V0U291cmNlVmFyaWFudH0uXG4gKlxuICogQHBhcmFtIHsoVW5pb25EaXNjcmltaW5hdG9yfEV4dGVybmFsTGF5b3V0fExheW91dCl9IGRpc2NyIC0gSG93IHRvXG4gKiBpZGVudGlmeSB0aGUgbGF5b3V0IHVzZWQgdG8gaW50ZXJwcmV0IHRoZSB1bmlvbiBjb250ZW50cy4gIFRoZVxuICogcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFVuaW9uRGlzY3JpbWluYXRvcn0sIGFuXG4gKiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHRoYXQgc2F0aXNmaWVzIHtAbGlua1xuICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LCBvciB7QGxpbmsgVUludH0gKG9yIHtAbGlua1xuICogVUludEJFfSkuICBXaGVuIGEgbm9uLWV4dGVybmFsIGxheW91dCBlbGVtZW50IGlzIHBhc3NlZCB0aGUgbGF5b3V0XG4gKiBhcHBlYXJzIGF0IHRoZSBzdGFydCBvZiB0aGUgdW5pb24uICBJbiBhbGwgY2FzZXMgdGhlIChzeW50aGVzaXplZClcbiAqIHtAbGluayBVbmlvbkRpc2NyaW1pbmF0b3J9IGluc3RhbmNlIGlzIHJlY29yZGVkIGFzIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfS5cbiAqXG4gKiBAcGFyYW0geyhMYXlvdXR8bnVsbCl9IGRlZmF1bHRMYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRMYXlvdXR9LiAgSWYgYWJzZW50IGRlZmF1bHRzIHRvIGBudWxsYC5cbiAqIElmIGBudWxsYCB0aGVyZSBpcyBubyBkZWZhdWx0IGxheW91dDogdGhlIHVuaW9uIGhhcyBkYXRhLWRlcGVuZGVudFxuICogbGVuZ3RoIGFuZCBhdHRlbXB0cyB0byBkZWNvZGUgb3IgZW5jb2RlIHVucmVjb2duaXplZCB2YXJpYW50cyB3aWxsXG4gKiB0aHJvdyBhbiBleGNlcHRpb24uICBBIHtAbGluayBMYXlvdXR9IGluc3RhbmNlIG11c3QgaGF2ZSBhXG4gKiBub24tbmVnYXRpdmUge0BsaW5rIExheW91dCNzcGFufHNwYW59LCBhbmQgaWYgaXQgbGFja3MgYSB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0TGF5b3V0fSB3aWxsIGJlIGEge0BsaW5rXG4gKiBMYXlvdXQjcmVwbGljYXRlfHJlcGxpY2F9IHdpdGggcHJvcGVydHkgYGNvbnRlbnRgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVW5pb24gZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihkaXNjciwgZGVmYXVsdExheW91dCwgcHJvcGVydHkpIHtcbiAgICBjb25zdCB1cHYgPSAoKGRpc2NyIGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgICAgIHx8IChkaXNjciBpbnN0YW5jZW9mIFVJbnRCRSkpO1xuICAgIGlmICh1cHYpIHtcbiAgICAgIGRpc2NyID0gbmV3IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcihuZXcgT2Zmc2V0TGF5b3V0KGRpc2NyKSk7XG4gICAgfSBlbHNlIGlmICgoZGlzY3IgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dClcbiAgICAgICAgICAgICAgICYmIGRpc2NyLmlzQ291bnQoKSkge1xuICAgICAgZGlzY3IgPSBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKGRpc2NyKTtcbiAgICB9IGVsc2UgaWYgKCEoZGlzY3IgaW5zdGFuY2VvZiBVbmlvbkRpc2NyaW1pbmF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkaXNjciBtdXN0IGJlIGEgVW5pb25EaXNjcmltaW5hdG9yICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnb3IgYW4gdW5zaWduZWQgaW50ZWdlciBsYXlvdXQnKTtcbiAgICB9XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gZGVmYXVsdExheW91dCkge1xuICAgICAgZGVmYXVsdExheW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghKChudWxsID09PSBkZWZhdWx0TGF5b3V0KVxuICAgICAgICAgIHx8IChkZWZhdWx0TGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RlZmF1bHRMYXlvdXQgbXVzdCBiZSBudWxsIG9yIGEgTGF5b3V0Jyk7XG4gICAgfVxuICAgIGlmIChudWxsICE9PSBkZWZhdWx0TGF5b3V0KSB7XG4gICAgICBpZiAoMCA+IGRlZmF1bHRMYXlvdXQuc3Bhbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlZmF1bHRMYXlvdXQgbXVzdCBoYXZlIGNvbnN0YW50IHNwYW4nKTtcbiAgICAgIH1cbiAgICAgIGlmICh1bmRlZmluZWQgPT09IGRlZmF1bHRMYXlvdXQucHJvcGVydHkpIHtcbiAgICAgICAgZGVmYXVsdExheW91dCA9IGRlZmF1bHRMYXlvdXQucmVwbGljYXRlKCdjb250ZW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogVGhlIHVuaW9uIHNwYW4gY2FuIGJlIGVzdGltYXRlZCBvbmx5IGlmIHRoZXJlJ3MgYSBkZWZhdWx0XG4gICAgICogbGF5b3V0LiAgVGhlIHVuaW9uIHNwYW5zIGl0cyBkZWZhdWx0IGxheW91dCwgcGx1cyBhbnkgcHJlZml4XG4gICAgICogdmFyaWFudCBsYXlvdXQuICBCeSBjb25zdHJ1Y3Rpb24gYm90aCBsYXlvdXRzLCBpZiBwcmVzZW50LCBoYXZlXG4gICAgICogbm9uLW5lZ2F0aXZlIHNwYW4uICovXG4gICAgbGV0IHNwYW4gPSAtMTtcbiAgICBpZiAoZGVmYXVsdExheW91dCkge1xuICAgICAgc3BhbiA9IGRlZmF1bHRMYXlvdXQuc3BhbjtcbiAgICAgIGlmICgoMCA8PSBzcGFuKSAmJiB1cHYpIHtcbiAgICAgICAgc3BhbiArPSBkaXNjci5sYXlvdXQuc3BhbjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuXG4gICAgLyoqIFRoZSBpbnRlcmZhY2UgZm9yIHRoZSBkaXNjcmltaW5hdG9yIHZhbHVlIGluIGlzb2xhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgYSB7QGxpbmsgVW5pb25EaXNjcmltaW5hdG9yfSBlaXRoZXIgcGFzc2VkIHRvIHRoZVxuICAgICAqIGNvbnN0cnVjdG9yIG9yIHN5bnRoZXNpemVkIGZyb20gdGhlIGBkaXNjcmAgY29uc3RydWN0b3JcbiAgICAgKiBhcmd1bWVudC4gIHtAbGlua1xuICAgICAqIFVuaW9uI3VzZXNQcmVmaXhEaXNjcmltaW5hdG9yfHVzZXNQcmVmaXhEaXNjcmltaW5hdG9yfSB3aWxsIGJlXG4gICAgICogYHRydWVgIGlmZiB0aGUgYGRpc2NyYCBwYXJhbWV0ZXIgd2FzIGEgbm9uLW9mZnNldCB7QGxpbmtcbiAgICAgKiBMYXlvdXR9IGluc3RhbmNlLiAqL1xuICAgIHRoaXMuZGlzY3JpbWluYXRvciA9IGRpc2NyO1xuXG4gICAgLyoqIGB0cnVlYCBpZiB0aGUge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gaXMgdGhlXG4gICAgICogZmlyc3QgZmllbGQgaW4gdGhlIHVuaW9uLlxuICAgICAqXG4gICAgICogSWYgYGZhbHNlYCB0aGUgZGlzY3JpbWluYXRvciBpcyBvYnRhaW5lZCBmcm9tIHNvbWV3aGVyZVxuICAgICAqIGVsc2UuICovXG4gICAgdGhpcy51c2VzUHJlZml4RGlzY3JpbWluYXRvciA9IHVwdjtcblxuICAgIC8qKiBUaGUgbGF5b3V0IGZvciBub24tZGlzY3JpbWluYXRvciBjb250ZW50IHdoZW4gdGhlIHZhbHVlIG9mIHRoZVxuICAgICAqIGRpc2NyaW1pbmF0b3IgaXMgbm90IHJlY29nbml6ZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSB2YWx1ZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiAgSXQgaXNcbiAgICAgKiBzdHJ1Y3R1cmFsbHkgZXF1aXZhbGVudCB0byB0aGUgc2Vjb25kIGNvbXBvbmVudCBvZiB7QGxpbmtcbiAgICAgKiBVbmlvbiNsYXlvdXR8bGF5b3V0fSBidXQgbWF5IGhhdmUgYSBkaWZmZXJlbnQgcHJvcGVydHlcbiAgICAgKiBuYW1lLiAqL1xuICAgIHRoaXMuZGVmYXVsdExheW91dCA9IGRlZmF1bHRMYXlvdXQ7XG5cbiAgICAvKiogQSByZWdpc3RyeSBvZiBhbGxvd2VkIHZhcmlhbnRzLlxuICAgICAqXG4gICAgICogVGhlIGtleXMgYXJlIHVuc2lnbmVkIGludGVnZXJzIHdoaWNoIHNob3VsZCBiZSBjb21wYXRpYmxlIHdpdGhcbiAgICAgKiB7QGxpbmsgVW5pb24uZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfS4gIFRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIGlzIHRoZSBjb3JyZXNwb25kaW5nIHtAbGluayBWYXJpYW50TGF5b3V0fSBpbnN0YW5jZXMgYXNzaWduZWRcbiAgICAgKiB0byB0aGlzIHVuaW9uIGJ5IHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZFZhcmlhbnR9LlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhlIHJlZ2lzdHJ5IHJlbWFpbnMgbXV0YWJsZSBzbyB0aGF0IHZhcmlhbnRzIGNhbiBiZVxuICAgICAqIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZGVkfSBhdCBhbnkgdGltZS4gIFVzZXJzIHNob3VsZCBub3RcbiAgICAgKiBtYW5pcHVsYXRlIHRoZSBjb250ZW50IG9mIHRoaXMgcHJvcGVydHkuICovXG4gICAgdGhpcy5yZWdpc3RyeSA9IHt9O1xuXG4gICAgLyogUHJpdmF0ZSB2YXJpYWJsZSB1c2VkIHdoZW4gaW52b2tpbmcgZ2V0U291cmNlVmFyaWFudCAqL1xuICAgIGxldCBib3VuZEdldFNvdXJjZVZhcmlhbnQgPSB0aGlzLmRlZmF1bHRHZXRTb3VyY2VWYXJpYW50LmJpbmQodGhpcyk7XG5cbiAgICAvKiogRnVuY3Rpb24gdG8gaW5mZXIgdGhlIHZhcmlhbnQgc2VsZWN0ZWQgYnkgYSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogRGVmYXVsdHMgdG8ge0BsaW5rXG4gICAgICogVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9IGJ1dCBtYXlcbiAgICAgKiBiZSBvdmVycmlkZGVuIHVzaW5nIHtAbGlua1xuICAgICAqIFVuaW9uI2NvbmZpZ0dldFNvdXJjZVZhcmlhbnR8Y29uZmlnR2V0U291cmNlVmFyaWFudH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIC0gYXMgd2l0aCB7QGxpbmtcbiAgICAgKiBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7KHVuZGVmaW5lZHxWYXJpYW50TGF5b3V0KX0gVGhlIGRlZmF1bHQgdmFyaWFudFxuICAgICAqIChgdW5kZWZpbmVkYCkgb3IgZmlyc3QgcmVnaXN0ZXJlZCB2YXJpYW50IHRoYXQgdXNlcyBhIHByb3BlcnR5XG4gICAgICogYXZhaWxhYmxlIGluIGBzcmNgLiAqL1xuICAgIHRoaXMuZ2V0U291cmNlVmFyaWFudCA9IGZ1bmN0aW9uKHNyYykge1xuICAgICAgcmV0dXJuIGJvdW5kR2V0U291cmNlVmFyaWFudChzcmMpO1xuICAgIH07XG5cbiAgICAvKiogRnVuY3Rpb24gdG8gb3ZlcnJpZGUgdGhlIGltcGxlbWVudGF0aW9uIG9mIHtAbGlua1xuICAgICAqIFVuaW9uI2dldFNvdXJjZVZhcmlhbnR8Z2V0U291cmNlVmFyaWFudH0uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBpZiB0aGUgZGVzaXJlZCB2YXJpYW50IGNhbm5vdCBiZSBpZGVudGlmaWVkIHVzaW5nIHRoZVxuICAgICAqIGFsZ29yaXRobSBvZiB7QGxpbmtcbiAgICAgKiBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0uXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGUgcHJvdmlkZWQgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGJvdW5kIHRvIHRoaXNcbiAgICAgKiBVbmlvbiBpbnN0YW5jZSwgcHJvdmlkaW5nIGxvY2FsIGFjY2VzcyB0byB7QGxpbmtcbiAgICAgKiBVbmlvbiNyZWdpc3RyeXxyZWdpc3RyeX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnc3YgLSBhIGZ1bmN0aW9uIHRoYXQgZm9sbG93cyB0aGUgQVBJIG9mXG4gICAgICoge0BsaW5rIFVuaW9uI2RlZmF1bHRHZXRTb3VyY2VWYXJpYW50fGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50fS4gKi9cbiAgICB0aGlzLmNvbmZpZ0dldFNvdXJjZVZhcmlhbnQgPSBmdW5jdGlvbihnc3YpIHtcbiAgICAgIGJvdW5kR2V0U291cmNlVmFyaWFudCA9IGdzdi5iaW5kKHRoaXMpO1xuICAgIH07XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIC8qIERlZmF1bHQgbGF5b3V0cyBhbHdheXMgaGF2ZSBub24tbmVnYXRpdmUgc3Bhbiwgc28gd2UgZG9uJ3QgaGF2ZVxuICAgICAqIG9uZSBhbmQgd2UgaGF2ZSB0byByZWNvZ25pemUgdGhlIHZhcmlhbnQgd2hpY2ggd2lsbCBpbiB0dXJuXG4gICAgICogZGV0ZXJtaW5lIHRoZSBzcGFuLiAqL1xuICAgIGNvbnN0IHZsbyA9IHRoaXMuZ2V0VmFyaWFudChiLCBvZmZzZXQpO1xuICAgIGlmICghdmxvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBkZXRlcm1pbmUgc3BhbiBmb3IgdW5yZWNvZ25pemVkIHZhcmlhbnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZsby5nZXRTcGFuKGIsIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHRvIGluZmVyIGEgcmVnaXN0ZXJlZCBVbmlvbiB2YXJpYW50IGNvbXBhdGlibGUgd2l0aCBgc3JjYC5cbiAgICpcbiAgICogVGhlIGZpcnN0IHNhdGlzaWZpZWQgcnVsZSBpbiB0aGUgZm9sbG93aW5nIHNlcXVlbmNlIGRlZmluZXMgdGhlXG4gICAqIHJldHVybiB2YWx1ZTpcbiAgICogKiBJZiBgc3JjYCBoYXMgcHJvcGVydGllcyBtYXRjaGluZyB0aGUgVW5pb24gZGlzY3JpbWluYXRvciBhbmRcbiAgICogICB0aGUgZGVmYXVsdCBsYXlvdXQsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkIHJlZ2FyZGxlc3Mgb2YgdGhlXG4gICAqICAgdmFsdWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkgKHRoaXMgZW5zdXJlcyB0aGUgZGVmYXVsdFxuICAgKiAgIGxheW91dCB3aWxsIGJlIHVzZWQpO1xuICAgKiAqIElmIGBzcmNgIGhhcyBhIHByb3BlcnR5IG1hdGNoaW5nIHRoZSBVbmlvbiBkaXNjcmltaW5hdG9yLCB0aGVcbiAgICogICB2YWx1ZSBvZiB0aGUgZGlzY3JpbWluYXRvciBpZGVudGlmaWVzIGEgcmVnaXN0ZXJlZCB2YXJpYW50LCBhbmRcbiAgICogICBlaXRoZXIgKGEpIHRoZSB2YXJpYW50IGhhcyBubyBsYXlvdXQsIG9yIChiKSBgc3JjYCBoYXMgdGhlXG4gICAqICAgdmFyaWFudCdzIHByb3BlcnR5LCB0aGVuIHRoZSB2YXJpYW50IGlzIHJldHVybmVkIChiZWNhdXNlIHRoZVxuICAgKiAgIHNvdXJjZSBzYXRpc2ZpZXMgdGhlIGNvbnN0cmFpbnRzIG9mIHRoZSB2YXJpYW50IGl0IGlkZW50aWZpZXMpO1xuICAgKiAqIElmIGBzcmNgIGRvZXMgbm90IGhhdmUgYSBwcm9wZXJ0eSBtYXRjaGluZyB0aGUgVW5pb25cbiAgICogICBkaXNjcmltaW5hdG9yLCBidXQgZG9lcyBoYXZlIGEgcHJvcGVydHkgbWF0Y2hpbmcgYSByZWdpc3RlcmVkXG4gICAqICAgdmFyaWFudCwgdGhlbiB0aGUgdmFyaWFudCBpcyByZXR1cm5lZCAoYmVjYXVzZSB0aGUgc291cmNlXG4gICAqICAgbWF0Y2hlcyBhIHZhcmlhbnQgd2l0aG91dCBhbiBleHBsaWNpdCBjb25mbGljdCk7XG4gICAqICogQW4gZXJyb3IgaXMgdGhyb3duIChiZWNhdXNlIHdlIGVpdGhlciBjYW4ndCBpZGVudGlmeSBhIHZhcmlhbnQsXG4gICAqICAgb3Igd2Ugd2VyZSBleHBsaWNpdGx5IHRvbGQgdGhlIHZhcmlhbnQgYnV0IGNhbid0IHNhdGlzZnkgaXQpLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIC0gYW4gb2JqZWN0IHByZXN1bWVkIHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICAgKiB0aGUgY29udGVudCBvZiB0aGUgVW5pb24uXG4gICAqXG4gICAqIEByZXR1cm4geyh1bmRlZmluZWR8VmFyaWFudExheW91dCl9IC0gYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBpZiBgc3JjYCBjYW5ub3QgYmUgYXNzb2NpYXRlZCB3aXRoIGEgZGVmYXVsdCBvclxuICAgKiByZWdpc3RlcmVkIHZhcmlhbnQuXG4gICAqL1xuICBkZWZhdWx0R2V0U291cmNlVmFyaWFudChzcmMpIHtcbiAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KHRoaXMuZGlzY3JpbWluYXRvci5wcm9wZXJ0eSkpIHtcbiAgICAgIGlmICh0aGlzLmRlZmF1bHRMYXlvdXRcbiAgICAgICAgICAmJiBzcmMuaGFzT3duUHJvcGVydHkodGhpcy5kZWZhdWx0TGF5b3V0LnByb3BlcnR5KSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3QgdmxvID0gdGhpcy5yZWdpc3RyeVtzcmNbdGhpcy5kaXNjcmltaW5hdG9yLnByb3BlcnR5XV07XG4gICAgICBpZiAodmxvXG4gICAgICAgICAgJiYgKCghdmxvLmxheW91dClcbiAgICAgICAgICAgICAgfHwgc3JjLmhhc093blByb3BlcnR5KHZsby5wcm9wZXJ0eSkpKSB7XG4gICAgICAgIHJldHVybiB2bG87XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgdGFnIGluIHRoaXMucmVnaXN0cnkpIHtcbiAgICAgICAgY29uc3QgdmxvID0gdGhpcy5yZWdpc3RyeVt0YWddO1xuICAgICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KHZsby5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICByZXR1cm4gdmxvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGluZmVyIHNyYyB2YXJpYW50Jyk7XG4gIH1cblxuICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gZm9yIHtAbGluayBVbmlvbn0uXG4gICAqXG4gICAqIElmIHRoZSB2YXJpYW50IGlzIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fHJlZ2lzdGVyZWR9IHRoZSByZXR1cm5cbiAgICogdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgdGhhdCB2YXJpYW50LCB3aXRoIG5vIGV4cGxpY2l0XG4gICAqIGRpc2NyaW1pbmF0b3IuICBPdGhlcndpc2UgdGhlIHtAbGluayBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRcbiAgICogbGF5b3V0fSBpcyB1c2VkIHRvIGRlY29kZSB0aGUgY29udGVudC4gKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IGRlc3Q7XG4gICAgY29uc3QgZGxvID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgIGNvbnN0IGRpc2NyID0gZGxvLmRlY29kZShiLCBvZmZzZXQpO1xuICAgIGxldCBjbG8gPSB0aGlzLnJlZ2lzdHJ5W2Rpc2NyXTtcbiAgICBpZiAodW5kZWZpbmVkID09PSBjbG8pIHtcbiAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgIGNsbyA9IHRoaXMuZGVmYXVsdExheW91dDtcbiAgICAgIGlmICh0aGlzLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgIGNvbnRlbnRPZmZzZXQgPSBkbG8ubGF5b3V0LnNwYW47XG4gICAgICB9XG4gICAgICBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgIGRlc3RbZGxvLnByb3BlcnR5XSA9IGRpc2NyO1xuICAgICAgZGVzdFtjbG8ucHJvcGVydHldID0gdGhpcy5kZWZhdWx0TGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzdCA9IGNsby5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBVbmlvbn0uXG4gICAqXG4gICAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGBzcmNgIG9iamVjdCBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHVuaW9uJ3NcbiAgICoge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9LiAgVG8gZW5jb2RlIHZhcmlhbnRzXG4gICAqIHVzZSB0aGUgYXBwcm9wcmlhdGUgdmFyaWFudC1zcGVjaWZpYyB7QGxpbmsgVmFyaWFudExheW91dCNlbmNvZGV9XG4gICAqIG1ldGhvZC4gKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCB2bG8gPSB0aGlzLmdldFNvdXJjZVZhcmlhbnQoc3JjKTtcbiAgICBpZiAodW5kZWZpbmVkID09PSB2bG8pIHtcbiAgICAgIGNvbnN0IGRsbyA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgIGNvbnN0IGNsbyA9IHRoaXMuZGVmYXVsdExheW91dDtcbiAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgIGlmICh0aGlzLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgIGNvbnRlbnRPZmZzZXQgPSBkbG8ubGF5b3V0LnNwYW47XG4gICAgICB9XG4gICAgICBkbG8uZW5jb2RlKHNyY1tkbG8ucHJvcGVydHldLCBiLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIGNvbnRlbnRPZmZzZXQgKyBjbG8uZW5jb2RlKHNyY1tjbG8ucHJvcGVydHldLCBiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdmxvLmVuY29kZShzcmMsIGIsIG9mZnNldCk7XG4gIH1cblxuICAvKiogUmVnaXN0ZXIgYSBuZXcgdmFyaWFudCBzdHJ1Y3R1cmUgd2l0aGluIGEgdW5pb24uICBUaGUgbmV3bHlcbiAgICogY3JlYXRlZCB2YXJpYW50IGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFyaWFudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICogVmFyaWFudExheW91dCN2YXJpYW50fHZhcmlhbnR9LlxuICAgKlxuICAgKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gICAqXG4gICAqIEByZXR1cm4ge1ZhcmlhbnRMYXlvdXR9ICovXG4gIGFkZFZhcmlhbnQodmFyaWFudCwgbGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IHJ2ID0gbmV3IFZhcmlhbnRMYXlvdXQodGhpcywgdmFyaWFudCwgbGF5b3V0LCBwcm9wZXJ0eSk7XG4gICAgdGhpcy5yZWdpc3RyeVt2YXJpYW50XSA9IHJ2O1xuICAgIHJldHVybiBydjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheW91dCBhc3NvY2lhdGVkIHdpdGggYSByZWdpc3RlcmVkIHZhcmlhbnQuXG4gICAqXG4gICAqIElmIGB2YmAgZG9lcyBub3QgcHJvZHVjZSBhIHJlZ2lzdGVyZWQgdmFyaWFudCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICAgKiBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogQHBhcmFtIHsoTnVtYmVyfEJ1ZmZlcil9IHZiIC0gZWl0aGVyIHRoZSB2YXJpYW50IG51bWJlciwgb3IgYVxuICAgKiBidWZmZXIgZnJvbSB3aGljaCB0aGUgZGlzY3JpbWluYXRvciBpcyB0byBiZSByZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IC0gb2Zmc2V0IGludG8gYHZiYCBmb3IgdGhlIHN0YXJ0IG9mIHRoZVxuICAgKiB1bmlvbi4gIFVzZWQgb25seSB3aGVuIGB2YmAgaXMgYW4gaW5zdGFuY2Ugb2Yge0J1ZmZlcn0uXG4gICAqXG4gICAqIEByZXR1cm4geyh7VmFyaWFudExheW91dH18dW5kZWZpbmVkKX1cbiAgICovXG4gIGdldFZhcmlhbnQodmIsIG9mZnNldCkge1xuICAgIGxldCB2YXJpYW50ID0gdmI7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YikpIHtcbiAgICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgfVxuICAgICAgdmFyaWFudCA9IHRoaXMuZGlzY3JpbWluYXRvci5kZWNvZGUodmIsIG9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5W3ZhcmlhbnRdO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgc3BlY2lmaWMgdmFyaWFudCB3aXRoaW4gYSBjb250YWluaW5nIHVuaW9uLlxuICpcbiAqICoqTk9URSoqIFRoZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0gb2YgdGhlIHZhcmlhbnQgbWF5IGluY2x1ZGVcbiAqIHRoZSBzcGFuIG9mIHRoZSB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSB1c2VkIHRvXG4gKiBpZGVudGlmeSBpdCwgYnV0IHZhbHVlcyByZWFkIGFuZCB3cml0dGVuIHVzaW5nIHRoZSB2YXJpYW50IHN0cmljdGx5XG4gKiBjb25mb3JtIHRvIHRoZSBjb250ZW50IG9mIHtAbGluayBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LlxuICpcbiAqICoqTk9URSoqIFVzZXIgY29kZSBzaG91bGQgbm90IGludm9rZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiAgVXNlXG4gKiB0aGUgdW5pb24ge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkVmFyaWFudH0gaGVscGVyIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge1VuaW9ufSB1bmlvbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXQjdW5pb258dW5pb259LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YXJpYW50IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogVmFyaWFudExheW91dCN2YXJpYW50fHZhcmlhbnR9LlxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBbbGF5b3V0XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uICBJZiBhYnNlbnQgdGhlIHZhcmlhbnQgY2FycmllcyBub1xuICogZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uICBVbmxpa2UgbWFueSBvdGhlciBsYXlvdXRzLCB2YXJpYW50XG4gKiBsYXlvdXRzIG5vcm1hbGx5IGluY2x1ZGUgYSBwcm9wZXJ0eSBuYW1lIHNvIHRoZXkgY2FuIGJlIGlkZW50aWZpZWRcbiAqIHdpdGhpbiB0aGVpciBjb250YWluaW5nIHtAbGluayBVbmlvbn0uICBUaGUgcHJvcGVydHkgaWRlbnRpZmllciBtYXlcbiAqIGJlIGFic2VudCBvbmx5IGlmIGBsYXlvdXRgIGlzIGlzIGFic2VudC5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVmFyaWFudExheW91dCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHVuaW9uLCB2YXJpYW50LCBsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgaWYgKCEodW5pb24gaW5zdGFuY2VvZiBVbmlvbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuaW9uIG11c3QgYmUgYSBVbmlvbicpO1xuICAgIH1cbiAgICBpZiAoKCFOdW1iZXIuaXNJbnRlZ2VyKHZhcmlhbnQpKSB8fCAoMCA+IHZhcmlhbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YXJpYW50IG11c3QgYmUgYSAobm9uLW5lZ2F0aXZlKSBpbnRlZ2VyJyk7XG4gICAgfVxuICAgIGlmICgoJ3N0cmluZycgPT09IHR5cGVvZiBsYXlvdXQpXG4gICAgICAgICYmICh1bmRlZmluZWQgPT09IHByb3BlcnR5KSkge1xuICAgICAgcHJvcGVydHkgPSBsYXlvdXQ7XG4gICAgICBsYXlvdXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobGF5b3V0KSB7XG4gICAgICBpZiAoIShsYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgICB9XG4gICAgICBpZiAoKG51bGwgIT09IHVuaW9uLmRlZmF1bHRMYXlvdXQpXG4gICAgICAgICAgJiYgKDAgPD0gbGF5b3V0LnNwYW4pXG4gICAgICAgICAgJiYgKGxheW91dC5zcGFuID4gdW5pb24uZGVmYXVsdExheW91dC5zcGFuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhcmlhbnQgc3BhbiBleGNlZWRzIHNwYW4gb2YgY29udGFpbmluZyB1bmlvbicpO1xuICAgICAgfVxuICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFyaWFudCBtdXN0IGhhdmUgYSBTdHJpbmcgcHJvcGVydHknKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHNwYW4gPSB1bmlvbi5zcGFuO1xuICAgIGlmICgwID4gdW5pb24uc3Bhbikge1xuICAgICAgc3BhbiA9IGxheW91dCA/IGxheW91dC5zcGFuIDogMDtcbiAgICAgIGlmICgoMCA8PSBzcGFuKSAmJiB1bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICBzcGFuICs9IHVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUge0BsaW5rIFVuaW9ufSB0byB3aGljaCB0aGlzIHZhcmlhbnQgYmVsb25ncy4gKi9cbiAgICB0aGlzLnVuaW9uID0gdW5pb247XG5cbiAgICAvKiogVGhlIHVuc2lnbmVkIGludGVncmFsIHZhbHVlIGlkZW50aWZ5aW5nIHRoaXMgdmFyaWFudCB3aXRoaW5cbiAgICAgKiB0aGUge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gb2YgdGhlIGNvbnRhaW5pbmdcbiAgICAgKiB1bmlvbi4gKi9cbiAgICB0aGlzLnZhcmlhbnQgPSB2YXJpYW50O1xuXG4gICAgLyoqIFRoZSB7QGxpbmsgTGF5b3V0fSB0byBiZSB1c2VkIHdoZW4gcmVhZGluZy93cml0aW5nIHRoZVxuICAgICAqIG5vbi1kaXNjcmltaW5hdG9yIHBhcnQgb2YgdGhlIHtAbGlua1xuICAgICAqIFZhcmlhbnRMYXlvdXQjdW5pb258dW5pb259LiAgSWYgYG51bGxgIHRoZSB2YXJpYW50IGNhcnJpZXMgbm9cbiAgICAgKiBkYXRhLiAqL1xuICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0IHx8IG51bGw7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICAvKiBXaWxsIGJlIGVxdWFsIHRvIHRoZSBjb250YWluaW5nIHVuaW9uIHNwYW4gaWYgdGhhdCBpcyBub3RcbiAgICAgICAqIHZhcmlhYmxlLiAqL1xuICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgIGNvbnRlbnRPZmZzZXQgPSB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgfVxuICAgIC8qIFNwYW4gaXMgZGVmaW5lZCBzb2xlbHkgYnkgdGhlIHZhcmlhbnQgKGFuZCBwcmVmaXggZGlzY3JpbWluYXRvcikgKi9cbiAgICByZXR1cm4gY29udGVudE9mZnNldCArIHRoaXMubGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGlmICh0aGlzICE9PSB0aGlzLnVuaW9uLmdldFZhcmlhbnQoYiwgb2Zmc2V0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YXJpYW50IG1pc21hdGNoJyk7XG4gICAgfVxuICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgY29udGVudE9mZnNldCA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICB9XG4gICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICBkZXN0W3RoaXMucHJvcGVydHldID0gdGhpcy5sYXlvdXQuZGVjb2RlKGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wZXJ0eSkge1xuICAgICAgZGVzdFt0aGlzLnByb3BlcnR5XSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICBkZXN0W3RoaXMudW5pb24uZGlzY3JpbWluYXRvci5wcm9wZXJ0eV0gPSB0aGlzLnZhcmlhbnQ7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgY29udGVudE9mZnNldCA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICB9XG4gICAgaWYgKHRoaXMubGF5b3V0XG4gICAgICAgICYmICghc3JjLmhhc093blByb3BlcnR5KHRoaXMucHJvcGVydHkpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFyaWFudCBsYWNrcyBwcm9wZXJ0eSAnICsgdGhpcy5wcm9wZXJ0eSk7XG4gICAgfVxuICAgIHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5lbmNvZGUodGhpcy52YXJpYW50LCBiLCBvZmZzZXQpO1xuICAgIGxldCBzcGFuID0gY29udGVudE9mZnNldDtcbiAgICBpZiAodGhpcy5sYXlvdXQpIHtcbiAgICAgIHRoaXMubGF5b3V0LmVuY29kZShzcmNbdGhpcy5wcm9wZXJ0eV0sIGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgc3BhbiArPSB0aGlzLmxheW91dC5nZXRTcGFuKGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgaWYgKCgwIDw9IHRoaXMudW5pb24uc3BhbilcbiAgICAgICAgICAmJiAoc3BhbiA+IHRoaXMudW5pb24uc3BhbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmNvZGVkIHZhcmlhbnQgb3ZlcnJ1bnMgY29udGFpbmluZyB1bmlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3BhbjtcbiAgfVxuXG4gIC8qKiBEZWxlZ2F0ZSB7QGxpbmsgTGF5b3V0I2Zyb21BcnJheXxmcm9tQXJyYXl9IHRvIHtAbGlua1xuICAgKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LiAqL1xuICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZnJvbUFycmF5KHZhbHVlcyk7XG4gICAgfVxuICB9XG59XG5cbi8qKiBKYXZhU2NyaXB0IGNob3NlIHRvIGRlZmluZSBiaXR3aXNlIG9wZXJhdGlvbnMgYXMgb3BlcmF0aW5nIG9uXG4gKiBzaWduZWQgMzItYml0IHZhbHVlcyBpbiAyJ3MgY29tcGxlbWVudCBmb3JtLCBtZWFuaW5nIGFueSBpbnRlZ2VyXG4gKiB3aXRoIGJpdCAzMSBzZXQgaXMgZ29pbmcgdG8gbG9vayBuZWdhdGl2ZS4gIEZvciByaWdodCBzaGlmdHMgdGhhdCdzXG4gKiBub3QgYSBwcm9ibGVtLCBiZWNhdXNlIGA+Pj5gIGlzIGEgbG9naWNhbCBzaGlmdCwgYnV0IGZvciBldmVyeVxuICogb3RoZXIgYml0d2lzZSBvcGVyYXRvciB3ZSBoYXZlIHRvIGNvbXBlbnNhdGUgZm9yIHBvc3NpYmxlIG5lZ2F0aXZlXG4gKiByZXN1bHRzLiAqL1xuZnVuY3Rpb24gZml4Qml0d2lzZVJlc3VsdCh2KSB7XG4gIGlmICgwID4gdikge1xuICAgIHYgKz0gMHgxMDAwMDAwMDA7XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5cbi8qKlxuICogQ29udGFpbiBhIHNlcXVlbmNlIG9mIGJpdCBmaWVsZHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmJpdHN8Yml0c31cbiAqXG4gKiBUaGlzIGlzIGEgY29udGFpbmVyIGVsZW1lbnQ7IHdpdGhpbiBpdCB0aGVyZSBhcmUge0BsaW5rIEJpdEZpZWxkfVxuICogaW5zdGFuY2VzIHRoYXQgcHJvdmlkZSB0aGUgZXh0cmFjdGVkIHByb3BlcnRpZXMuICBUaGUgY29udGFpbmVyXG4gKiBzaW1wbHkgZGVmaW5lcyB0aGUgYWdncmVnYXRlIHJlcHJlc2VudGF0aW9uIGFuZCBpdHMgYml0IG9yZGVyaW5nLlxuICogVGhlIHJlcHJlc2VudGF0aW9uIGlzIGFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgd2l0aCBudW1lcmljXG4gKiBvciB7QGxpbmsgQm9vbGVhbn0gdmFsdWVzLlxuICpcbiAqIHtAbGluayBCaXRGaWVsZH1zIGFyZSBhZGRlZCB3aXRoIHRoZSB7QGxpbmtcbiAqIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRGaWVsZH0gYW5kIHtAbGlua1xuICogQml0U3RydWN0dXJlI2FkZEJvb2xlYW58YWRkQm9vbGVhbn0gbWV0aG9kcy5cblxuICogQHBhcmFtIHtMYXlvdXR9IHdvcmQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBCaXRTdHJ1Y3R1cmUjd29yZHx3b3JkfS4gIFRoZSBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZlxuICoge0BsaW5rIFVJbnR9IChvciB7QGxpbmsgVUludEJFfSkgdGhhdCBpcyBubyBtb3JlIHRoYW4gNCBieXRlcyB3aWRlLlxuICpcbiAqIEBwYXJhbSB7Ym9vbH0gW21zYl0gLSBgdHJ1ZWAgaWYgdGhlIGJpdCBudW1iZXJpbmcgc3RhcnRzIGF0IHRoZVxuICogbW9zdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGNvbnRhaW5pbmcgd29yZDsgYGZhbHNlYCAoZGVmYXVsdCkgaWZcbiAqIGl0IHN0YXJ0cyBhdCB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBjb250YWluaW5nIHdvcmQuICBJZlxuICogdGhlIHBhcmFtZXRlciBhdCB0aGlzIHBvc2l0aW9uIGlzIGEgc3RyaW5nIGFuZCBgcHJvcGVydHlgIGlzXG4gKiBgdW5kZWZpbmVkYCB0aGUgdmFsdWUgb2YgdGhpcyBhcmd1bWVudCB3aWxsIGluc3RlYWQgYmUgdXNlZCBhcyB0aGVcbiAqIHZhbHVlIG9mIGBwcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBCaXRTdHJ1Y3R1cmUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcih3b3JkLCBtc2IsIHByb3BlcnR5KSB7XG4gICAgaWYgKCEoKHdvcmQgaW5zdGFuY2VvZiBVSW50KVxuICAgICAgICAgIHx8ICh3b3JkIGluc3RhbmNlb2YgVUludEJFKSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3dvcmQgbXVzdCBiZSBhIFVJbnQgb3IgVUludEJFIGxheW91dCcpO1xuICAgIH1cbiAgICBpZiAoKCdzdHJpbmcnID09PSB0eXBlb2YgbXNiKVxuICAgICAgICAmJiAodW5kZWZpbmVkID09PSBwcm9wZXJ0eSkpIHtcbiAgICAgIHByb3BlcnR5ID0gbXNiO1xuICAgICAgbXNiID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoNCA8IHdvcmQuc3Bhbikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3dvcmQgY2Fubm90IGV4Y2VlZCAzMiBiaXRzJyk7XG4gICAgfVxuICAgIHN1cGVyKHdvcmQuc3BhbiwgcHJvcGVydHkpO1xuXG4gICAgLyoqIFRoZSBsYXlvdXQgdXNlZCBmb3IgdGhlIHBhY2tlZCB2YWx1ZS4gIHtAbGluayBCaXRGaWVsZH1cbiAgICAgKiBpbnN0YW5jZXMgYXJlIHBhY2tlZCBzZXF1ZW50aWFsbHkgZGVwZW5kaW5nIG9uIHtAbGlua1xuICAgICAqIEJpdFN0cnVjdHVyZSNtc2J8bXNifS4gKi9cbiAgICB0aGlzLndvcmQgPSB3b3JkO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhlIGJpdCBzZXF1ZW5jZXMgYXJlIHBhY2tlZCBzdGFydGluZyBhdCB0aGUgbW9zdFxuICAgICAqIHNpZ25pZmljYW50IGJpdCBncm93aW5nIGRvd24gKGB0cnVlYCksIG9yIHRoZSBsZWFzdCBzaWduaWZpY2FudFxuICAgICAqIGJpdCBncm93aW5nIHVwIChgZmFsc2VgKS5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIFJlZ2FyZGxlc3Mgb2YgdGhpcyB2YWx1ZSwgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZlxuICAgICAqIGFueSB7QGxpbmsgQml0RmllbGR9IHZhbHVlIGlzIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlXG4gICAgICogY29ycmVzcG9uZGluZyBzZWN0aW9uIG9mIHRoZSBwYWNrZWQgdmFsdWUuICovXG4gICAgdGhpcy5tc2IgPSAhIW1zYjtcblxuICAgIC8qKiBUaGUgc2VxdWVuY2Ugb2Yge0BsaW5rIEJpdEZpZWxkfSBsYXlvdXRzIHRoYXQgY29tcHJpc2UgdGhlXG4gICAgICogcGFja2VkIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIFRoZSBhcnJheSByZW1haW5zIG11dGFibGUgdG8gYWxsb3cgZmllbGRzIHRvIGJlIHtAbGlua1xuICAgICAqIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRlZH0gYWZ0ZXIgY29uc3RydWN0aW9uLiAgVXNlcnMgc2hvdWxkXG4gICAgICogbm90IG1hbmlwdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhpcyBwcm9wZXJ0eS4qL1xuICAgIHRoaXMuZmllbGRzID0gW107XG5cbiAgICAvKiBTdG9yYWdlIGZvciB0aGUgdmFsdWUuICBDYXB0dXJlIGEgdmFyaWFibGUgaW5zdGVhZCBvZiB1c2luZyBhblxuICAgICAqIGluc3RhbmNlIHByb3BlcnR5IGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBhbnl0aGluZyB0byBjaGFuZ2UgdGhlXG4gICAgICogdmFsdWUgd2l0aG91dCBnb2luZyB0aHJvdWdoIHRoZSBtdXRhdG9yLiAqL1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgdGhpcy5fcGFja2VkU2V0VmFsdWUgPSBmdW5jdGlvbih2KSB7XG4gICAgICB2YWx1ZSA9IGZpeEJpdHdpc2VSZXN1bHQodik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHRoaXMuX3BhY2tlZEdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGNvbnN0IGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLndvcmQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgdGhpcy5fcGFja2VkU2V0VmFsdWUodmFsdWUpO1xuICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgIGlmICh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KSB7XG4gICAgICAgIGRlc3RbZmQucHJvcGVydHldID0gZmQuZGVjb2RlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBCaXRTdHJ1Y3R1cmV9LlxuICAgKlxuICAgKiBJZiBgc3JjYCBpcyBtaXNzaW5nIGEgcHJvcGVydHkgZm9yIGEgbWVtYmVyIHdpdGggYSBkZWZpbmVkIHtAbGlua1xuICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRoZSBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgcGFja2VkXG4gICAqIHZhbHVlIGlzIGxlZnQgdW5tb2RpZmllZC4gIFVudXNlZCBiaXRzIGFyZSBhbHNvIGxlZnQgdW5tb2RpZmllZC4gKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMud29yZC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICB0aGlzLl9wYWNrZWRTZXRWYWx1ZSh2YWx1ZSk7XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgY29uc3QgZnYgPSBzcmNbZmQucHJvcGVydHldO1xuICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmdikge1xuICAgICAgICAgIGZkLmVuY29kZShmdik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud29yZC5lbmNvZGUodGhpcy5fcGFja2VkR2V0VmFsdWUoKSwgYiwgb2Zmc2V0KTtcbiAgfVxuXG4gIC8qKiBSZWdpc3RlciBhIG5ldyBiaXRmaWVsZCB3aXRoIGEgY29udGFpbmluZyBiaXQgc3RydWN0dXJlLiAgVGhlXG4gICAqIHJlc3VsdGluZyBiaXRmaWVsZCBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGJpdHMgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICpcbiAgICogQHJldHVybiB7Qml0RmllbGR9ICovXG4gIGFkZEZpZWxkKGJpdHMsIHByb3BlcnR5KSB7XG4gICAgY29uc3QgYmYgPSBuZXcgQml0RmllbGQodGhpcywgYml0cywgcHJvcGVydHkpO1xuICAgIHRoaXMuZmllbGRzLnB1c2goYmYpO1xuICAgIHJldHVybiBiZjtcbiAgfVxuXG4gIC8qKiBBcyB3aXRoIHtAbGluayBCaXRTdHJ1Y3R1cmUjYWRkRmllbGR8YWRkRmllbGR9IGZvciBzaW5nbGUtYml0XG4gICAqIGZpZWxkcyB3aXRoIGBib29sZWFuYCB2YWx1ZSByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAqL1xuICBhZGRCb29sZWFuKHByb3BlcnR5KSB7XG4gICAgLy8gVGhpcyBpcyBteSBCb29sZWFuLCBub3QgdGhlIEphdmFzY3JpcHQgb25lLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctd3JhcHBlcnNcbiAgICBjb25zdCBiZiA9IG5ldyBCb29sZWFuKHRoaXMsIHByb3BlcnR5KTtcbiAgICB0aGlzLmZpZWxkcy5wdXNoKGJmKTtcbiAgICByZXR1cm4gYmY7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFjY2VzcyB0byB0aGUgYml0IGZpZWxkIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgYml0IGZpZWxkIG9mIGludGVyZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtCaXRGaWVsZH0gLSB0aGUgZmllbGQgYXNzb2NpYXRlZCB3aXRoIGBwcm9wZXJ0eWAsIG9yXG4gICAqIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBzdWNoIHByb3BlcnR5LlxuICAgKi9cbiAgZmllbGRGb3IocHJvcGVydHkpIHtcbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgaWYgKGZkLnByb3BlcnR5ID09PSBwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gZmQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgc2VxdWVuY2Ugb2YgYml0cyB3aXRoaW4gYSB7QGxpbmsgQml0U3RydWN0dXJlfS5cbiAqXG4gKiBBbGwgYml0IGZpZWxkIHZhbHVlcyBhcmUgcmVwcmVzZW50ZWQgYXMgdW5zaWduZWQgaW50ZWdlcnMuXG4gKlxuICogKipOT1RFKiogVXNlciBjb2RlIHNob3VsZCBub3QgaW52b2tlIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuXG4gKiBVc2UgdGhlIGNvbnRhaW5lciB7QGxpbmsgQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZEZpZWxkfSBoZWxwZXJcbiAqIG1ldGhvZC5cbiAqXG4gKiAqKk5PVEUqKiBCaXRGaWVsZCBpbnN0YW5jZXMgYXJlIG5vdCBpbnN0YW5jZXMgb2Yge0BsaW5rIExheW91dH1cbiAqIHNpbmNlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSBtZWFzdXJlcyA4LWJpdCB1bml0cy5cbiAqXG4gKiBAcGFyYW0ge0JpdFN0cnVjdHVyZX0gY29udGFpbmVyIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogQml0RmllbGQjY29udGFpbmVyfGNvbnRhaW5lcn0uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGJpdHMgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICovXG5jbGFzcyBCaXRGaWVsZCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgYml0cywgcHJvcGVydHkpIHtcbiAgICBpZiAoIShjb250YWluZXIgaW5zdGFuY2VvZiBCaXRTdHJ1Y3R1cmUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb250YWluZXIgbXVzdCBiZSBhIEJpdFN0cnVjdHVyZScpO1xuICAgIH1cbiAgICBpZiAoKCFOdW1iZXIuaXNJbnRlZ2VyKGJpdHMpKSB8fCAoMCA+PSBiaXRzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYml0cyBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICB9XG4gICAgY29uc3QgdG90YWxCaXRzID0gOCAqIGNvbnRhaW5lci5zcGFuO1xuICAgIGNvbnN0IHVzZWRCaXRzID0gY29udGFpbmVyLmZpZWxkcy5yZWR1Y2UoKHN1bSwgZmQpID0+IHN1bSArIGZkLmJpdHMsIDApO1xuICAgIGlmICgoYml0cyArIHVzZWRCaXRzKSA+IHRvdGFsQml0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaXRzIHRvbyBsb25nIGZvciBzcGFuIHJlbWFpbmRlciAoJ1xuICAgICAgICAgICAgICAgICAgICAgICsgKHRvdGFsQml0cyAtIHVzZWRCaXRzKSArICcgb2YgJ1xuICAgICAgICAgICAgICAgICAgICAgICsgdG90YWxCaXRzICsgJyByZW1haW4pJyk7XG4gICAgfVxuXG4gICAgLyoqIFRoZSB7QGxpbmsgQml0U3RydWN0dXJlfSBpbnN0YW5jZSB0byB3aGljaCB0aGlzIGJpdCBmaWVsZFxuICAgICAqIGJlbG9uZ3MuICovXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAvKiogVGhlIHNwYW4gb2YgdGhpcyB2YWx1ZSBpbiBiaXRzLiAqL1xuICAgIHRoaXMuYml0cyA9IGJpdHM7XG5cbiAgICAvKiogQSBtYXNrIG9mIHtAbGluayBCaXRGaWVsZCNiaXRzfGJpdHN9IGJpdHMgaXNvbGF0aW5nIHZhbHVlIGJpdHNcbiAgICAgKiB0aGF0IGZpdCB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqXG4gICAgICogVGhhdCBpcywgaXQgbWFza3MgYSB2YWx1ZSB0aGF0IGhhcyBub3QgeWV0IGJlZW4gc2hpZnRlZCBpbnRvXG4gICAgICogcG9zaXRpb24gd2l0aGluIGl0cyBjb250YWluaW5nIHBhY2tlZCBpbnRlZ2VyLiAqL1xuICAgIHRoaXMudmFsdWVNYXNrID0gKDEgPDwgYml0cykgLSAxO1xuICAgIGlmICgzMiA9PT0gYml0cykgeyAvLyBzaGlmdGVkIHZhbHVlIG91dCBvZiByYW5nZVxuICAgICAgdGhpcy52YWx1ZU1hc2sgPSAweEZGRkZGRkZGO1xuICAgIH1cblxuICAgIC8qKiBUaGUgb2Zmc2V0IG9mIHRoZSB2YWx1ZSB3aXRoaW4gdGhlIGNvbnRhaW5pbmcgcGFja2VkIHVuc2lnbmVkXG4gICAgICogaW50ZWdlci4gIFRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIHBhY2tlZCB2YWx1ZSBpcyBhdFxuICAgICAqIG9mZnNldCB6ZXJvLCByZWdhcmRsZXNzIG9mIGJpdCBvcmRlcmluZyB1c2VkLiAqL1xuICAgIHRoaXMuc3RhcnQgPSB1c2VkQml0cztcbiAgICBpZiAodGhpcy5jb250YWluZXIubXNiKSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdG90YWxCaXRzIC0gdXNlZEJpdHMgLSBiaXRzO1xuICAgIH1cblxuICAgIC8qKiBBIG1hc2sgb2Yge0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30gaXNvbGF0aW5nIHRoZSBmaWVsZCB2YWx1ZVxuICAgICAqIHdpdGhpbiB0aGUgY29udGFpbmluZyBwYWNrZWQgdW5zaWduZWQgaW50ZWdlci4gKi9cbiAgICB0aGlzLndvcmRNYXNrID0gZml4Qml0d2lzZVJlc3VsdCh0aGlzLnZhbHVlTWFzayA8PCB0aGlzLnN0YXJ0KTtcblxuICAgIC8qKiBUaGUgcHJvcGVydHkgbmFtZSB1c2VkIHdoZW4gdGhpcyBiaXRmaWVsZCBpcyByZXByZXNlbnRlZCBpbiBhblxuICAgICAqIE9iamVjdC5cbiAgICAgKlxuICAgICAqIEludGVuZGVkIHRvIGJlIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eX0uXG4gICAgICpcbiAgICAgKiBJZiBsZWZ0IHVuZGVmaW5lZCB0aGUgY29ycmVzcG9uZGluZyBzcGFuIG9mIGJpdHMgd2lsbCBiZVxuICAgICAqIHRyZWF0ZWQgYXMgcGFkZGluZzogaXQgd2lsbCBub3QgYmUgbXV0YXRlZCBieSB7QGxpbmtcbiAgICAgKiBMYXlvdXQjZW5jb2RlfGVuY29kZX0gbm9yIHJlcHJlc2VudGVkIGFzIGEgcHJvcGVydHkgaW4gdGhlXG4gICAgICogZGVjb2RlZCBPYmplY3QuICovXG4gICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICB9XG5cbiAgLyoqIFN0b3JlIGEgdmFsdWUgaW50byB0aGUgY29ycmVzcG9uZGluZyBzdWJzZXF1ZW5jZSBvZiB0aGUgY29udGFpbmluZ1xuICAgKiBiaXQgZmllbGQuICovXG4gIGRlY29kZSgpIHtcbiAgICBjb25zdCB3b3JkID0gdGhpcy5jb250YWluZXIuX3BhY2tlZEdldFZhbHVlKCk7XG4gICAgY29uc3Qgd29yZFZhbHVlID0gZml4Qml0d2lzZVJlc3VsdCh3b3JkICYgdGhpcy53b3JkTWFzayk7XG4gICAgY29uc3QgdmFsdWUgPSB3b3JkVmFsdWUgPj4+IHRoaXMuc3RhcnQ7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqIFN0b3JlIGEgdmFsdWUgaW50byB0aGUgY29ycmVzcG9uZGluZyBzdWJzZXF1ZW5jZSBvZiB0aGUgY29udGFpbmluZ1xuICAgKiBiaXQgZmllbGQuXG4gICAqXG4gICAqICoqTk9URSoqIFRoaXMgaXMgbm90IGEgc3BlY2lhbGl6YXRpb24gb2Yge0BsaW5rXG4gICAqIExheW91dCNlbmNvZGV8TGF5b3V0LmVuY29kZX0gYW5kIHRoZXJlIGlzIG5vIHJldHVybiB2YWx1ZS4gKi9cbiAgZW5jb2RlKHZhbHVlKSB7XG4gICAgaWYgKCghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpXG4gICAgICAgIHx8ICh2YWx1ZSAhPT0gZml4Qml0d2lzZVJlc3VsdCh2YWx1ZSAmIHRoaXMudmFsdWVNYXNrKSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobmFtZVdpdGhQcm9wZXJ0eSgnQml0RmllbGQuZW5jb2RlJywgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnIHZhbHVlIG11c3QgYmUgaW50ZWdlciBub3QgZXhjZWVkaW5nICcgKyB0aGlzLnZhbHVlTWFzayk7XG4gICAgfVxuICAgIGNvbnN0IHdvcmQgPSB0aGlzLmNvbnRhaW5lci5fcGFja2VkR2V0VmFsdWUoKTtcbiAgICBjb25zdCB3b3JkVmFsdWUgPSBmaXhCaXR3aXNlUmVzdWx0KHZhbHVlIDw8IHRoaXMuc3RhcnQpO1xuICAgIHRoaXMuY29udGFpbmVyLl9wYWNrZWRTZXRWYWx1ZShmaXhCaXR3aXNlUmVzdWx0KHdvcmQgJiB+dGhpcy53b3JkTWFzaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB3b3JkVmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNpbmdsZSBiaXQgd2l0aGluIGEge0BsaW5rIEJpdFN0cnVjdHVyZX0gYXMgYVxuICogSmF2YVNjcmlwdCBib29sZWFuLlxuICpcbiAqICoqTk9URSoqIFVzZXIgY29kZSBzaG91bGQgbm90IGludm9rZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LlxuICogVXNlIHRoZSBjb250YWluZXIge0BsaW5rIEJpdFN0cnVjdHVyZSNhZGRCb29sZWFufGFkZEJvb2xlYW59IGhlbHBlclxuICogbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7Qml0U3RydWN0dXJlfSBjb250YWluZXIgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBCaXRGaWVsZCNjb250YWluZXJ8Y29udGFpbmVyfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtCaXRGaWVsZH1cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tZXh0ZW5kLW5hdGl2ZSAqL1xuY2xhc3MgQm9vbGVhbiBleHRlbmRzIEJpdEZpZWxkIHtcbiAgY29uc3RydWN0b3IoY29udGFpbmVyLCBwcm9wZXJ0eSkge1xuICAgIHN1cGVyKGNvbnRhaW5lciwgMSwgcHJvcGVydHkpO1xuICB9XG5cbiAgLyoqIE92ZXJyaWRlIHtAbGluayBCaXRGaWVsZCNkZWNvZGV8ZGVjb2RlfSBmb3Ige0BsaW5rIEJvb2xlYW58Qm9vbGVhbn0uXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuICEhQml0RmllbGQucHJvdG90eXBlLmRlY29kZS5jYWxsKHRoaXMsIGIsIG9mZnNldCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZSh2YWx1ZSkge1xuICAgIGlmICgnYm9vbGVhbicgPT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgLy8gQml0RmllbGQgcmVxdWlyZXMgaW50ZWdlciB2YWx1ZXNcbiAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gQml0RmllbGQucHJvdG90eXBlLmVuY29kZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSBuby1leHRlbmQtbmF0aXZlICovXG5cbi8qKlxuICogQ29udGFpbiBhIGZpeGVkLWxlbmd0aCBibG9jayBvZiBhcmJpdHJhcnkgZGF0YSwgcmVwcmVzZW50ZWQgYXMgYVxuICogQnVmZmVyLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuYmxvYnxibG9ifVxuICpcbiAqIEBwYXJhbSB7KE51bWJlcnxFeHRlcm5hbExheW91dCl9IGxlbmd0aCAtIGluaXRpYWxpemVzIHtAbGlua1xuICogQmxvYiNsZW5ndGh8bGVuZ3RofS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEJsb2IgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIHByb3BlcnR5KSB7XG4gICAgaWYgKCEoKChsZW5ndGggaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkgJiYgbGVuZ3RoLmlzQ291bnQoKSlcbiAgICAgICAgICB8fCAoTnVtYmVyLmlzSW50ZWdlcihsZW5ndGgpICYmICgwIDw9IGxlbmd0aCkpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGVuZ3RoIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlciAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgJ29yIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICB9XG5cbiAgICBsZXQgc3BhbiA9IC0xO1xuICAgIGlmICghKGxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSkge1xuICAgICAgc3BhbiA9IGxlbmd0aDtcbiAgICB9XG4gICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhlIGJsb2IuXG4gICAgICpcbiAgICAgKiBUaGlzIG1heSBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBvciBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICAgKiBFeHRlcm5hbExheW91dH0gdGhhdCBzYXRpc2ZpZXMge0BsaW5rXG4gICAgICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LiAqL1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBnZXRTcGFuKGIsIG9mZnNldCkge1xuICAgIGxldCBzcGFuID0gdGhpcy5zcGFuO1xuICAgIGlmICgwID4gc3Bhbikge1xuICAgICAgc3BhbiA9IHRoaXMubGVuZ3RoLmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gc3BhbjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IHNwYW4gPSB0aGlzLnNwYW47XG4gICAgaWYgKDAgPiBzcGFuKSB7XG4gICAgICBzcGFuID0gdGhpcy5sZW5ndGguZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBiLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3Bhbik7XG4gIH1cblxuICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBCbG9ifS5cbiAgICpcbiAgICogKipOT1RFKiogSWYge0BsaW5rIExheW91dCNjb3VudHxjb3VudH0gaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rXG4gICAqIEV4dGVybmFsTGF5b3V0fSB0aGVuIHRoZSBsZW5ndGggb2YgYHNyY2Agd2lsbCBiZSBlbmNvZGVkIGFzIHRoZVxuICAgKiBjb3VudCBhZnRlciBgc3JjYCBpcyBlbmNvZGVkLiAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBsZXQgc3BhbiA9IHRoaXMubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICBzcGFuID0gc3JjLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKCEoQnVmZmVyLmlzQnVmZmVyKHNyYylcbiAgICAgICAgICAmJiAoc3BhbiA9PT0gc3JjLmxlbmd0aCkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG5hbWVXaXRoUHJvcGVydHkoJ0Jsb2IuZW5jb2RlJywgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnIHJlcXVpcmVzIChsZW5ndGggJyArIHNwYW4gKyAnKSBCdWZmZXIgYXMgc3JjJyk7XG4gICAgfVxuICAgIGlmICgob2Zmc2V0ICsgc3BhbikgPiBiLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuY29kaW5nIG92ZXJydW5zIEJ1ZmZlcicpO1xuICAgIH1cbiAgICBiLndyaXRlKHNyYy50b1N0cmluZygnaGV4JyksIG9mZnNldCwgc3BhbiwgJ2hleCcpO1xuICAgIGlmICh0aGlzLmxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICB0aGlzLmxlbmd0aC5lbmNvZGUoc3BhbiwgYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNwYW47XG4gIH1cbn1cblxuLyoqXG4gKiBDb250YWluIGEgYE5VTGAtdGVybWluYXRlZCBVVEY4IHN0cmluZy5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmNzdHJ8Y3N0cn1cbiAqXG4gKiAqKk5PVEUqKiBBbnkgVVRGOCBzdHJpbmcgdGhhdCBpbmNvcnBvcmF0ZXMgYSB6ZXJvLXZhbHVlZCBieXRlIHdpbGxcbiAqIG5vdCBiZSBjb3JyZWN0bHkgZGVjb2RlZCBieSB0aGlzIGxheW91dC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIENTdHJpbmcgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIHN1cGVyKC0xLCBwcm9wZXJ0eSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2IgbXVzdCBiZSBhIEJ1ZmZlcicpO1xuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGxldCBpZHggPSBvZmZzZXQ7XG4gICAgd2hpbGUgKChpZHggPCBiLmxlbmd0aCkgJiYgKDAgIT09IGJbaWR4XSkpIHtcbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gMSArIGlkeCAtIG9mZnNldDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCwgZGVzdCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IHNwYW4gPSB0aGlzLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICByZXR1cm4gYi5zbGljZShvZmZzZXQsIG9mZnNldCArIHNwYW4gLSAxKS50b1N0cmluZygndXRmLTgnKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICAvKiBNdXN0IGZvcmNlIHRoaXMgdG8gYSBzdHJpbmcsIGxlc3QgaXQgYmUgYSBudW1iZXIgYW5kIHRoZVxuICAgICAqIFwidXRmOC1lbmNvZGluZ1wiIGJlbG93IGFjdHVhbGx5IGFsbG9jYXRlIGEgYnVmZmVyIG9mIGxlbmd0aFxuICAgICAqIHNyYyAqL1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHNyYykge1xuICAgICAgc3JjID0gc3JjLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHNyY2IgPSBuZXcgQnVmZmVyKHNyYywgJ3V0ZjgnKTtcbiAgICBjb25zdCBzcGFuID0gc3JjYi5sZW5ndGg7XG4gICAgaWYgKChvZmZzZXQgKyBzcGFuKSA+IGIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5jb2Rpbmcgb3ZlcnJ1bnMgQnVmZmVyJyk7XG4gICAgfVxuICAgIHNyY2IuY29weShiLCBvZmZzZXQpO1xuICAgIGJbb2Zmc2V0ICsgc3Bhbl0gPSAwO1xuICAgIHJldHVybiBzcGFuICsgMTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnRhaW4gYSBVVEY4IHN0cmluZyB3aXRoIGltcGxpY2l0IGxlbmd0aC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnV0Zjh8dXRmOH1cbiAqXG4gKiAqKk5PVEUqKiBCZWNhdXNlIHRoZSBsZW5ndGggaXMgaW1wbGljaXQgaW4gdGhlIHNpemUgb2YgdGhlIGJ1ZmZlclxuICogdGhpcyBsYXlvdXQgc2hvdWxkIGJlIHVzZWQgb25seSBpbiBpc29sYXRpb24sIG9yIGluIGEgc2l0dWF0aW9uXG4gKiB3aGVyZSB0aGUgbGVuZ3RoIGNhbiBiZSBleHByZXNzZWQgYnkgb3BlcmF0aW5nIG9uIGEgc2xpY2Ugb2YgdGhlXG4gKiBjb250YWluaW5nIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW21heFNwYW5dIC0gdGhlIG1heGltdW0gbGVuZ3RoIGFsbG93ZWQgZm9yIGVuY29kZWRcbiAqIHN0cmluZyBjb250ZW50LiAgSWYgbm90IHByb3ZpZGVkIHRoZXJlIGlzIG5vIGJvdW5kIG9uIHRoZSBhbGxvd2VkXG4gKiBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVVRGOCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKG1heFNwYW4sIHByb3BlcnR5KSB7XG4gICAgaWYgKCgnc3RyaW5nJyA9PT0gdHlwZW9mIG1heFNwYW4pXG4gICAgICAgICYmICh1bmRlZmluZWQgPT09IHByb3BlcnR5KSkge1xuICAgICAgcHJvcGVydHkgPSBtYXhTcGFuO1xuICAgICAgbWF4U3BhbiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gbWF4U3Bhbikge1xuICAgICAgbWF4U3BhbiA9IC0xO1xuICAgIH0gZWxzZSBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4U3BhbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heFNwYW4gbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuXG4gICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUgbWF4aW11bSBzcGFuIG9mIHRoZSBsYXlvdXQgaW4gYnl0ZXMuXG4gICAgICpcbiAgICAgKiBQb3NpdGl2ZSB2YWx1ZXMgYXJlIGdlbmVyYWxseSBleHBlY3RlZC4gIFplcm8gaXMgYWJub3JtYWwuXG4gICAgICogQXR0ZW1wdHMgdG8gZW5jb2RlIG9yIGRlY29kZSBhIHZhbHVlIHRoYXQgZXhjZWVkcyB0aGlzIGxlbmd0aFxuICAgICAqIHdpbGwgdGhyb3cgYSBgUmFuZ2VFcnJvcmAuXG4gICAgICpcbiAgICAgKiBBIG5lZ2F0aXZlIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIG5vIGJvdW5kIG9uIHRoZSBsZW5ndGhcbiAgICAgKiBvZiB0aGUgY29udGVudC4gKi9cbiAgICB0aGlzLm1heFNwYW4gPSBtYXhTcGFuO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBnZXRTcGFuKGIsIG9mZnNldCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiIG11c3QgYmUgYSBCdWZmZXInKTtcbiAgICB9XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gYi5sZW5ndGggLSBvZmZzZXQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQsIGRlc3QpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGxldCBzcGFuID0gdGhpcy5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgaWYgKCgwIDw9IHRoaXMubWF4U3BhbilcbiAgICAgICAgJiYgKHRoaXMubWF4U3BhbiA8IHNwYW4pKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGV4dCBsZW5ndGggZXhjZWVkcyBtYXhTcGFuJyk7XG4gICAgfVxuICAgIHJldHVybiBiLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3BhbikudG9TdHJpbmcoJ3V0Zi04Jyk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgLyogTXVzdCBmb3JjZSB0aGlzIHRvIGEgc3RyaW5nLCBsZXN0IGl0IGJlIGEgbnVtYmVyIGFuZCB0aGVcbiAgICAgKiBcInV0ZjgtZW5jb2RpbmdcIiBiZWxvdyBhY3R1YWxseSBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBsZW5ndGhcbiAgICAgKiBzcmMgKi9cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzcmMpIHtcbiAgICAgIHNyYyA9IHNyYy50b1N0cmluZygpO1xuICAgIH1cbiAgICBjb25zdCBzcmNiID0gbmV3IEJ1ZmZlcihzcmMsICd1dGY4Jyk7XG4gICAgY29uc3Qgc3BhbiA9IHNyY2IubGVuZ3RoO1xuICAgIGlmICgoMCA8PSB0aGlzLm1heFNwYW4pXG4gICAgICAgICYmICh0aGlzLm1heFNwYW4gPCBzcGFuKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RleHQgbGVuZ3RoIGV4Y2VlZHMgbWF4U3BhbicpO1xuICAgIH1cbiAgICBpZiAoKG9mZnNldCArIHNwYW4pID4gYi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmNvZGluZyBvdmVycnVucyBCdWZmZXInKTtcbiAgICB9XG4gICAgc3JjYi5jb3B5KGIsIG9mZnNldCk7XG4gICAgcmV0dXJuIHNwYW47XG4gIH1cbn1cblxuLyoqXG4gKiBDb250YWluIGEgY29uc3RhbnQgdmFsdWUuXG4gKlxuICogVGhpcyBsYXlvdXQgbWF5IGJlIHVzZWQgaW4gY2FzZXMgd2hlcmUgYSBKYXZhU2NyaXB0IHZhbHVlIGNhbiBiZVxuICogaW5mZXJyZWQgd2l0aG91dCBhbiBleHByZXNzaW9uIGluIHRoZSBiaW5hcnkgZW5jb2RpbmcuICBBbiBleGFtcGxlXG4gKiB3b3VsZCBiZSBhIHtAbGluayBWYXJpYW50TGF5b3V0fHZhcmlhbnQgbGF5b3V0fSB3aGVyZSB0aGUgY29udGVudFxuICogaXMgaW1wbGllZCBieSB0aGUgdW5pb24ge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8TnVtYmVyfFN0cmluZ30gdmFsdWUgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBDb25zdGFudCN2YWx1ZXx2YWx1ZX0uICBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IChvciBhcnJheSkgYW5kXG4gKiB0aGUgYXBwbGljYXRpb24gaW50ZW5kcyB0aGUgb2JqZWN0IHRvIHJlbWFpbiB1bmNoYW5nZWQgcmVnYXJkbGVzc1xuICogb2Ygd2hhdCBpcyBkb25lIHRvIHZhbHVlcyBkZWNvZGVkIGJ5IHRoaXMgbGF5b3V0LCB0aGUgdmFsdWUgc2hvdWxkXG4gKiBiZSBmcm96ZW4gcHJpb3IgcGFzc2luZyBpdCB0byB0aGlzIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQ29uc3RhbnQgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgcHJvcGVydHkpIHtcbiAgICBzdXBlcigwLCBwcm9wZXJ0eSk7XG5cbiAgICAvKiogVGhlIHZhbHVlIHByb2R1Y2VkIGJ5IHRoaXMgY29uc3RhbnQgd2hlbiB0aGUgbGF5b3V0IGlzIHtAbGlua1xuICAgICAqIENvbnN0YW50I2RlY29kZXxkZWNvZGVkfS5cbiAgICAgKlxuICAgICAqIEFueSBKYXZhU2NyaXB0IHZhbHVlIGluY2x1ZGluZyBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGlzXG4gICAgICogcGVybWl0dGVkLlxuICAgICAqXG4gICAgICogKipXQVJOSU5HKiogSWYgYHZhbHVlYCBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIHdhcyBub3RcbiAgICAgKiBmcm96ZW4sIGl0IGlzIHBvc3NpYmxlIGZvciB1c2VycyBvZiBkZWNvZGVkIHZhbHVlcyB0byBjaGFuZ2VcbiAgICAgKiB0aGUgY29udGVudCBvZiB0aGUgdmFsdWUuICovXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0LCBkZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIC8qIENvbnN0YW50cyB0YWtlIG5vIHNwYWNlICovXG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuZXhwb3J0cy5FeHRlcm5hbExheW91dCA9IEV4dGVybmFsTGF5b3V0O1xuZXhwb3J0cy5HcmVlZHlDb3VudCA9IEdyZWVkeUNvdW50O1xuZXhwb3J0cy5PZmZzZXRMYXlvdXQgPSBPZmZzZXRMYXlvdXQ7XG5leHBvcnRzLlVJbnQgPSBVSW50O1xuZXhwb3J0cy5VSW50QkUgPSBVSW50QkU7XG5leHBvcnRzLkludCA9IEludDtcbmV4cG9ydHMuSW50QkUgPSBJbnRCRTtcbmV4cG9ydHMuRmxvYXQgPSBGbG9hdDtcbmV4cG9ydHMuRmxvYXRCRSA9IEZsb2F0QkU7XG5leHBvcnRzLkRvdWJsZSA9IERvdWJsZTtcbmV4cG9ydHMuRG91YmxlQkUgPSBEb3VibGVCRTtcbmV4cG9ydHMuU2VxdWVuY2UgPSBTZXF1ZW5jZTtcbmV4cG9ydHMuU3RydWN0dXJlID0gU3RydWN0dXJlO1xuZXhwb3J0cy5VbmlvbkRpc2NyaW1pbmF0b3IgPSBVbmlvbkRpc2NyaW1pbmF0b3I7XG5leHBvcnRzLlVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcjtcbmV4cG9ydHMuVW5pb24gPSBVbmlvbjtcbmV4cG9ydHMuVmFyaWFudExheW91dCA9IFZhcmlhbnRMYXlvdXQ7XG5leHBvcnRzLkJpdFN0cnVjdHVyZSA9IEJpdFN0cnVjdHVyZTtcbmV4cG9ydHMuQml0RmllbGQgPSBCaXRGaWVsZDtcbmV4cG9ydHMuQm9vbGVhbiA9IEJvb2xlYW47XG5leHBvcnRzLkJsb2IgPSBCbG9iO1xuZXhwb3J0cy5DU3RyaW5nID0gQ1N0cmluZztcbmV4cG9ydHMuVVRGOCA9IFVURjg7XG5leHBvcnRzLkNvbnN0YW50ID0gQ29uc3RhbnQ7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgR3JlZWR5Q291bnR9LiAqL1xuZXhwb3J0cy5ncmVlZHkgPSAoKGVsZW1lbnRTcGFuLCBwcm9wZXJ0eSkgPT4gbmV3IEdyZWVkeUNvdW50KGVsZW1lbnRTcGFuLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE9mZnNldExheW91dH0uICovXG5leHBvcnRzLm9mZnNldCA9ICgobGF5b3V0LCBvZmZzZXQsIHByb3BlcnR5KSA9PiBuZXcgT2Zmc2V0TGF5b3V0KGxheW91dCwgb2Zmc2V0LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8dW5zaWduZWQgaW50IGxheW91dHN9IHNwYW5uaW5nIG9uZVxuICogYnl0ZS4gKi9cbmV4cG9ydHMudTggPSAocHJvcGVydHkgPT4gbmV3IFVJbnQoMSwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0d28gYnl0ZXMuICovXG5leHBvcnRzLnUxNiA9IChwcm9wZXJ0eSA9PiBuZXcgVUludCgyLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuZXhwb3J0cy51MjQgPSAocHJvcGVydHkgPT4gbmV3IFVJbnQoMywgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmb3VyIGJ5dGVzLiAqL1xuZXhwb3J0cy51MzIgPSAocHJvcGVydHkgPT4gbmV3IFVJbnQoNCwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmaXZlIGJ5dGVzLiAqL1xuZXhwb3J0cy51NDAgPSAocHJvcGVydHkgPT4gbmV3IFVJbnQoNSwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5leHBvcnRzLnU0OCA9IChwcm9wZXJ0eSA9PiBuZXcgVUludCg2LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJVSW50NjR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnRcbiAqIGxheW91dHN9IGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm51NjQgPSAocHJvcGVydHkgPT4gbmV3IE5lYXJVSW50NjQocHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0d28gYnl0ZXMuICovXG5leHBvcnRzLnUxNmJlID0gKHByb3BlcnR5ID0+IG5ldyBVSW50QkUoMiwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMudTI0YmUgPSAocHJvcGVydHkgPT4gbmV3IFVJbnRCRSgzLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnUzMmJlID0gKHByb3BlcnR5ID0+IG5ldyBVSW50QkUoNCwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmaXZlIGJ5dGVzLiAqL1xuZXhwb3J0cy51NDBiZSA9IChwcm9wZXJ0eSA9PiBuZXcgVUludEJFKDUsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy51NDhiZSA9IChwcm9wZXJ0eSA9PiBuZXcgVUludEJFKDYsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhclVJbnQ2NEJFfGJpZy1lbmRpYW4gdW5zaWduZWQgaW50XG4gKiBsYXlvdXRzfSBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuZXhwb3J0cy5udTY0YmUgPSAocHJvcGVydHkgPT4gbmV3IE5lYXJVSW50NjRCRShwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxzaWduZWQgaW50IGxheW91dHN9IHNwYW5uaW5nIG9uZVxuICogYnl0ZS4gKi9cbmV4cG9ydHMuczggPSAocHJvcGVydHkgPT4gbmV3IEludCgxLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMuczE2ID0gKHByb3BlcnR5ID0+IG5ldyBJbnQoMiwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMuczI0ID0gKHByb3BlcnR5ID0+IG5ldyBJbnQoMywgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmb3VyIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMzIgPSAocHJvcGVydHkgPT4gbmV3IEludCg0LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnM0MCA9IChwcm9wZXJ0eSA9PiBuZXcgSW50KDUsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy5zNDggPSAocHJvcGVydHkgPT4gbmV3IEludCg2LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJJbnQ2NHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm5zNjQgPSAocHJvcGVydHkgPT4gbmV3IE5lYXJJbnQ2NChwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMuczE2YmUgPSAocHJvcGVydHkgPT4gbmV3IEludEJFKDIsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdGhyZWUgYnl0ZXMuICovXG5leHBvcnRzLnMyNGJlID0gKHByb3BlcnR5ID0+IG5ldyBJbnRCRSgzLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnMzMmJlID0gKHByb3BlcnR5ID0+IG5ldyBJbnRCRSg0LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnM0MGJlID0gKHByb3BlcnR5ID0+IG5ldyBJbnRCRSg1LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHNpeCBieXRlcy4gKi9cbmV4cG9ydHMuczQ4YmUgPSAocHJvcGVydHkgPT4gbmV3IEludEJFKDYsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhckludDY0QkV8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuZXhwb3J0cy5uczY0YmUgPSAocHJvcGVydHkgPT4gbmV3IE5lYXJJbnQ2NEJFKHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgRmxvYXR8bGl0dGxlLWVuZGlhbiAzMi1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjMyID0gKHByb3BlcnR5ID0+IG5ldyBGbG9hdChwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEZsb2F0QkV8YmlnLWVuZGlhbiAzMi1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjMyYmUgPSAocHJvcGVydHkgPT4gbmV3IEZsb2F0QkUocHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBEb3VibGV8bGl0dGxlLWVuZGlhbiA2NC1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjY0ID0gKHByb3BlcnR5ID0+IG5ldyBEb3VibGUocHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBEb3VibGVCRXxiaWctZW5kaWFuIDY0LWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mNjRiZSA9IChwcm9wZXJ0eSA9PiBuZXcgRG91YmxlQkUocHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBTdHJ1Y3R1cmV9IHZhbHVlcy4gKi9cbmV4cG9ydHMuc3RydWN0ID0gKChmaWVsZHMsIHByb3BlcnR5LCBkZWNvZGVQcmVmaXhlcykgPT4gbmV3IFN0cnVjdHVyZShmaWVsZHMsIHByb3BlcnR5LCBkZWNvZGVQcmVmaXhlcykpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEJpdFN0cnVjdHVyZX0gdmFsdWVzLiAqL1xuZXhwb3J0cy5iaXRzID0gKCh3b3JkLCBtc2IsIHByb3BlcnR5KSA9PiBuZXcgQml0U3RydWN0dXJlKHdvcmQsIG1zYiwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBTZXF1ZW5jZX0gdmFsdWVzLiAqL1xuZXhwb3J0cy5zZXEgPSAoKGVsZW1lbnRMYXlvdXQsIGNvdW50LCBwcm9wZXJ0eSkgPT4gbmV3IFNlcXVlbmNlKGVsZW1lbnRMYXlvdXQsIGNvdW50LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVuaW9ufSB2YWx1ZXMuICovXG5leHBvcnRzLnVuaW9uID0gKChkaXNjciwgZGVmYXVsdExheW91dCwgcHJvcGVydHkpID0+IG5ldyBVbmlvbihkaXNjciwgZGVmYXVsdExheW91dCwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3J9IHZhbHVlcy4gKi9cbmV4cG9ydHMudW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gKChsYXlvdXQsIHByb3BlcnR5KSA9PiBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKGxheW91dCwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBCbG9ifSB2YWx1ZXMuICovXG5leHBvcnRzLmJsb2IgPSAoKGxlbmd0aCwgcHJvcGVydHkpID0+IG5ldyBCbG9iKGxlbmd0aCwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBDU3RyaW5nfSB2YWx1ZXMuICovXG5leHBvcnRzLmNzdHIgPSAocHJvcGVydHkgPT4gbmV3IENTdHJpbmcocHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVVEY4fSB2YWx1ZXMuICovXG5leHBvcnRzLnV0ZjggPSAoKG1heFNwYW4sIHByb3BlcnR5KSA9PiBuZXcgVVRGOChtYXhTcGFuLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIENvbnN0YW50fSB2YWx1ZXMuICovXG5leHBvcnRzLmNvbnN0ID0gKCh2YWx1ZSwgcHJvcGVydHkpID0+IG5ldyBDb25zdGFudCh2YWx1ZSwgcHJvcGVydHkpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/buffer-layout/lib/Layout.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Home.module.css":
/*!************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Home.module.css ***!
  \************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".Home_App__2g2bl {\\n  min-height: 100vh;\\n  display: flex;\\n  flex-direction: column;\\n\\n  text-align: left;\\n  background-color: #282c34;\\n}\\n\\n.Home_AppHeader__EWHKt {\\n  height: 90px;\\n  display: flex;\\n  background-color: black;\\n  flex-direction: row;\\n  align-items: center;\\n  justify-content: space-between;\\n  font-size: 50px;\\n  color: white;\\n  padding-left: 20px;\\n  padding-right: 20px;\\n  flex-wrap: wrap;\\n}\\n\\n.Home_AppBody__v6U3u {\\n  height: 100%;\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  justify-content: flex-start;\\n  font-size: calc(10px + 2vmin);\\n  color: white;\\n  padding-top: 50px;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/Home.module.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,iBAAiB;EACjB,aAAa;EACb,sBAAsB;;EAEtB,gBAAgB;EAChB,yBAAyB;AAC3B;;AAEA;EACE,YAAY;EACZ,aAAa;EACb,uBAAuB;EACvB,mBAAmB;EACnB,mBAAmB;EACnB,8BAA8B;EAC9B,eAAe;EACf,YAAY;EACZ,kBAAkB;EAClB,mBAAmB;EACnB,eAAe;AACjB;;AAEA;EACE,YAAY;EACZ,aAAa;EACb,sBAAsB;EACtB,mBAAmB;EACnB,2BAA2B;EAC3B,6BAA6B;EAC7B,YAAY;EACZ,iBAAiB;AACnB\",\"sourcesContent\":[\".App {\\n  min-height: 100vh;\\n  display: flex;\\n  flex-direction: column;\\n\\n  text-align: left;\\n  background-color: #282c34;\\n}\\n\\n.AppHeader {\\n  height: 90px;\\n  display: flex;\\n  background-color: black;\\n  flex-direction: row;\\n  align-items: center;\\n  justify-content: space-between;\\n  font-size: 50px;\\n  color: white;\\n  padding-left: 20px;\\n  padding-right: 20px;\\n  flex-wrap: wrap;\\n}\\n\\n.AppBody {\\n  height: 100%;\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  justify-content: flex-start;\\n  font-size: calc(10px + 2vmin);\\n  color: white;\\n  padding-top: 50px;\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"App\": \"Home_App__2g2bl\",\n\t\"AppHeader\": \"Home_AppHeader__EWHKt\",\n\t\"AppBody\": \"Home_AppBody__v6U3u\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vc3R5bGVzL0hvbWUubW9kdWxlLmNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLG1LQUErRTtBQUN6SDtBQUNBO0FBQ0EsNERBQTRELHNCQUFzQixrQkFBa0IsMkJBQTJCLHVCQUF1Qiw4QkFBOEIsR0FBRyw0QkFBNEIsaUJBQWlCLGtCQUFrQiw0QkFBNEIsd0JBQXdCLHdCQUF3QixtQ0FBbUMsb0JBQW9CLGlCQUFpQix1QkFBdUIsd0JBQXdCLG9CQUFvQixHQUFHLDBCQUEwQixpQkFBaUIsa0JBQWtCLDJCQUEyQix3QkFBd0IsZ0NBQWdDLGtDQUFrQyxpQkFBaUIsc0JBQXNCLEdBQUcsT0FBTyx1RkFBdUYsWUFBWSxXQUFXLGFBQWEsYUFBYSxhQUFhLE9BQU8sS0FBSyxVQUFVLFVBQVUsWUFBWSxhQUFhLGFBQWEsYUFBYSxXQUFXLFVBQVUsWUFBWSxhQUFhLFdBQVcsT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLGFBQWEsYUFBYSxhQUFhLFdBQVcsWUFBWSxnQ0FBZ0Msc0JBQXNCLGtCQUFrQiwyQkFBMkIsdUJBQXVCLDhCQUE4QixHQUFHLGdCQUFnQixpQkFBaUIsa0JBQWtCLDRCQUE0Qix3QkFBd0Isd0JBQXdCLG1DQUFtQyxvQkFBb0IsaUJBQWlCLHVCQUF1Qix3QkFBd0Isb0JBQW9CLEdBQUcsY0FBYyxpQkFBaUIsa0JBQWtCLDJCQUEyQix3QkFBd0IsZ0NBQWdDLGtDQUFrQyxpQkFBaUIsc0JBQXNCLEdBQUcsbUJBQW1CO0FBQ3pzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zdHlsZXMvSG9tZS5tb2R1bGUuY3NzPzFjYjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5Ib21lX0FwcF9fMmcyYmwge1xcbiAgbWluLWhlaWdodDogMTAwdmg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG5cXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjgyYzM0O1xcbn1cXG5cXG4uSG9tZV9BcHBIZWFkZXJfX0VXSEt0IHtcXG4gIGhlaWdodDogOTBweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcXG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgZm9udC1zaXplOiA1MHB4O1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgcGFkZGluZy1sZWZ0OiAyMHB4O1xcbiAgcGFkZGluZy1yaWdodDogMjBweDtcXG4gIGZsZXgtd3JhcDogd3JhcDtcXG59XFxuXFxuLkhvbWVfQXBwQm9keV9fdjZVM3Uge1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgZm9udC1zaXplOiBjYWxjKDEwcHggKyAydm1pbik7XFxuICBjb2xvcjogd2hpdGU7XFxuICBwYWRkaW5nLXRvcDogNTBweDtcXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3N0eWxlcy9Ib21lLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxpQkFBaUI7RUFDakIsYUFBYTtFQUNiLHNCQUFzQjs7RUFFdEIsZ0JBQWdCO0VBQ2hCLHlCQUF5QjtBQUMzQjs7QUFFQTtFQUNFLFlBQVk7RUFDWixhQUFhO0VBQ2IsdUJBQXVCO0VBQ3ZCLG1CQUFtQjtFQUNuQixtQkFBbUI7RUFDbkIsOEJBQThCO0VBQzlCLGVBQWU7RUFDZixZQUFZO0VBQ1osa0JBQWtCO0VBQ2xCLG1CQUFtQjtFQUNuQixlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsWUFBWTtFQUNaLGFBQWE7RUFDYixzQkFBc0I7RUFDdEIsbUJBQW1CO0VBQ25CLDJCQUEyQjtFQUMzQiw2QkFBNkI7RUFDN0IsWUFBWTtFQUNaLGlCQUFpQjtBQUNuQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuQXBwIHtcXG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuXFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzI4MmMzNDtcXG59XFxuXFxuLkFwcEhlYWRlciB7XFxuICBoZWlnaHQ6IDkwcHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIGZvbnQtc2l6ZTogNTBweDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIHBhZGRpbmctbGVmdDogMjBweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDIwcHg7XFxuICBmbGV4LXdyYXA6IHdyYXA7XFxufVxcblxcbi5BcHBCb2R5IHtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gIGZvbnQtc2l6ZTogY2FsYygxMHB4ICsgMnZtaW4pO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgcGFkZGluZy10b3A6IDUwcHg7XFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcIkFwcFwiOiBcIkhvbWVfQXBwX18yZzJibFwiLFxuXHRcIkFwcEhlYWRlclwiOiBcIkhvbWVfQXBwSGVhZGVyX19FV0hLdFwiLFxuXHRcIkFwcEJvZHlcIjogXCJIb21lX0FwcEJvZHlfX3Y2VTN1XCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Home.module.css\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=%2Fhome%2Fmatheus%2FCode%2Ffac%2Fcurrent%2Fblockchain%2Fsolana%2Fmovie-fe%2Fpages%2Findex.tsx!":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=%2Fhome%2Fmatheus%2FCode%2Ffac%2Fcurrent%2Fblockchain%2Fsolana%2Fmovie-fe%2Fpages%2Findex.tsx! ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./pages/index.tsx */ \"./pages/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/cGFnZT0lMkYmYWJzb2x1dGVQYWdlUGF0aD0lMkZob21lJTJGbWF0aGV1cyUyRkNvZGUlMkZmYWMlMkZjdXJyZW50JTJGYmxvY2tjaGFpbiUyRnNvbGFuYSUyRm1vdmllLWZlJTJGcGFnZXMlMkZpbmRleC50c3ghLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsNENBQW1CO0FBQzFDO0FBQ0E7QUFDQSxPQUFPLElBQVU7QUFDakIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz8zMTJlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwiLi9wYWdlcy9pbmRleC50c3hcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL1wiXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=%2Fhome%2Fmatheus%2FCode%2Ffac%2Fcurrent%2Fblockchain%2Fsolana%2Fmovie-fe%2Fpages%2Findex.tsx!\n");

/***/ }),

/***/ "./styles/Home.module.css":
/*!********************************!*\
  !*** ./styles/Home.module.css ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Home.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Home.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                // These elements should always exist. If they do not,\n                // this code should fail.\n                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\n                var parentNode = anchorElement.parentNode// Normally <head>\n                ;\n                // Each style tag should be placed right before our\n                // anchor. By inserting before and not after, we do not\n                // need to track the last inserted element.\n                parentNode.insertBefore(element, anchorElement);\n            };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Home.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Home.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Home.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Home.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvSG9tZS5tb2R1bGUuY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxvTkFBd0c7QUFDMUgsMEJBQTBCLG1CQUFPLENBQUMsK2VBQW1QOztBQUVyUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZCx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBaUI7QUFDckIsTUFBTSwrZUFBbVA7QUFDelA7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQywrZUFBbVA7O0FBRTdROztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9Ib21lLm1vZHVsZS5jc3M/MzhmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMl0hLi9Ib21lLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vSG9tZS5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsyXSEuL0hvbWUubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./styles/Home.module.css\n");

/***/ }),

/***/ "./components/AppBar.tsx":
/*!*******************************!*\
  !*** ./components/AppBar.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AppBar\": function() { return /* binding */ AppBar; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _styles_Home_module_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../styles/Home.module.css */ \"./styles/Home.module.css\");\n/* harmony import */ var _styles_Home_module_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _solana_wallet_adapter_react_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/wallet-adapter-react-ui */ \"./node_modules/@solana/wallet-adapter-react-ui/lib/esm/index.mjs\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_2__);\nvar _this = undefined;\n\n\n\n\nvar AppBar = function() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_3___default().AppHeader),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_2___default()), {\n                src: \"/solanaLogo.png\",\n                height: 30,\n                width: 200\n            }, void 0, false, {\n                fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/AppBar.tsx\",\n                lineNumber: 9,\n                columnNumber: 13\n            }, _this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                children: \"Movie Reviews\"\n            }, void 0, false, {\n                fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/AppBar.tsx\",\n                lineNumber: 10,\n                columnNumber: 13\n            }, _this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_solana_wallet_adapter_react_ui__WEBPACK_IMPORTED_MODULE_1__.WalletMultiButton, {}, void 0, false, {\n                fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/AppBar.tsx\",\n                lineNumber: 11,\n                columnNumber: 13\n            }, _this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/AppBar.tsx\",\n        lineNumber: 8,\n        columnNumber: 9\n    }, _this);\n};\n_c = AppBar;\nvar _c;\n$RefreshReg$(_c, \"AppBar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0FwcEJhci50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDOEM7QUFDcUI7QUFDckM7QUFFdkIsSUFBTUcsTUFBTSxHQUFPLFdBQU07SUFDNUIscUJBQ0ksOERBQUNDLEtBQUc7UUFBQ0MsU0FBUyxFQUFFTCwwRUFBZ0I7OzBCQUM1Qiw4REFBQ0UsbURBQUs7Z0JBQUNLLEdBQUcsRUFBQyxpQkFBaUI7Z0JBQUNDLE1BQU0sRUFBRSxFQUFFO2dCQUFFQyxLQUFLLEVBQUUsR0FBRzs7Ozs7cUJBQUk7MEJBQ3ZELDhEQUFDQyxNQUFJOzBCQUFDLGVBQWE7Ozs7O3FCQUFPOzBCQUMxQiw4REFBQ1QsOEVBQWlCOzs7O3FCQUFHOzs7Ozs7YUFDbkIsQ0FDVDtDQUNKO0FBUllFLEtBQUFBLE1BQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9BcHBCYXIudHN4PzZiN2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRkMgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi4vc3R5bGVzL0hvbWUubW9kdWxlLmNzcydcbmltcG9ydCB7IFdhbGxldE11bHRpQnV0dG9uIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aSdcbmltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJ1xuXG5leHBvcnQgY29uc3QgQXBwQmFyOiBGQyA9ICgpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLkFwcEhlYWRlcn0+XG4gICAgICAgICAgICA8SW1hZ2Ugc3JjPVwiL3NvbGFuYUxvZ28ucG5nXCIgaGVpZ2h0PXszMH0gd2lkdGg9ezIwMH0gLz5cbiAgICAgICAgICAgIDxzcGFuPk1vdmllIFJldmlld3M8L3NwYW4+XG4gICAgICAgICAgICA8V2FsbGV0TXVsdGlCdXR0b24gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgKVxufSJdLCJuYW1lcyI6WyJzdHlsZXMiLCJXYWxsZXRNdWx0aUJ1dHRvbiIsIkltYWdlIiwiQXBwQmFyIiwiZGl2IiwiY2xhc3NOYW1lIiwiQXBwSGVhZGVyIiwic3JjIiwiaGVpZ2h0Iiwid2lkdGgiLCJzcGFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/AppBar.tsx\n");

/***/ }),

/***/ "./components/Card.tsx":
/*!*****************************!*\
  !*** ./components/Card.tsx ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Card\": function() { return /* binding */ Card; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chakra-ui/react */ \"./node_modules/@chakra-ui/react/dist/chakra-ui-react.esm.js\");\nvar _this = undefined;\n\n\nvar Card = function(props) {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__.Box, {\n        p: 4,\n        display: {\n            md: \"flex\"\n        },\n        maxWidth: \"32rem\",\n        borderWidth: 1,\n        margin: 2,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__.Stack, {\n            w: \"full\",\n            align: {\n                base: \"center\",\n                md: \"stretch\"\n            },\n            textAlign: {\n                base: \"center\",\n                md: \"left\"\n            },\n            mt: {\n                base: 4,\n                md: 0\n            },\n            ml: {\n                md: 6\n            },\n            mr: {\n                md: 6\n            },\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__.HStack, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__.Text, {\n                            fontWeight: \"bold\",\n                            textTransform: \"uppercase\",\n                            fontSize: \"lg\",\n                            letterSpacing: \"wide\",\n                            color: \"gray.200\",\n                            children: props.movie.title\n                        }, void 0, false, {\n                            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Card.tsx\",\n                            lineNumber: 27,\n                            columnNumber: 21\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__.Spacer, {}, void 0, false, {\n                            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Card.tsx\",\n                            lineNumber: 36,\n                            columnNumber: 21\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__.Text, {\n                            color: \"gray.200\",\n                            children: [\n                                props.movie.rating,\n                                \"/5\"\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Card.tsx\",\n                            lineNumber: 37,\n                            columnNumber: 21\n                        }, _this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Card.tsx\",\n                    lineNumber: 26,\n                    columnNumber: 17\n                }, _this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_1__.Text, {\n                    my: 2,\n                    color: \"gray.400\",\n                    children: props.movie.description\n                }, void 0, false, {\n                    fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Card.tsx\",\n                    lineNumber: 43,\n                    columnNumber: 17\n                }, _this)\n            ]\n        }, void 0, true, {\n            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Card.tsx\",\n            lineNumber: 18,\n            columnNumber: 13\n        }, _this)\n    }, void 0, false, {\n        fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Card.tsx\",\n        lineNumber: 11,\n        columnNumber: 9\n    }, _this);\n};\n_c = Card;\nvar _c;\n$RefreshReg$(_c, \"Card\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0NhcmQudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFBb0U7QUFRN0QsSUFBTUssSUFBSSxHQUFrQixTQUFDQyxLQUFLLEVBQUs7SUFDMUMscUJBQ0ksOERBQUNOLGlEQUFHO1FBQ0FPLENBQUMsRUFBRSxDQUFDO1FBQ0pDLE9BQU8sRUFBRTtZQUFFQyxFQUFFLEVBQUUsTUFBTTtTQUFFO1FBQ3ZCQyxRQUFRLEVBQUMsT0FBTztRQUNoQkMsV0FBVyxFQUFFLENBQUM7UUFDZEMsTUFBTSxFQUFFLENBQUM7a0JBRVQsNEVBQUNULG1EQUFLO1lBQ0ZVLENBQUMsRUFBQyxNQUFNO1lBQ1JDLEtBQUssRUFBRTtnQkFBRUMsSUFBSSxFQUFFLFFBQVE7Z0JBQUVOLEVBQUUsRUFBRSxTQUFTO2FBQUU7WUFDeENPLFNBQVMsRUFBRTtnQkFBRUQsSUFBSSxFQUFFLFFBQVE7Z0JBQUVOLEVBQUUsRUFBRSxNQUFNO2FBQUU7WUFDekNRLEVBQUUsRUFBRTtnQkFBRUYsSUFBSSxFQUFFLENBQUM7Z0JBQUVOLEVBQUUsRUFBRSxDQUFDO2FBQUU7WUFDdEJTLEVBQUUsRUFBRTtnQkFBRVQsRUFBRSxFQUFFLENBQUM7YUFBRTtZQUNiVSxFQUFFLEVBQUU7Z0JBQUVWLEVBQUUsRUFBRSxDQUFDO2FBQUU7OzhCQUViLDhEQUFDUixvREFBTTs7c0NBQ0gsOERBQUNHLGtEQUFJOzRCQUNEZ0IsVUFBVSxFQUFDLE1BQU07NEJBQ2pCQyxhQUFhLEVBQUMsV0FBVzs0QkFDekJDLFFBQVEsRUFBQyxJQUFJOzRCQUNiQyxhQUFhLEVBQUMsTUFBTTs0QkFDcEJDLEtBQUssRUFBQyxVQUFVO3NDQUVmbEIsS0FBSyxDQUFDbUIsS0FBSyxDQUFDQyxLQUFLOzs7OztpQ0FDZjtzQ0FDUCw4REFBQ3hCLG9EQUFNOzs7O2lDQUFHO3NDQUNWLDhEQUFDRSxrREFBSTs0QkFDRG9CLEtBQUssRUFBQyxVQUFVOztnQ0FFZmxCLEtBQUssQ0FBQ21CLEtBQUssQ0FBQ0UsTUFBTTtnQ0FBQyxJQUN4Qjs7Ozs7O2lDQUFPOzs7Ozs7eUJBQ0Y7OEJBQ1QsOERBQUN2QixrREFBSTtvQkFBQ3dCLEVBQUUsRUFBRSxDQUFDO29CQUFFSixLQUFLLEVBQUMsVUFBVTs4QkFDeEJsQixLQUFLLENBQUNtQixLQUFLLENBQUNJLFdBQVc7Ozs7O3lCQUNyQjs7Ozs7O2lCQUNIOzs7OzthQUNOLENBQ1Q7Q0FDSjtBQXhDWXhCLEtBQUFBLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9DYXJkLnRzeD83YTM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJveCwgSFN0YWNrLCBTcGFjZXIsIFN0YWNrLCBUZXh0IH0gZnJvbSAnQGNoYWtyYS11aS9yZWFjdCc7XG5pbXBvcnQgeyBGQyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1vdmllIH0gZnJvbSAnLi4vbW9kZWxzL01vdmllJztcblxuZXhwb3J0IGludGVyZmFjZSBDYXJkUHJvcHMge1xuICAgIG1vdmllOiBNb3ZpZTtcbn1cblxuZXhwb3J0IGNvbnN0IENhcmQ6IEZDPENhcmRQcm9wcz4gPSAocHJvcHMpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8Qm94XG4gICAgICAgICAgICBwPXs0fVxuICAgICAgICAgICAgZGlzcGxheT17eyBtZDogXCJmbGV4XCIgfX1cbiAgICAgICAgICAgIG1heFdpZHRoPVwiMzJyZW1cIlxuICAgICAgICAgICAgYm9yZGVyV2lkdGg9ezF9XG4gICAgICAgICAgICBtYXJnaW49ezJ9XG4gICAgICAgID5cbiAgICAgICAgICAgIDxTdGFja1xuICAgICAgICAgICAgICAgIHc9J2Z1bGwnXG4gICAgICAgICAgICAgICAgYWxpZ249e3sgYmFzZTogXCJjZW50ZXJcIiwgbWQ6IFwic3RyZXRjaFwiIH19XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduPXt7IGJhc2U6IFwiY2VudGVyXCIsIG1kOiBcImxlZnRcIiB9fVxuICAgICAgICAgICAgICAgIG10PXt7IGJhc2U6IDQsIG1kOiAwIH19XG4gICAgICAgICAgICAgICAgbWw9e3sgbWQ6IDYgfX1cbiAgICAgICAgICAgICAgICBtcj17eyBtZDogNiB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxIU3RhY2sgPlxuICAgICAgICAgICAgICAgICAgICA8VGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodD1cImJvbGRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFRyYW5zZm9ybT1cInVwcGVyY2FzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZT1cImxnXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldHRlclNwYWNpbmc9XCJ3aWRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yPVwiZ3JheS4yMDBcIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICB7cHJvcHMubW92aWUudGl0bGV9XG4gICAgICAgICAgICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgICAgICAgICAgICAgPFNwYWNlciAvPlxuICAgICAgICAgICAgICAgICAgICA8VGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I9XCJncmF5LjIwMFwiXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtwcm9wcy5tb3ZpZS5yYXRpbmd9LzVcbiAgICAgICAgICAgICAgICAgICAgPC9UZXh0PlxuICAgICAgICAgICAgICAgIDwvSFN0YWNrPlxuICAgICAgICAgICAgICAgIDxUZXh0IG15PXsyfSBjb2xvcj1cImdyYXkuNDAwXCI+XG4gICAgICAgICAgICAgICAgICAgIHtwcm9wcy5tb3ZpZS5kZXNjcmlwdGlvbn1cbiAgICAgICAgICAgICAgICA8L1RleHQ+XG4gICAgICAgICAgICA8L1N0YWNrPlxuICAgICAgICA8L0JveD5cbiAgICApXG59XG5cbiJdLCJuYW1lcyI6WyJCb3giLCJIU3RhY2siLCJTcGFjZXIiLCJTdGFjayIsIlRleHQiLCJDYXJkIiwicHJvcHMiLCJwIiwiZGlzcGxheSIsIm1kIiwibWF4V2lkdGgiLCJib3JkZXJXaWR0aCIsIm1hcmdpbiIsInciLCJhbGlnbiIsImJhc2UiLCJ0ZXh0QWxpZ24iLCJtdCIsIm1sIiwibXIiLCJmb250V2VpZ2h0IiwidGV4dFRyYW5zZm9ybSIsImZvbnRTaXplIiwibGV0dGVyU3BhY2luZyIsImNvbG9yIiwibW92aWUiLCJ0aXRsZSIsInJhdGluZyIsIm15IiwiZGVzY3JpcHRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Card.tsx\n");

/***/ }),

/***/ "./components/Form.tsx":
/*!*****************************!*\
  !*** ./components/Form.tsx ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Form\": function() { return /* binding */ Form; }\n/* harmony export */ });\n/* harmony import */ var _home_matheus_Code_fac_current_blockchain_solana_movie_fe_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/dist/compiled/regenerator-runtime/runtime.js */ \"./node_modules/next/dist/compiled/regenerator-runtime/runtime.js\");\n/* harmony import */ var _home_matheus_Code_fac_current_blockchain_solana_movie_fe_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_home_matheus_Code_fac_current_blockchain_solana_movie_fe_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _models_Movie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models/Movie */ \"./models/Movie.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @chakra-ui/react */ \"./node_modules/@chakra-ui/react/dist/chakra-ui-react.esm.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/web3.js */ \"./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"./node_modules/@solana/wallet-adapter-react/lib/esm/index.mjs\");\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s1, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s1 = _i.next()).done); _n = true){\n            _arr.push(_s1.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nvar _this = undefined;\n\n\n\n\n\n\nvar _s = $RefreshSig$();\nvar MOVIE_REVIEW_PROGRAM_ID = \"CenYq6bDRB7p73EjsPEpiYN7uveyPUTdXkDkgUduboaN\";\nvar Form = function() {\n    _s();\n    var ref4 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(\"\"), title = ref4[0], setTitle = ref4[1];\n    var ref1 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(0), rating = ref1[0], setRating = ref1[1];\n    var ref2 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(\"\"), message = ref2[0], setMessage = ref2[1];\n    var connection = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__.useConnection)().connection;\n    var ref3 = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__.useWallet)(), publicKey = ref3.publicKey, sendTransaction = ref3.sendTransaction;\n    var handleSubmit = function(event) {\n        event.preventDefault();\n        var movie = new _models_Movie__WEBPACK_IMPORTED_MODULE_2__.Movie(title, rating, message);\n        handleTransactionSubmit(movie);\n    };\n    var handleTransactionSubmit = function() {\n        var _ref = _asyncToGenerator(_home_matheus_Code_fac_current_blockchain_solana_movie_fe_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(movie) {\n            var buffer, transaction, ref, pda, instruction, txid;\n            return _home_matheus_Code_fac_current_blockchain_solana_movie_fe_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_ctx) {\n                while(1)switch(_ctx.prev = _ctx.next){\n                    case 0:\n                        if (publicKey) {\n                            _ctx.next = 3;\n                            break;\n                        }\n                        alert(\"Please connect your wallet!\");\n                        return _ctx.abrupt(\"return\");\n                    case 3:\n                        buffer = movie.serialize();\n                        transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_4__.Transaction();\n                        _ctx.t0 = _slicedToArray;\n                        _ctx.next = 8;\n                        return _solana_web3_js__WEBPACK_IMPORTED_MODULE_4__.PublicKey.findProgramAddress([\n                            publicKey.toBuffer(),\n                            new TextEncoder().encode(movie.title)\n                        ], new _solana_web3_js__WEBPACK_IMPORTED_MODULE_4__.PublicKey(MOVIE_REVIEW_PROGRAM_ID));\n                    case 8:\n                        _ctx.t1 = _ctx.sent;\n                        ref = (0, _ctx.t0)(_ctx.t1, 1);\n                        pda = ref[0];\n                        instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_4__.TransactionInstruction({\n                            keys: [\n                                {\n                                    pubkey: publicKey,\n                                    isSigner: true,\n                                    isWritable: false\n                                },\n                                {\n                                    pubkey: pda,\n                                    isSigner: false,\n                                    isWritable: true\n                                },\n                                {\n                                    pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_4__.SystemProgram.programId,\n                                    isSigner: false,\n                                    isWritable: false\n                                }, \n                            ],\n                            data: buffer,\n                            programId: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_4__.PublicKey(MOVIE_REVIEW_PROGRAM_ID)\n                        });\n                        transaction.add(instruction);\n                        _ctx.prev = 13;\n                        _ctx.next = 16;\n                        return sendTransaction(transaction, connection);\n                    case 16:\n                        txid = _ctx.sent;\n                        console.log(\"Transaction submitted: https://explorer.solana.com/tx/\".concat(txid, \"?cluster=devnet\"));\n                        _ctx.next = 23;\n                        break;\n                    case 20:\n                        _ctx.prev = 20;\n                        _ctx.t2 = _ctx[\"catch\"](13);\n                        alert(JSON.stringify(_ctx.t2));\n                    case 23:\n                    case \"end\":\n                        return _ctx.stop();\n                }\n            }, _callee, null, [\n                [\n                    13,\n                    20\n                ]\n            ]);\n        }));\n        return function handleTransactionSubmit(movie) {\n            return _ref.apply(this, arguments);\n        };\n    }();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.Box, {\n        p: 4,\n        display: {\n            md: \"flex\"\n        },\n        maxWidth: \"32rem\",\n        borderWidth: 1,\n        margin: 2,\n        justifyContent: \"center\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"form\", {\n            onSubmit: handleSubmit,\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.FormControl, {\n                    isRequired: true,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.FormLabel, {\n                            color: \"gray.200\",\n                            children: \"Movie Title\"\n                        }, void 0, false, {\n                            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n                            lineNumber: 95,\n                            columnNumber: 11\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.Input, {\n                            id: \"title\",\n                            color: \"gray.400\",\n                            onChange: function(event) {\n                                return setTitle(event.currentTarget.value);\n                            }\n                        }, void 0, false, {\n                            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n                            lineNumber: 96,\n                            columnNumber: 11\n                        }, _this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n                    lineNumber: 94,\n                    columnNumber: 9\n                }, _this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.FormControl, {\n                    isRequired: true,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.FormLabel, {\n                            color: \"gray.200\",\n                            children: \"Add your review\"\n                        }, void 0, false, {\n                            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n                            lineNumber: 103,\n                            columnNumber: 11\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.Textarea, {\n                            id: \"review\",\n                            color: \"gray.400\",\n                            onChange: function(event) {\n                                return setMessage(event.currentTarget.value);\n                            }\n                        }, void 0, false, {\n                            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n                            lineNumber: 104,\n                            columnNumber: 11\n                        }, _this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n                    lineNumber: 102,\n                    columnNumber: 9\n                }, _this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.FormControl, {\n                    isRequired: true,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.FormLabel, {\n                            color: \"gray.200\",\n                            children: \"Rating\"\n                        }, void 0, false, {\n                            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n                            lineNumber: 111,\n                            columnNumber: 11\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.NumberInput, {\n                            max: 5,\n                            min: 1,\n                            onChange: function(valueString) {\n                                return setRating(parseInt(valueString));\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.NumberInputField, {\n                                    id: \"amount\",\n                                    color: \"gray.400\"\n                                }, void 0, false, {\n                                    fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n                                    lineNumber: 117,\n                                    columnNumber: 13\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.NumberInputStepper, {\n                                    color: \"gray.400\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.NumberIncrementStepper, {}, void 0, false, {\n                                            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n                                            lineNumber: 119,\n                                            columnNumber: 15\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.NumberDecrementStepper, {}, void 0, false, {\n                                            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n                                            lineNumber: 120,\n                                            columnNumber: 15\n                                        }, _this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n                                    lineNumber: 118,\n                                    columnNumber: 13\n                                }, _this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n                            lineNumber: 112,\n                            columnNumber: 11\n                        }, _this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n                    lineNumber: 110,\n                    columnNumber: 9\n                }, _this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.Button, {\n                    width: \"full\",\n                    mt: 4,\n                    type: \"submit\",\n                    children: \"Submit Review\"\n                }, void 0, false, {\n                    fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n                    lineNumber: 124,\n                    columnNumber: 9\n                }, _this)\n            ]\n        }, void 0, true, {\n            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n            lineNumber: 93,\n            columnNumber: 7\n        }, _this)\n    }, void 0, false, {\n        fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/Form.tsx\",\n        lineNumber: 85,\n        columnNumber: 5\n    }, _this);\n};\n_s(Form, \"xQ6YJIvfDA/fBdqHkw3Z+MgiL/A=\", false, function() {\n    return [\n        _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__.useConnection,\n        _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__.useWallet\n    ];\n});\n_c = Form;\nvar _c;\n$RefreshReg$(_c, \"Form\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLFVBQVU7NEJBQ2hCRSxRQUFRLEVBQUUsU0FBQzFDLEtBQUs7dUNBQUtMLFVBQVUsQ0FBQ0ssS0FBSyxDQUFDMkMsYUFBYSxDQUFDQyxLQUFLLENBQUM7NkJBQUE7Ozs7O2lDQUMxRDs7Ozs7O3lCQUNVOzhCQUNkLDhEQUFDcEUseURBQVc7b0JBQUMrRCxVQUFVOztzQ0FDckIsOERBQUM5RCx1REFBUzs0QkFBQytELEtBQUssRUFBQyxVQUFVO3NDQUFDLFFBQU07Ozs7O2lDQUFZO3NDQUM5Qyw4REFBQzNELHlEQUFXOzRCQUNWZ0UsR0FBRyxFQUFFLENBQUM7NEJBQ05DLEdBQUcsRUFBRSxDQUFDOzRCQUNOSixRQUFRLEVBQUUsU0FBQ0ssV0FBVzt1Q0FBS3RELFNBQVMsQ0FBQ3VELFFBQVEsQ0FBQ0QsV0FBVyxDQUFDLENBQUM7NkJBQUE7OzhDQUUzRCw4REFBQ2pFLDhEQUFnQjtvQ0FBQzJELEVBQUUsRUFBQyxRQUFRO29DQUFDRCxLQUFLLEVBQUMsVUFBVTs7Ozs7eUNBQUc7OENBQ2pELDhEQUFDekQsZ0VBQWtCO29DQUFDeUQsS0FBSyxFQUFDLFVBQVU7O3NEQUNsQyw4REFBQzVELG9FQUFzQjs7OztpREFBRztzREFDMUIsOERBQUNELG9FQUFzQjs7OztpREFBRzs7Ozs7O3lDQUNQOzs7Ozs7aUNBQ1Q7Ozs7Ozt5QkFDRjs4QkFDZCw4REFBQ0osb0RBQU07b0JBQUMwRSxLQUFLLEVBQUMsTUFBTTtvQkFBQ0MsRUFBRSxFQUFFLENBQUM7b0JBQUVDLElBQUksRUFBQyxRQUFROzhCQUFDLGVBRTFDOzs7Ozt5QkFBUzs7Ozs7O2lCQUNKOzs7OzthQUNILENBQ047Q0FDSCxDQUFDO0dBNUdXOUQsSUFBSTs7UUFLUUgsdUVBQWE7UUFDR0MsbUVBQVM7OztBQU5yQ0UsS0FBQUEsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Zvcm0udHN4P2VlZDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRkMgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IE1vdmllIH0gZnJvbSBcIi4uL21vZGVscy9Nb3ZpZVwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIEJveCxcbiAgQnV0dG9uLFxuICBGb3JtQ29udHJvbCxcbiAgRm9ybUxhYmVsLFxuICBJbnB1dCxcbiAgTnVtYmVyRGVjcmVtZW50U3RlcHBlcixcbiAgTnVtYmVySW5jcmVtZW50U3RlcHBlcixcbiAgTnVtYmVySW5wdXQsXG4gIE51bWJlcklucHV0RmllbGQsXG4gIE51bWJlcklucHV0U3RlcHBlcixcbiAgVGV4dGFyZWEsXG59IGZyb20gXCJAY2hha3JhLXVpL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyB3ZWIzIGZyb20gXCJAc29sYW5hL3dlYjMuanNcIjtcbmltcG9ydCB7IHVzZUNvbm5lY3Rpb24sIHVzZVdhbGxldCB9IGZyb20gXCJAc29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0XCI7XG5cbmNvbnN0IE1PVklFX1JFVklFV19QUk9HUkFNX0lEID0gXCJDZW5ZcTZiRFJCN3A3M0Vqc1BFcGlZTjd1dmV5UFVUZFhrRGtnVWR1Ym9hTlwiO1xuXG5leHBvcnQgY29uc3QgRm9ybTogRkMgPSAoKSA9PiB7XG4gIGNvbnN0IFt0aXRsZSwgc2V0VGl0bGVdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtyYXRpbmcsIHNldFJhdGluZ10gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW21lc3NhZ2UsIHNldE1lc3NhZ2VdID0gdXNlU3RhdGUoXCJcIik7XG5cbiAgY29uc3QgeyBjb25uZWN0aW9uIH0gPSB1c2VDb25uZWN0aW9uKCk7XG4gIGNvbnN0IHsgcHVibGljS2V5LCBzZW5kVHJhbnNhY3Rpb24gfSA9IHVzZVdhbGxldCgpO1xuXG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IChldmVudDogYW55KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBtb3ZpZSA9IG5ldyBNb3ZpZSh0aXRsZSwgcmF0aW5nLCBtZXNzYWdlKTtcbiAgICBoYW5kbGVUcmFuc2FjdGlvblN1Ym1pdChtb3ZpZSk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlVHJhbnNhY3Rpb25TdWJtaXQgPSBhc3luYyAobW92aWU6IE1vdmllKSA9PiB7XG4gICAgaWYgKCFwdWJsaWNLZXkpIHtcbiAgICAgIGFsZXJ0KFwiUGxlYXNlIGNvbm5lY3QgeW91ciB3YWxsZXQhXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IG1vdmllLnNlcmlhbGl6ZSgpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IHdlYjMuVHJhbnNhY3Rpb24oKTtcblxuICAgIGNvbnN0IFtwZGFdID0gYXdhaXQgd2ViMy5QdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzKFxuICAgICAgW3B1YmxpY0tleS50b0J1ZmZlcigpLCBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobW92aWUudGl0bGUpXSxcbiAgICAgIG5ldyB3ZWIzLlB1YmxpY0tleShNT1ZJRV9SRVZJRVdfUFJPR1JBTV9JRClcbiAgICApO1xuXG4gICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBuZXcgd2ViMy5UcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHB1YmtleTogcHVibGljS2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcHVia2V5OiBwZGEsXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJrZXk6IHdlYjMuU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRhdGE6IGJ1ZmZlcixcbiAgICAgIHByb2dyYW1JZDogbmV3IHdlYjMuUHVibGljS2V5KE1PVklFX1JFVklFV19QUk9HUkFNX0lEKSxcbiAgICB9KTtcblxuICAgIHRyYW5zYWN0aW9uLmFkZChpbnN0cnVjdGlvbik7XG5cbiAgICB0cnkge1xuICAgICAgbGV0IHR4aWQgPSBhd2FpdCBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24pO1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGBUcmFuc2FjdGlvbiBzdWJtaXR0ZWQ6IGh0dHBzOi8vZXhwbG9yZXIuc29sYW5hLmNvbS90eC8ke3R4aWR9P2NsdXN0ZXI9ZGV2bmV0YFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhbGVydChKU09OLnN0cmluZ2lmeShlKSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEJveFxuICAgICAgcD17NH1cbiAgICAgIGRpc3BsYXk9e3sgbWQ6IFwiZmxleFwiIH19XG4gICAgICBtYXhXaWR0aD1cIjMycmVtXCJcbiAgICAgIGJvcmRlcldpZHRoPXsxfVxuICAgICAgbWFyZ2luPXsyfVxuICAgICAganVzdGlmeUNvbnRlbnQ9XCJjZW50ZXJcIlxuICAgID5cbiAgICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXR9PlxuICAgICAgICA8Rm9ybUNvbnRyb2wgaXNSZXF1aXJlZD5cbiAgICAgICAgICA8Rm9ybUxhYmVsIGNvbG9yPVwiZ3JheS4yMDBcIj5Nb3ZpZSBUaXRsZTwvRm9ybUxhYmVsPlxuICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgaWQ9XCJ0aXRsZVwiXG4gICAgICAgICAgICBjb2xvcj1cImdyYXkuNDAwXCJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+IHNldFRpdGxlKGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUpfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvRm9ybUNvbnRyb2w+XG4gICAgICAgIDxGb3JtQ29udHJvbCBpc1JlcXVpcmVkPlxuICAgICAgICAgIDxGb3JtTGFiZWwgY29sb3I9XCJncmF5LjIwMFwiPkFkZCB5b3VyIHJldmlldzwvRm9ybUxhYmVsPlxuICAgICAgICAgIDxUZXh0YXJlYVxuICAgICAgICAgICAgaWQ9XCJyZXZpZXdcIlxuICAgICAgICAgICAgY29sb3I9XCJncmF5LjQwMFwiXG4gICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PiBzZXRNZXNzYWdlKGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUpfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvRm9ybUNvbnRyb2w+XG4gICAgICAgIDxGb3JtQ29udHJvbCBpc1JlcXVpcmVkPlxuICAgICAgICAgIDxGb3JtTGFiZWwgY29sb3I9XCJncmF5LjIwMFwiPlJhdGluZzwvRm9ybUxhYmVsPlxuICAgICAgICAgIDxOdW1iZXJJbnB1dFxuICAgICAgICAgICAgbWF4PXs1fVxuICAgICAgICAgICAgbWluPXsxfVxuICAgICAgICAgICAgb25DaGFuZ2U9eyh2YWx1ZVN0cmluZykgPT4gc2V0UmF0aW5nKHBhcnNlSW50KHZhbHVlU3RyaW5nKSl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPE51bWJlcklucHV0RmllbGQgaWQ9XCJhbW91bnRcIiBjb2xvcj1cImdyYXkuNDAwXCIgLz5cbiAgICAgICAgICAgIDxOdW1iZXJJbnB1dFN0ZXBwZXIgY29sb3I9XCJncmF5LjQwMFwiPlxuICAgICAgICAgICAgICA8TnVtYmVySW5jcmVtZW50U3RlcHBlciAvPlxuICAgICAgICAgICAgICA8TnVtYmVyRGVjcmVtZW50U3RlcHBlciAvPlxuICAgICAgICAgICAgPC9OdW1iZXJJbnB1dFN0ZXBwZXI+XG4gICAgICAgICAgPC9OdW1iZXJJbnB1dD5cbiAgICAgICAgPC9Gb3JtQ29udHJvbD5cbiAgICAgICAgPEJ1dHRvbiB3aWR0aD1cImZ1bGxcIiBtdD17NH0gdHlwZT1cInN1Ym1pdFwiPlxuICAgICAgICAgIFN1Ym1pdCBSZXZpZXdcbiAgICAgICAgPC9CdXR0b24+XG4gICAgICA8L2Zvcm0+XG4gICAgPC9Cb3g+XG4gICk7XG59O1xuIl0sIm5hbWVzIjpbIk1vdmllIiwidXNlU3RhdGUiLCJCb3giLCJCdXR0b24iLCJGb3JtQ29udHJvbCIsIkZvcm1MYWJlbCIsIklucHV0IiwiTnVtYmVyRGVjcmVtZW50U3RlcHBlciIsIk51bWJlckluY3JlbWVudFN0ZXBwZXIiLCJOdW1iZXJJbnB1dCIsIk51bWJlcklucHV0RmllbGQiLCJOdW1iZXJJbnB1dFN0ZXBwZXIiLCJUZXh0YXJlYSIsIndlYjMiLCJ1c2VDb25uZWN0aW9uIiwidXNlV2FsbGV0IiwiTU9WSUVfUkVWSUVXX1BST0dSQU1fSUQiLCJGb3JtIiwidGl0bGUiLCJzZXRUaXRsZSIsInJhdGluZyIsInNldFJhdGluZyIsIm1lc3NhZ2UiLCJzZXRNZXNzYWdlIiwiY29ubmVjdGlvbiIsInB1YmxpY0tleSIsInNlbmRUcmFuc2FjdGlvbiIsImhhbmRsZVN1Ym1pdCIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJtb3ZpZSIsImhhbmRsZVRyYW5zYWN0aW9uU3VibWl0IiwiYnVmZmVyIiwidHJhbnNhY3Rpb24iLCJwZGEiLCJpbnN0cnVjdGlvbiIsInR4aWQiLCJhbGVydCIsInNlcmlhbGl6ZSIsIlRyYW5zYWN0aW9uIiwiUHVibGljS2V5IiwiZmluZFByb2dyYW1BZGRyZXNzIiwidG9CdWZmZXIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsIlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24iLCJrZXlzIiwicHVia2V5IiwiaXNTaWduZXIiLCJpc1dyaXRhYmxlIiwiU3lzdGVtUHJvZ3JhbSIsInByb2dyYW1JZCIsImRhdGEiLCJhZGQiLCJjb25zb2xlIiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsInAiLCJkaXNwbGF5IiwibWQiLCJtYXhXaWR0aCIsImJvcmRlcldpZHRoIiwibWFyZ2luIiwianVzdGlmeUNvbnRlbnQiLCJmb3JtIiwib25TdWJtaXQiLCJpc1JlcXVpcmVkIiwiY29sb3IiLCJpZCIsIm9uQ2hhbmdlIiwiY3VycmVudFRhcmdldCIsInZhbHVlIiwibWF4IiwibWluIiwidmFsdWVTdHJpbmciLCJwYXJzZUludCIsIndpZHRoIiwibXQiLCJ0eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Form.tsx\n");

/***/ }),

/***/ "./components/MovieList.tsx":
/*!**********************************!*\
  !*** ./components/MovieList.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MovieList\": function() { return /* binding */ MovieList; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Card__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Card */ \"./components/Card.tsx\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _models_Movie__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../models/Movie */ \"./models/Movie.ts\");\nvar _this = undefined;\n\n\n\n\nvar _s = $RefreshSig$();\nvar MOVIE_REVIEW_PROGRAM_ID = \"CenYq6bDRB7p73EjsPEpiYN7uveyPUTdXkDkgUduboaN\";\nvar MovieList = function() {\n    var _this1 = _this;\n    _s();\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]), movies = ref[0], setMovies = ref[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function() {\n        setMovies(_models_Movie__WEBPACK_IMPORTED_MODULE_3__.Movie.mocks);\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: movies.map(function(movie, i) {\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Card__WEBPACK_IMPORTED_MODULE_1__.Card, {\n                movie: movie\n            }, i, false, {\n                fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/MovieList.tsx\",\n                lineNumber: 19,\n                columnNumber: 25\n            }, _this1);\n        })\n    }, void 0, false, {\n        fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/components/MovieList.tsx\",\n        lineNumber: 15,\n        columnNumber: 9\n    }, _this);\n};\n_s(MovieList, \"0R7l53CiwQu7ziyMeHtgYF+Ya+E=\");\n_c = MovieList;\nvar _c;\n$RefreshReg$(_c, \"MovieList\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL01vdmllTGlzdC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOztBQUE2QjtBQUNrQjtBQUNSOztBQUV2QyxJQUFNSSx1QkFBdUIsR0FBRyw4Q0FBOEM7QUFFdkUsSUFBTUMsU0FBUyxHQUFPLFdBQU07OztJQUMvQixJQUE0QkgsR0FBcUIsR0FBckJBLCtDQUFRLENBQVUsRUFBRSxDQUFDLEVBUHJELE1BT2lCLEdBQWVBLEdBQXFCLEdBQXBDLEVBUGpCLFNBTzRCLEdBQUlBLEdBQXFCLEdBQXpCO0lBRXhCRCxnREFBUyxDQUFDLFdBQU07UUFDWk0sU0FBUyxDQUFDSixzREFBVyxDQUFDO0tBQ3pCLEVBQUUsRUFBRSxDQUFDO0lBRU4scUJBQ0ksOERBQUNNLEtBQUc7a0JBRUlILE1BQU0sQ0FBQ0ksR0FBRyxDQUFDLFNBQUNDLEtBQUssRUFBRUMsQ0FBQyxFQUFLO1lBQ3JCLHFCQUNJLDhEQUFDWix1Q0FBSTtnQkFBU1csS0FBSyxFQUFFQSxLQUFLO2VBQWZDLENBQUM7Ozs7c0JBQWtCLENBQ2pDO1NBQ0osQ0FBQzs7Ozs7YUFFSixDQUNUO0NBQ0o7R0FsQllQLFNBQVM7QUFBVEEsS0FBQUEsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL01vdmllTGlzdC50c3g/OTdlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYXJkIH0gZnJvbSAnLi9DYXJkJ1xuaW1wb3J0IHsgRkMsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IE1vdmllIH0gZnJvbSAnLi4vbW9kZWxzL01vdmllJ1xuXG5jb25zdCBNT1ZJRV9SRVZJRVdfUFJPR1JBTV9JRCA9ICdDZW5ZcTZiRFJCN3A3M0Vqc1BFcGlZTjd1dmV5UFVUZFhrRGtnVWR1Ym9hTidcblxuZXhwb3J0IGNvbnN0IE1vdmllTGlzdDogRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgW21vdmllcywgc2V0TW92aWVzXSA9IHVzZVN0YXRlPE1vdmllW10+KFtdKVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0TW92aWVzKE1vdmllLm1vY2tzKVxuICAgIH0sIFtdKVxuICAgIFxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbW92aWVzLm1hcCgobW92aWUsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDYXJkIGtleT17aX0gbW92aWU9e21vdmllfSAvPlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgPC9kaXY+XG4gICAgKVxufSJdLCJuYW1lcyI6WyJDYXJkIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJNb3ZpZSIsIk1PVklFX1JFVklFV19QUk9HUkFNX0lEIiwiTW92aWVMaXN0IiwibW92aWVzIiwic2V0TW92aWVzIiwibW9ja3MiLCJkaXYiLCJtYXAiLCJtb3ZpZSIsImkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/MovieList.tsx\n");

/***/ }),

/***/ "./models/Movie.ts":
/*!*************************!*\
  !*** ./models/Movie.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Movie\": function() { return /* binding */ Movie; }\n/* harmony export */ });\n/* harmony import */ var _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @coral-xyz/borsh */ \"./node_modules/@coral-xyz/borsh/dist/index.js\");\n/* harmony import */ var _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\n\nvar Movie = /*#__PURE__*/ function() {\n    \"use strict\";\n    function Movie(title, rating, description) {\n        _classCallCheck(this, Movie);\n        this.borshInstructionSchema = _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.struct([\n            _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.u8(\"variant\"),\n            _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.str(\"title\"),\n            _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.u8(\"rating\"),\n            _coral_xyz_borsh__WEBPACK_IMPORTED_MODULE_0__.str(\"description\"), \n        ]);\n        this.title = title;\n        this.rating = rating;\n        this.description = description;\n    }\n    var _proto = Movie.prototype;\n    _proto.serialize = function serialize() {\n        var buffer = Buffer.alloc(1000);\n        this.borshInstructionSchema.encode(_objectSpread({}, this, {\n            variant: 0\n        }), buffer);\n        return buffer.slice(0, this.borshInstructionSchema.getSpan(buffer));\n    };\n    return Movie;\n}();\nMovie.mocks = [\n    new Movie(\"The Shawshank Redemption\", 5, \"For a movie shot entirely in prison where there is no hope at all, shawshank redemption's main massage and purpose is to remind us of hope, that even in the darkest places hope exists, and only needs someone to find it. Combine this message with a brilliant screenplay, lovely characters and Martin freeman, and you get a movie that can teach you a lesson everytime you watch it. An all time Classic!!!\"),\n    new Movie(\"The Godfather\", 5, \"One of Hollywood's greatest critical and commercial successes, The Godfather gets everything right; not only did the movie transcend expectations, it established new benchmarks for American cinema.\"),\n    new Movie(\"The Godfather: Part II\", 4, \"The Godfather: Part II is a continuation of the saga of the late Italian-American crime boss, Francis Ford Coppola, and his son, Vito Corleone. The story follows the continuing saga of the Corleone family as they attempt to successfully start a new life for themselves after years of crime and corruption.\"),\n    new Movie(\"The Dark Knight\", 5, \"The Dark Knight is a 2008 superhero film directed, produced, and co-written by Christopher Nolan. Batman, in his darkest hour, faces his greatest challenge yet: he must become the symbol of the opposite of the Batmanian order, the League of Shadows.\"), \n];\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tb2RlbHMvTW92aWUudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEM7QUFFbkMsU0FBVyxpQkFGZjs7YUFFVUMsS0FBSyxDQUtKQyxLQUFhLEVBQUVDLE1BQWMsRUFBRUMsV0FBbUI7O1FBNkI5REMsS0FBQUEsc0JBQXNCLEdBQUdMLG9EQUFZLENBQUM7WUFDcENBLGdEQUFRLENBQUMsU0FBUyxDQUFDO1lBRW5CQSxpREFBUyxDQUFDLE9BQU8sQ0FBQztZQUVsQkEsZ0RBQVEsQ0FBQyxRQUFRLENBQUM7WUFFbEJBLGlEQUFTLENBQUMsYUFBYSxDQUFDO1NBQ3pCLENBQUMsQ0FBQztRQXBDRCxJQUFJLENBQUNFLEtBQUssR0FBR0EsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQ0MsTUFBTSxHQUFHQSxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDQyxXQUFXLEdBQUdBLFdBQVcsQ0FBQzs7aUJBUnRCSCxLQUFLO0lBNENoQlEsT0FBQUEsU0FBUyxHQUFUQSxTQUFBQSxTQUFTLEdBQVc7UUFDbEIsSUFBTUMsTUFBTSxHQUFHQyxNQUFNLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUM7UUFFakMsSUFBSSxDQUFDUCxzQkFBc0IsQ0FBQ1EsTUFBTSxDQUFDLGtCQUFLLElBQUk7WUFBRUMsT0FBTyxFQUFFLENBQUM7VUFBRSxFQUFFSixNQUFNLENBQUMsQ0FBQztRQUVwRSxPQUFPQSxNQUFNLENBQUNLLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDVixzQkFBc0IsQ0FBQ1csT0FBTyxDQUFDTixNQUFNLENBQUMsQ0FBQyxDQUFDO0tBQ3JFOztDQUNGO0FBeENDLEtBWGdCLENBV1RPLEtBQUssR0FBWTtJQUN0QixJQUFJaEIsS0FBSyxDQUNQLDBCQUEwQixFQUMxQixDQUFDLEVBQ0Esb1pBQWtaLENBQ3BaO0lBQ0QsSUFBSUEsS0FBSyxDQUNQLGVBQWUsRUFDZixDQUFDLEVBQ0EsdU1BQXFNLENBQ3ZNO0lBQ0QsSUFBSUEsS0FBSyxDQUNQLHdCQUF3QixFQUN4QixDQUFDLEVBQ0EsbVRBQWlULENBQ25UO0lBQ0QsSUFBSUEsS0FBSyxDQUNQLGlCQUFpQixFQUNqQixDQUFDLEVBQ0EsMlBBQXlQLENBQzNQO0NBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbW9kZWxzL01vdmllLnRzPzllYjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYm9yc2ggZnJvbSBcIkBjb3JhbC14eXovYm9yc2hcIjtcblxuZXhwb3J0IGNsYXNzIE1vdmllIHtcbiAgdGl0bGU6IHN0cmluZztcbiAgcmF0aW5nOiBudW1iZXI7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IodGl0bGU6IHN0cmluZywgcmF0aW5nOiBudW1iZXIsIGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcbiAgICB0aGlzLnRpdGxlID0gdGl0bGU7XG4gICAgdGhpcy5yYXRpbmcgPSByYXRpbmc7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICB9XG5cbiAgc3RhdGljIG1vY2tzOiBNb3ZpZVtdID0gW1xuICAgIG5ldyBNb3ZpZShcbiAgICAgIFwiVGhlIFNoYXdzaGFuayBSZWRlbXB0aW9uXCIsXG4gICAgICA1LFxuICAgICAgYEZvciBhIG1vdmllIHNob3QgZW50aXJlbHkgaW4gcHJpc29uIHdoZXJlIHRoZXJlIGlzIG5vIGhvcGUgYXQgYWxsLCBzaGF3c2hhbmsgcmVkZW1wdGlvbidzIG1haW4gbWFzc2FnZSBhbmQgcHVycG9zZSBpcyB0byByZW1pbmQgdXMgb2YgaG9wZSwgdGhhdCBldmVuIGluIHRoZSBkYXJrZXN0IHBsYWNlcyBob3BlIGV4aXN0cywgYW5kIG9ubHkgbmVlZHMgc29tZW9uZSB0byBmaW5kIGl0LiBDb21iaW5lIHRoaXMgbWVzc2FnZSB3aXRoIGEgYnJpbGxpYW50IHNjcmVlbnBsYXksIGxvdmVseSBjaGFyYWN0ZXJzIGFuZCBNYXJ0aW4gZnJlZW1hbiwgYW5kIHlvdSBnZXQgYSBtb3ZpZSB0aGF0IGNhbiB0ZWFjaCB5b3UgYSBsZXNzb24gZXZlcnl0aW1lIHlvdSB3YXRjaCBpdC4gQW4gYWxsIHRpbWUgQ2xhc3NpYyEhIWBcbiAgICApLFxuICAgIG5ldyBNb3ZpZShcbiAgICAgIFwiVGhlIEdvZGZhdGhlclwiLFxuICAgICAgNSxcbiAgICAgIGBPbmUgb2YgSG9sbHl3b29kJ3MgZ3JlYXRlc3QgY3JpdGljYWwgYW5kIGNvbW1lcmNpYWwgc3VjY2Vzc2VzLCBUaGUgR29kZmF0aGVyIGdldHMgZXZlcnl0aGluZyByaWdodDsgbm90IG9ubHkgZGlkIHRoZSBtb3ZpZSB0cmFuc2NlbmQgZXhwZWN0YXRpb25zLCBpdCBlc3RhYmxpc2hlZCBuZXcgYmVuY2htYXJrcyBmb3IgQW1lcmljYW4gY2luZW1hLmBcbiAgICApLFxuICAgIG5ldyBNb3ZpZShcbiAgICAgIFwiVGhlIEdvZGZhdGhlcjogUGFydCBJSVwiLFxuICAgICAgNCxcbiAgICAgIGBUaGUgR29kZmF0aGVyOiBQYXJ0IElJIGlzIGEgY29udGludWF0aW9uIG9mIHRoZSBzYWdhIG9mIHRoZSBsYXRlIEl0YWxpYW4tQW1lcmljYW4gY3JpbWUgYm9zcywgRnJhbmNpcyBGb3JkIENvcHBvbGEsIGFuZCBoaXMgc29uLCBWaXRvIENvcmxlb25lLiBUaGUgc3RvcnkgZm9sbG93cyB0aGUgY29udGludWluZyBzYWdhIG9mIHRoZSBDb3JsZW9uZSBmYW1pbHkgYXMgdGhleSBhdHRlbXB0IHRvIHN1Y2Nlc3NmdWxseSBzdGFydCBhIG5ldyBsaWZlIGZvciB0aGVtc2VsdmVzIGFmdGVyIHllYXJzIG9mIGNyaW1lIGFuZCBjb3JydXB0aW9uLmBcbiAgICApLFxuICAgIG5ldyBNb3ZpZShcbiAgICAgIFwiVGhlIERhcmsgS25pZ2h0XCIsXG4gICAgICA1LFxuICAgICAgYFRoZSBEYXJrIEtuaWdodCBpcyBhIDIwMDggc3VwZXJoZXJvIGZpbG0gZGlyZWN0ZWQsIHByb2R1Y2VkLCBhbmQgY28td3JpdHRlbiBieSBDaHJpc3RvcGhlciBOb2xhbi4gQmF0bWFuLCBpbiBoaXMgZGFya2VzdCBob3VyLCBmYWNlcyBoaXMgZ3JlYXRlc3QgY2hhbGxlbmdlIHlldDogaGUgbXVzdCBiZWNvbWUgdGhlIHN5bWJvbCBvZiB0aGUgb3Bwb3NpdGUgb2YgdGhlIEJhdG1hbmlhbiBvcmRlciwgdGhlIExlYWd1ZSBvZiBTaGFkb3dzLmBcbiAgICApLFxuICBdO1xuXG4gIGJvcnNoSW5zdHJ1Y3Rpb25TY2hlbWEgPSBib3JzaC5zdHJ1Y3QoW1xuICAgIGJvcnNoLnU4KFwidmFyaWFudFwiKSxcblxuICAgIGJvcnNoLnN0cihcInRpdGxlXCIpLFxuXG4gICAgYm9yc2gudTgoXCJyYXRpbmdcIiksXG5cbiAgICBib3JzaC5zdHIoXCJkZXNjcmlwdGlvblwiKSxcbiAgXSk7XG5cbiAgc2VyaWFsaXplKCk6IEJ1ZmZlciB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEwMDApO1xuXG4gICAgdGhpcy5ib3JzaEluc3RydWN0aW9uU2NoZW1hLmVuY29kZSh7IC4uLnRoaXMsIHZhcmlhbnQ6IDAgfSwgYnVmZmVyKTtcblxuICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgdGhpcy5ib3JzaEluc3RydWN0aW9uU2NoZW1hLmdldFNwYW4oYnVmZmVyKSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJib3JzaCIsIk1vdmllIiwidGl0bGUiLCJyYXRpbmciLCJkZXNjcmlwdGlvbiIsImJvcnNoSW5zdHJ1Y3Rpb25TY2hlbWEiLCJzdHJ1Y3QiLCJ1OCIsInN0ciIsInNlcmlhbGl6ZSIsImJ1ZmZlciIsIkJ1ZmZlciIsImFsbG9jIiwiZW5jb2RlIiwidmFyaWFudCIsInNsaWNlIiwiZ2V0U3BhbiIsIm1vY2tzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./models/Movie.ts\n");

/***/ }),

/***/ "./node_modules/next/dist/client/image.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/image.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s2, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s2 = _i.next()).done); _n = true){\n            _arr.push(_s2.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = Image;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _head = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\"));\nvar _imageConfig = __webpack_require__(/*! ../shared/lib/image-config */ \"./node_modules/next/dist/shared/lib/image-config.js\");\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\nvar _imageConfigContext = __webpack_require__(/*! ../shared/lib/image-config-context */ \"./node_modules/next/dist/shared/lib/image-config-context.js\");\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nfunction Image(_param) {\n    _s();\n    var src = _param.src, sizes = _param.sizes, _unoptimized = _param.unoptimized, unoptimized = _unoptimized === void 0 ? false : _unoptimized, _priority = _param.priority, priority = _priority === void 0 ? false : _priority, loading = _param.loading, _lazyRoot = _param.lazyRoot, lazyRoot = _lazyRoot === void 0 ? null : _lazyRoot, _lazyBoundary = _param.lazyBoundary, lazyBoundary = _lazyBoundary === void 0 ? \"200px\" : _lazyBoundary, className = _param.className, quality = _param.quality, width = _param.width, height = _param.height, style = _param.style, objectFit = _param.objectFit, objectPosition = _param.objectPosition, onLoadingComplete = _param.onLoadingComplete, onError = _param.onError, _placeholder = _param.placeholder, placeholder = _placeholder === void 0 ? \"empty\" : _placeholder, blurDataURL = _param.blurDataURL, all = _objectWithoutProperties(_param, [\n        \"src\",\n        \"sizes\",\n        \"unoptimized\",\n        \"priority\",\n        \"loading\",\n        \"lazyRoot\",\n        \"lazyBoundary\",\n        \"className\",\n        \"quality\",\n        \"width\",\n        \"height\",\n        \"style\",\n        \"objectFit\",\n        \"objectPosition\",\n        \"onLoadingComplete\",\n        \"onError\",\n        \"placeholder\",\n        \"blurDataURL\"\n    ]);\n    var configContext = (0, _react).useContext(_imageConfigContext.ImageConfigContext);\n    var config = (0, _react).useMemo(function() {\n        var c = configEnv || configContext || _imageConfig.imageConfigDefault;\n        var allSizes = _toConsumableArray(c.deviceSizes).concat(_toConsumableArray(c.imageSizes)).sort(function(a, b) {\n            return a - b;\n        });\n        var deviceSizes = c.deviceSizes.sort(function(a, b) {\n            return a - b;\n        });\n        return _objectSpread({}, c, {\n            allSizes: allSizes,\n            deviceSizes: deviceSizes\n        });\n    }, [\n        configContext\n    ]);\n    var rest = all;\n    var layout = sizes ? \"responsive\" : \"intrinsic\";\n    if (\"layout\" in rest) {\n        // Override default layout if the user specified one:\n        if (rest.layout) layout = rest.layout;\n        // Remove property so it's not spread on <img>:\n        delete rest.layout;\n    }\n    var loader = defaultImageLoader;\n    if (\"loader\" in rest) {\n        if (rest.loader) {\n            var customImageLoader = rest.loader;\n            var _tmp;\n            _tmp = function(obj) {\n                var _ = obj.config, opts = _objectWithoutProperties(obj, [\n                    \"config\"\n                ]);\n                // The config object is internal only so we must\n                // not pass it to the user-defined loader()\n                return customImageLoader(opts);\n            }, loader = _tmp, _tmp;\n        }\n        // Remove property so it's not spread on <img>\n        delete rest.loader;\n    }\n    var staticSrc = \"\";\n    if (isStaticImport(src)) {\n        var staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \".concat(JSON.stringify(staticImageData)));\n        }\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!layout || layout !== \"fill\") {\n            height = height || staticImageData.height;\n            width = width || staticImageData.width;\n            if (!staticImageData.height || !staticImageData.width) {\n                throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \".concat(JSON.stringify(staticImageData)));\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    var widthInt = getInt(width);\n    var heightInt = getInt(height);\n    var qualityInt = getInt(quality);\n    var isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if ( true && loadedImageURLs.has(src)) {\n        isLazy = false;\n    }\n    var ref2 = _slicedToArray((0, _react).useState(false), 2), blurComplete = ref2[0], setBlurComplete = ref2[1];\n    var ref1 = _slicedToArray((0, _useIntersection).useIntersection({\n        rootRef: lazyRoot,\n        rootMargin: lazyBoundary,\n        disabled: !isLazy\n    }), 3), setIntersection = ref1[0], isIntersected = ref1[1], resetIntersected = ref1[2];\n    var isVisible = !isLazy || isIntersected;\n    var wrapperStyle = {\n        boxSizing: \"border-box\",\n        display: \"block\",\n        overflow: \"hidden\",\n        width: \"initial\",\n        height: \"initial\",\n        background: \"none\",\n        opacity: 1,\n        border: 0,\n        margin: 0,\n        padding: 0\n    };\n    var sizerStyle = {\n        boxSizing: \"border-box\",\n        display: \"block\",\n        width: \"initial\",\n        height: \"initial\",\n        background: \"none\",\n        opacity: 1,\n        border: 0,\n        margin: 0,\n        padding: 0\n    };\n    var hasSizer = false;\n    var sizerSvgUrl;\n    var layoutStyle = {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0,\n        boxSizing: \"border-box\",\n        padding: 0,\n        border: \"none\",\n        margin: \"auto\",\n        display: \"block\",\n        width: 0,\n        height: 0,\n        minWidth: \"100%\",\n        maxWidth: \"100%\",\n        minHeight: \"100%\",\n        maxHeight: \"100%\",\n        objectFit: objectFit,\n        objectPosition: objectPosition\n    };\n    if ( true && layout !== \"raw\" && style) {}\n    if (true) {\n        if (!src) {\n            throw new Error('Image is missing required \"src\" property. Make sure you pass \"src\" in props to the `next/image` component. Received: '.concat(JSON.stringify({\n                width: width,\n                height: height,\n                quality: quality\n            })));\n        }\n        if (!VALID_LAYOUT_VALUES.includes(layout)) {\n            throw new Error('Image with src \"'.concat(src, '\" has invalid \"layout\" property. Provided \"').concat(layout, '\" should be one of ').concat(VALID_LAYOUT_VALUES.map(String).join(\",\"), \".\"));\n        }\n        if (layout === \"raw\" && !experimentalLayoutRaw) {\n            throw new Error('The \"raw\" layout is currently experimental and may be subject to breaking changes. To use layout=\"raw\", include `experimental: { images: { layoutRaw: true } }` in your next.config.js file.');\n        }\n        if (typeof widthInt !== \"undefined\" && isNaN(widthInt) || typeof heightInt !== \"undefined\" && isNaN(heightInt)) {\n            throw new Error('Image with src \"'.concat(src, '\" has invalid \"width\" or \"height\" property. These should be numeric values.'));\n        }\n        if (layout === \"fill\" && (width || height)) {\n            (0, _utils).warnOnce('Image with src \"'.concat(src, '\" and \"layout=\\'fill\\'\" has unused properties assigned. Please remove \"width\" and \"height\".'));\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"'.concat(src, '\" has invalid \"loading\" property. Provided \"').concat(loading, '\" should be one of ').concat(VALID_LOADING_VALUES.map(String).join(\",\"), \".\"));\n        }\n        if (priority && loading === \"lazy\") {\n            throw new Error('Image with src \"'.concat(src, '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.'));\n        }\n        if (layout === \"raw\" && (objectFit || objectPosition)) {\n            throw new Error('Image with src \"'.concat(src, \"\\\" has \\\"layout='raw'\\\" and 'objectFit' or 'objectPosition'. For raw images, these and other styles should be specified using the 'style' attribute.\"));\n        }\n        if (sizes && layout !== \"fill\" && layout !== \"responsive\" && layout !== \"raw\") {\n            (0, _utils).warnOnce('Image with src \"'.concat(src, '\" has \"sizes\" property but it will be ignored. Only use \"sizes\" with \"layout=\\'fill\\'\", \"layout=\\'responsive\\'\", or \"layout=\\'raw\\''));\n        }\n        if (placeholder === \"blur\") {\n            if (layout !== \"fill\" && (widthInt || 0) * (heightInt || 0) < 1600) {\n                (0, _utils).warnOnce('Image with src \"'.concat(src, '\" is smaller than 40x40. Consider removing the \"placeholder=\\'blur\\'\" property to improve performance.'));\n            }\n            if (!blurDataURL) {\n                var VALID_BLUR_EXT = [\n                    \"jpeg\",\n                    \"png\",\n                    \"webp\",\n                    \"avif\"\n                ] // should match next-image-loader\n                ;\n                throw new Error('Image with src \"'.concat(src, '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n          Possible solutions:\\n            - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n            - Change the \"src\" property to a static import with one of the supported file types: ').concat(VALID_BLUR_EXT.join(\",\"), '\\n            - Remove the \"placeholder\" property, effectively no blur effect\\n          Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url'));\n            }\n        }\n        if (\"ref\" in rest) {\n            (0, _utils).warnOnce('Image with src \"'.concat(src, '\" is using unsupported \"ref\" property. Consider using the \"onLoadingComplete\" property instead.'));\n        }\n        if (!unoptimized && loader !== defaultImageLoader) {\n            var urlStr = loader({\n                config: config,\n                src: src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            var url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _utils).warnOnce('Image with src \"'.concat(src, '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.') + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (style && layout !== \"raw\") {\n            var overwrittenStyles = Object.keys(style).filter(function(key) {\n                return key in layoutStyle;\n            });\n            if (overwrittenStyles.length) {\n                (0, _utils).warnOnce(\"Image with src \".concat(src, \" is assigned the following styles, which are overwritten by automatically-generated styles: \").concat(overwrittenStyles.join(\", \")));\n            }\n        }\n        if ( true && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver(function(entryList) {\n                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                try {\n                    for(var _iterator = entryList.getEntries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                        var entry = _step.value;\n                        var ref1;\n                        // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                        var imgSrc = (entry === null || entry === void 0 ? void 0 : (ref1 = entry.element) === null || ref1 === void 0 ? void 0 : ref1.src) || \"\";\n                        var lcpImage = allImgs.get(imgSrc);\n                        if (lcpImage && !lcpImage.priority && lcpImage.placeholder !== \"blur\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                            // https://web.dev/lcp/#measure-lcp-in-javascript\n                            (0, _utils).warnOnce('Image with src \"'.concat(lcpImage.src, '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.') + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally{\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return != null) {\n                            _iterator.return();\n                        }\n                    } finally{\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: \"largest-contentful-paint\",\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    var imgStyle = Object.assign({}, style, layout === \"raw\" ? {\n        aspectRatio: \"\".concat(widthInt, \" / \").concat(heightInt)\n    } : layoutStyle);\n    var blurStyle = placeholder === \"blur\" && !blurComplete ? {\n        filter: \"blur(20px)\",\n        backgroundSize: objectFit || \"cover\",\n        backgroundImage: 'url(\"'.concat(blurDataURL, '\")'),\n        backgroundPosition: objectPosition || \"0% 0%\"\n    } : {};\n    if (layout === \"fill\") {\n        // <Image src=\"i.png\" layout=\"fill\" />\n        wrapperStyle.display = \"block\";\n        wrapperStyle.position = \"absolute\";\n        wrapperStyle.top = 0;\n        wrapperStyle.left = 0;\n        wrapperStyle.bottom = 0;\n        wrapperStyle.right = 0;\n    } else if (typeof widthInt !== \"undefined\" && typeof heightInt !== \"undefined\") {\n        // <Image src=\"i.png\" width=\"100\" height=\"100\" />\n        var quotient = heightInt / widthInt;\n        var paddingTop = isNaN(quotient) ? \"100%\" : \"\".concat(quotient * 100, \"%\");\n        if (layout === \"responsive\") {\n            // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"responsive\" />\n            wrapperStyle.display = \"block\";\n            wrapperStyle.position = \"relative\";\n            hasSizer = true;\n            sizerStyle.paddingTop = paddingTop;\n        } else if (layout === \"intrinsic\") {\n            // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"intrinsic\" />\n            wrapperStyle.display = \"inline-block\";\n            wrapperStyle.position = \"relative\";\n            wrapperStyle.maxWidth = \"100%\";\n            hasSizer = true;\n            sizerStyle.maxWidth = \"100%\";\n            sizerSvgUrl = \"data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27\".concat(widthInt, \"%27%20height=%27\").concat(heightInt, \"%27/%3e\");\n        } else if (layout === \"fixed\") {\n            // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"fixed\" />\n            wrapperStyle.display = \"inline-block\";\n            wrapperStyle.position = \"relative\";\n            wrapperStyle.width = widthInt;\n            wrapperStyle.height = heightInt;\n        }\n    } else {\n        // <Image src=\"i.png\" />\n        if (true) {\n            throw new Error('Image with src \"'.concat(src, '\" must use \"width\" and \"height\" properties or \"layout=\\'fill\\'\" property.'));\n        }\n    }\n    var imgAttributes = {\n        src: emptyDataURL,\n        srcSet: undefined,\n        sizes: undefined\n    };\n    if (isVisible) {\n        imgAttributes = generateImgAttrs({\n            config: config,\n            src: src,\n            unoptimized: unoptimized,\n            layout: layout,\n            width: widthInt,\n            quality: qualityInt,\n            sizes: sizes,\n            loader: loader\n        });\n    }\n    var srcString = src;\n    if (true) {\n        if (true) {\n            var fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src: src,\n                priority: priority,\n                placeholder: placeholder\n            });\n        }\n    }\n    var imageSrcSetPropName = \"imagesrcset\";\n    var imageSizesPropName = \"imagesizes\";\n    if (true) {\n        imageSrcSetPropName = \"imageSrcSet\";\n        imageSizesPropName = \"imageSizes\";\n    }\n    var _obj;\n    var linkProps = (_obj = {}, // Note: imagesrcset and imagesizes are not in the link element type with react 17.\n    _defineProperty(_obj, imageSrcSetPropName, imgAttributes.srcSet), _defineProperty(_obj, imageSizesPropName, imgAttributes.sizes), _obj);\n    var useLayoutEffect =  false ? 0 : _react.default.useLayoutEffect;\n    var onLoadingCompleteRef = (0, _react).useRef(onLoadingComplete);\n    var previousImageSrc = (0, _react).useRef(src);\n    (0, _react).useEffect(function() {\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    useLayoutEffect(function() {\n        if (previousImageSrc.current !== src) {\n            resetIntersected();\n            previousImageSrc.current = src;\n        }\n    }, [\n        resetIntersected,\n        src\n    ]);\n    var imgElementArgs = _objectSpread({\n        isLazy: isLazy,\n        imgAttributes: imgAttributes,\n        heightInt: heightInt,\n        widthInt: widthInt,\n        qualityInt: qualityInt,\n        layout: layout,\n        className: className,\n        imgStyle: imgStyle,\n        blurStyle: blurStyle,\n        loading: loading,\n        config: config,\n        unoptimized: unoptimized,\n        placeholder: placeholder,\n        loader: loader,\n        srcString: srcString,\n        onLoadingCompleteRef: onLoadingCompleteRef,\n        setBlurComplete: setBlurComplete,\n        setIntersection: setIntersection,\n        isVisible: isVisible\n    }, rest);\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, layout === \"raw\" ? /*#__PURE__*/ _react.default.createElement(ImageElement, Object.assign({}, imgElementArgs)) : /*#__PURE__*/ _react.default.createElement(\"span\", {\n        style: wrapperStyle\n    }, hasSizer ? /*#__PURE__*/ _react.default.createElement(\"span\", {\n        style: sizerStyle\n    }, sizerSvgUrl ? /*#__PURE__*/ _react.default.createElement(\"img\", {\n        style: {\n            display: \"block\",\n            maxWidth: \"100%\",\n            width: \"initial\",\n            height: \"initial\",\n            background: \"none\",\n            opacity: 1,\n            border: 0,\n            margin: 0,\n            padding: 0\n        },\n        alt: \"\",\n        \"aria-hidden\": true,\n        src: sizerSvgUrl\n    }) : null) : null, /*#__PURE__*/ _react.default.createElement(ImageElement, Object.assign({}, imgElementArgs))), priority ? // for browsers that do not support `imagesrcset`, and in those cases\n    // it would likely cause the incorrect image to be preloaded.\n    //\n    // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n    /*#__PURE__*/ _react.default.createElement(_head.default, null, /*#__PURE__*/ _react.default.createElement(\"link\", Object.assign({\n        key: \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes,\n        rel: \"preload\",\n        as: \"image\",\n        href: imgAttributes.srcSet ? undefined : imgAttributes.src\n    }, linkProps))) : null);\n}\n_s(Image, \"JC32V8ZswcgqIp1SSTncST29uwM=\");\n_c = Image;\nfunction _defineProperty1(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {};\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nfunction _objectSpread(target) {\n    var _arguments = arguments, _loop = function(i) {\n        var source = _arguments[i] != null ? _arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty1(target, key, source[key]);\n        });\n    };\n    for(var i = 1; i < arguments.length; i++)_loop(i);\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nvar ref;\nvar experimentalLayoutRaw = (ref = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"experimentalLayoutRaw\":false,\"domains\":[]}) === null || ref === void 0 ? void 0 : ref.experimentalLayoutRaw;\nvar configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"experimentalLayoutRaw\":false,\"domains\":[]};\nvar loadedImageURLs = new Set();\nvar allImgs = new Map();\nvar perfObserver;\nvar emptyDataURL = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\nif (false) {}\nvar VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nvar loaders = new Map([\n    [\n        \"default\",\n        defaultLoader\n    ],\n    [\n        \"imgix\",\n        imgixLoader\n    ],\n    [\n        \"cloudinary\",\n        cloudinaryLoader\n    ],\n    [\n        \"akamai\",\n        akamaiLoader\n    ],\n    [\n        \"custom\",\n        customLoader\n    ], \n]);\nvar VALID_LAYOUT_VALUES = [\n    \"fill\",\n    \"fixed\",\n    \"intrinsic\",\n    \"responsive\",\n    \"raw\",\n    undefined, \n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nfunction getWidths(param, width, layout, sizes) {\n    var deviceSizes = param.deviceSizes, allSizes = param.allSizes;\n    if (sizes && (layout === \"fill\" || layout === \"responsive\" || layout === \"raw\")) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        var viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        var percentSizes = [];\n        for(var match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            var _Math;\n            var smallestRatio = (_Math = Math).min.apply(_Math, _toConsumableArray(percentSizes)) * 0.01;\n            return {\n                widths: allSizes.filter(function(s) {\n                    return s >= deviceSizes[0] * smallestRatio;\n                }),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\" || layout === \"fill\" || layout === \"responsive\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    var widths = _toConsumableArray(new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n    // > blue colors. Showing a 3x resolution image in the app vs a 2x\n    // > resolution image will be visually the same, though the 3x image\n    // > takes significantly more data. Even true 3x resolution screens are\n    // > wasteful as the human eye cannot see that level of detail without\n    // > something like a magnifying glass.\n    // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n    [\n        width,\n        width * 2 /*, width * 3*/ \n    ].map(function(w) {\n        return allSizes.find(function(p) {\n            return p >= w;\n        }) || allSizes[allSizes.length - 1];\n    })));\n    return {\n        widths: widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    var config = param.config, src = param.src, unoptimized = param.unoptimized, layout = param.layout, width = param.width, quality = param.quality, sizes = param.sizes, loader = param.loader;\n    if (unoptimized) {\n        return {\n            src: src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    var ref3 = getWidths(config, width, layout, sizes), widths = ref3.widths, kind = ref3.kind;\n    var last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map(function(w, i) {\n            return \"\".concat(loader({\n                config: config,\n                src: src,\n                quality: quality,\n                width: w\n            }), \" \").concat(kind === \"w\" ? w : i + 1).concat(kind);\n        }).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config: config,\n            src: src,\n            quality: quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getInt(x) {\n    if (typeof x === \"number\") {\n        return x;\n    }\n    if (typeof x === \"string\") {\n        return parseInt(x, 10);\n    }\n    return undefined;\n}\nfunction defaultImageLoader(loaderProps) {\n    var ref2;\n    var loaderKey = ((ref2 = loaderProps.config) === null || ref2 === void 0 ? void 0 : ref2.loader) || \"default\";\n    var load = loaders.get(loaderKey);\n    if (load) {\n        return load(loaderProps);\n    }\n    throw new Error('Unknown \"loader\" found in \"next.config.js\". Expected: '.concat(_imageConfig.VALID_LOADERS.join(\", \"), \". Received: \").concat(loaderKey));\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, src, layout, placeholder, onLoadingCompleteRef, setBlurComplete) {\n    if (!img || img.src === emptyDataURL || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    var p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p.catch(function() {}).then(function() {\n        if (!img.parentNode) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        loadedImageURLs.add(src);\n        if (placeholder === \"blur\") {\n            setBlurComplete(true);\n        }\n        if (onLoadingCompleteRef === null || onLoadingCompleteRef === void 0 ? void 0 : onLoadingCompleteRef.current) {\n            var naturalWidth = img.naturalWidth, naturalHeight = img.naturalHeight;\n            // Pass back read-only primitive values but not the\n            // underlying DOM element because it could be misused.\n            onLoadingCompleteRef.current({\n                naturalWidth: naturalWidth,\n                naturalHeight: naturalHeight\n            });\n        }\n        if (true) {\n            var ref3;\n            if ((ref3 = img.parentElement) === null || ref3 === void 0 ? void 0 : ref3.parentElement) {\n                var parent = getComputedStyle(img.parentElement.parentElement);\n                if (!parent.position) {\n                // The parent has not been rendered to the dom yet and therefore it has no position. Skip the warnings for such cases.\n                } else if (layout === \"responsive\" && parent.display === \"flex\") {\n                    (0, _utils).warnOnce('Image with src \"'.concat(src, '\" may not render properly as a child of a flex container. Consider wrapping the image with a div to configure the width.'));\n                } else if (layout === \"fill\" && parent.position !== \"relative\" && parent.position !== \"fixed\" && parent.position !== \"absolute\") {\n                    (0, _utils).warnOnce('Image with src \"'.concat(src, '\" may not render properly with a parent using position:\"').concat(parent.position, '\". Consider changing the parent style to position:\"relative\" with a width and height.'));\n                }\n            }\n        }\n    });\n}\nvar ImageElement = function(_param) {\n    _s1();\n    var imgAttributes = _param.imgAttributes, heightInt = _param.heightInt, widthInt = _param.widthInt, qualityInt = _param.qualityInt, layout = _param.layout, className = _param.className, imgStyle = _param.imgStyle, blurStyle = _param.blurStyle, isLazy = _param.isLazy, placeholder = _param.placeholder, loading = _param.loading, srcString = _param.srcString, config = _param.config, unoptimized = _param.unoptimized, loader = _param.loader, onLoadingCompleteRef = _param.onLoadingCompleteRef, setBlurComplete = _param.setBlurComplete, setIntersection = _param.setIntersection, onError = _param.onError, isVisible = _param.isVisible, rest = _objectWithoutProperties(_param, [\n        \"imgAttributes\",\n        \"heightInt\",\n        \"widthInt\",\n        \"qualityInt\",\n        \"layout\",\n        \"className\",\n        \"imgStyle\",\n        \"blurStyle\",\n        \"isLazy\",\n        \"placeholder\",\n        \"loading\",\n        \"srcString\",\n        \"config\",\n        \"unoptimized\",\n        \"loader\",\n        \"onLoadingCompleteRef\",\n        \"setBlurComplete\",\n        \"setIntersection\",\n        \"onError\",\n        \"isVisible\"\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"img\", Object.assign({}, rest, imgAttributes, layout === \"raw\" && !imgAttributes.sizes ? {\n        height: heightInt,\n        width: widthInt\n    } : {}, {\n        decoding: \"async\",\n        \"data-nimg\": layout,\n        className: className,\n        style: _objectSpread({}, imgStyle, blurStyle),\n        ref: (0, _react).useCallback(function(img) {\n            setIntersection(img);\n            if (img === null || img === void 0 ? void 0 : img.complete) {\n                handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n            }\n        }, [\n            setIntersection,\n            srcString,\n            layout,\n            placeholder,\n            onLoadingCompleteRef,\n            setBlurComplete, \n        ]),\n        onLoad: function(event) {\n            var img = event.currentTarget;\n            handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n        },\n        onError: function(event) {\n            if (placeholder === \"blur\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    })), (isLazy || placeholder === \"blur\") && /*#__PURE__*/ _react.default.createElement(\"noscript\", null, /*#__PURE__*/ _react.default.createElement(\"img\", Object.assign({}, rest, generateImgAttrs({\n        config: config,\n        src: srcString,\n        unoptimized: unoptimized,\n        layout: layout,\n        width: widthInt,\n        quality: qualityInt,\n        sizes: imgAttributes.sizes,\n        loader: loader\n    }), layout === \"raw\" && !imgAttributes.sizes ? {\n        height: heightInt,\n        width: widthInt\n    } : {}, {\n        decoding: \"async\",\n        \"data-nimg\": layout,\n        style: imgStyle,\n        className: className,\n        // @ts-ignore - TODO: upgrade to `@types/react@17`\n        loading: loading || \"lazy\"\n    }))));\n};\n_s1(ImageElement, \"epj4qY15NHsef74wNqHIp5fdZmg=\");\n_c1 = ImageElement;\nfunction normalizeSrc(src) {\n    return src[0] === \"/\" ? src.slice(1) : src;\n}\nfunction imgixLoader(param) {\n    var config = param.config, src = param.src, width = param.width, quality = param.quality;\n    // Demo: https://static.imgix.net/daisy.png?auto=format&fit=max&w=300\n    var url = new URL(\"\".concat(config.path).concat(normalizeSrc(src)));\n    var params = url.searchParams;\n    params.set(\"auto\", params.get(\"auto\") || \"format\");\n    params.set(\"fit\", params.get(\"fit\") || \"max\");\n    params.set(\"w\", params.get(\"w\") || width.toString());\n    if (quality) {\n        params.set(\"q\", quality.toString());\n    }\n    return url.href;\n}\nfunction akamaiLoader(param) {\n    var config = param.config, src = param.src, width = param.width;\n    return \"\".concat(config.path).concat(normalizeSrc(src), \"?imwidth=\").concat(width);\n}\nfunction cloudinaryLoader(param) {\n    var config = param.config, src = param.src, width = param.width, quality = param.quality;\n    // Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg\n    var params = [\n        \"f_auto\",\n        \"c_limit\",\n        \"w_\" + width,\n        \"q_\" + (quality || \"auto\")\n    ];\n    var paramsString = params.join(\",\") + \"/\";\n    return \"\".concat(config.path).concat(paramsString).concat(normalizeSrc(src));\n}\nfunction customLoader(param) {\n    var src = param.src;\n    throw new Error('Image with src \"'.concat(src, '\" is missing \"loader\" prop.') + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n}\nfunction defaultLoader(param) {\n    var config = param.config, src = param.src, width = param.width, quality = param.quality;\n    if (true) {\n        var missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \".concat(missingValues.join(\", \"), \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \").concat(JSON.stringify({\n                src: src,\n                width: width,\n                quality: quality\n            })));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"'.concat(src, '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)'));\n        }\n        if (!src.startsWith(\"/\") && config.domains) {\n            var parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"'.concat(src, '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)'));\n            }\n            if ( true && !config.domains.includes(parsedSrc.hostname)) {\n                throw new Error(\"Invalid src prop (\".concat(src, ') on `next/image`, hostname \"').concat(parsedSrc.hostname, '\" is not configured under images in your `next.config.js`\\n') + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n            }\n        }\n    }\n    if (src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        return src;\n    }\n    return \"\".concat((0, _normalizeTrailingSlash).normalizePathTrailingSlash(config.path), \"?url=\").concat(encodeURIComponent(src), \"&w=\").concat(width, \"&q=\").concat(quality || 75);\n}\nif (typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) {\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Image\");\n$RefreshReg$(_c1, \"ImageElement\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNiQSw4Q0FBNkM7SUFDekNHLEtBQUssRUFBRSxJQUFJO0NBQ2QsRUFBQyxDQUFDO0FBQ0hELGtCQUFlLEdBQUdHLEtBQUssQ0FBQztBQUN4QixJQUFJQyxNQUFNLEdBQUdDLHVCQUF1QixDQUFDQyxtQkFBTyxDQUFDLDRDQUFPLENBQUMsQ0FBQztBQUN0RCxJQUFJQyxLQUFLLEdBQUdDLHNCQUFzQixDQUFDRixtQkFBTyxDQUFDLHVFQUFvQixDQUFDLENBQUM7QUFDakUsSUFBSUcsWUFBWSxHQUFHSCxtQkFBTyxDQUFDLHVGQUE0QixDQUFDO0FBQ3hELElBQUlJLGdCQUFnQixHQUFHSixtQkFBTyxDQUFDLCtFQUFvQixDQUFDO0FBQ3BELElBQUlLLG1CQUFtQixHQUFHTCxtQkFBTyxDQUFDLHVHQUFvQyxDQUFDO0FBQ3ZFLElBQUlNLE1BQU0sR0FBR04sbUJBQU8sQ0FBQyx5RUFBcUIsQ0FBQztBQUMzQyxJQUFJTyx1QkFBdUIsR0FBR1AsbUJBQU8sQ0FBQywrRkFBNEIsQ0FBQztBQUNuRSxTQUFTSCxLQUFLLENBQUNXLE1BQU0sRUFBRTs7SUFDbkIsSUFBTUMsR0FBRyxHQUF1UEQsTUFBTSxDQUFoUUMsR0FBRyxFQUFHQyxLQUFLLEdBQStPRixNQUFNLENBQTFQRSxLQUFLLGlCQUErT0YsTUFBTSxDQUFsUEcsV0FBVyxFQUFYQSxXQUFXLDZCQUFFLEtBQUssNkJBQTBOSCxNQUFNLENBQTdOSSxRQUFRLEVBQVJBLFFBQVEsMEJBQUUsS0FBSyxjQUFHQyxPQUFPLEdBQThMTCxNQUFNLENBQTNNSyxPQUFPLGNBQThMTCxNQUFNLENBQWpNTSxRQUFRLEVBQVJBLFFBQVEsMEJBQUUsSUFBSSw4QkFBNktOLE1BQU0sQ0FBaExPLFlBQVksRUFBWkEsWUFBWSw4QkFBRSxPQUFPLGtCQUFHQyxTQUFTLEdBQXlJUixNQUFNLENBQXhKUSxTQUFTLEVBQUdDLE9BQU8sR0FBK0hULE1BQU0sQ0FBNUlTLE9BQU8sRUFBR0MsS0FBSyxHQUF1SFYsTUFBTSxDQUFsSVUsS0FBSyxFQUFHQyxNQUFNLEdBQThHWCxNQUFNLENBQTFIVyxNQUFNLEVBQUdDLEtBQUssR0FBc0daLE1BQU0sQ0FBakhZLEtBQUssRUFBR0MsU0FBUyxHQUEwRmIsTUFBTSxDQUF6R2EsU0FBUyxFQUFHQyxjQUFjLEdBQXlFZCxNQUFNLENBQTdGYyxjQUFjLEVBQUdDLGlCQUFpQixHQUFxRGYsTUFBTSxDQUE1RWUsaUJBQWlCLEVBQUdDLE9BQU8sR0FBMkNoQixNQUFNLENBQXhEZ0IsT0FBTyxpQkFBMkNoQixNQUFNLENBQTlDaUIsV0FBVyxFQUFYQSxXQUFXLDZCQUFFLE9BQU8saUJBQUdDLFdBQVcsR0FBTWxCLE1BQU0sQ0FBdkJrQixXQUFXLEVBQWNDLEdBQUcsR0FBR0Msd0JBQXdCLENBQUNwQixNQUFNLEVBQUU7UUFDM1MsS0FBSztRQUNMLE9BQU87UUFDUCxhQUFhO1FBQ2IsVUFBVTtRQUNWLFNBQVM7UUFDVCxVQUFVO1FBQ1YsY0FBYztRQUNkLFdBQVc7UUFDWCxTQUFTO1FBQ1QsT0FBTztRQUNQLFFBQVE7UUFDUixPQUFPO1FBQ1AsV0FBVztRQUNYLGdCQUFnQjtRQUNoQixtQkFBbUI7UUFDbkIsU0FBUztRQUNULGFBQWE7UUFDYixhQUFhO0tBQ2hCLENBQUM7SUFDRixJQUFNcUIsYUFBYSxHQUFHLENBQUMsQ0FBQyxFQUFFL0IsTUFBTSxDQUFDLENBQUNnQyxVQUFVLENBQUN6QixtQkFBbUIsQ0FBQzBCLGtCQUFrQixDQUFDO0lBQ3BGLElBQU1DLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRWxDLE1BQU0sQ0FBQyxDQUFDbUMsT0FBTyxDQUFDLFdBQUk7UUFDbkMsSUFBTUMsQ0FBQyxHQUFHQyxTQUFTLElBQUlOLGFBQWEsSUFBSTFCLFlBQVksQ0FBQ2lDLGtCQUFrQjtRQUN2RSxJQUFNQyxRQUFRLEdBQUcsbUJBQ1ZILENBQUMsQ0FBQ0ksV0FBVyxDQUFiSixRQUNILG1CQUFHQSxDQUFDLENBQUNLLFVBQVUsQ0FBWkwsQ0FDTixDQUFDTSxJQUFJLENBQUMsU0FBQ0MsQ0FBQyxFQUFFQyxDQUFDO21CQUFHRCxDQUFDLEdBQUdDLENBQUM7U0FBQSxDQUNuQjtRQUNELElBQU1KLFdBQVcsR0FBR0osQ0FBQyxDQUFDSSxXQUFXLENBQUNFLElBQUksQ0FBQyxTQUFDQyxDQUFDLEVBQUVDLENBQUM7bUJBQUdELENBQUMsR0FBR0MsQ0FBQztTQUFBLENBQ25EO1FBQ0QsT0FBT0MsYUFBYSxDQUFDLEVBQUUsRUFBRVQsQ0FBQyxFQUFFO1lBQ3hCRyxRQUFRLEVBQVJBLFFBQVE7WUFDUkMsV0FBVyxFQUFYQSxXQUFXO1NBQ2QsQ0FBQyxDQUFDO0tBQ04sRUFBRTtRQUNDVCxhQUFhO0tBQ2hCLENBQUM7SUFDRixJQUFJZSxJQUFJLEdBQUdqQixHQUFHO0lBQ2QsSUFBSWtCLE1BQU0sR0FBR25DLEtBQUssR0FBRyxZQUFZLEdBQUcsV0FBVztJQUMvQyxJQUFJLFFBQVEsSUFBSWtDLElBQUksRUFBRTtRQUNsQixxREFBcUQ7UUFDckQsSUFBSUEsSUFBSSxDQUFDQyxNQUFNLEVBQUVBLE1BQU0sR0FBR0QsSUFBSSxDQUFDQyxNQUFNLENBQUM7UUFDdEMsK0NBQStDO1FBQy9DLE9BQU9ELElBQUksQ0FBQ0MsTUFBTSxDQUFDO0tBQ3RCO0lBQ0QsSUFBSUMsTUFBTSxHQUFHQyxrQkFBa0I7SUFDL0IsSUFBSSxRQUFRLElBQUlILElBQUksRUFBRTtRQUNsQixJQUFJQSxJQUFJLENBQUNFLE1BQU0sRUFBRTtZQUNiLElBQU1FLGlCQUFpQixHQUFHSixJQUFJLENBQUNFLE1BQU07WUFDckMsSUFBSUcsSUFBSTtZQUNSQSxJQUFJLEdBQUcsU0FBQ0MsR0FBRyxFQUFHO2dCQUNWLElBQVFsQixDQUFTLEdBQU1rQixHQUFHLENBQWxCbEIsTUFBTSxFQUFjb0IsSUFBSSxHQUFHeEIsd0JBQXdCLENBQUNzQixHQUFHLEVBQUU7b0JBQzdELFFBQVE7aUJBQ1gsQ0FBQztnQkFDRixnREFBZ0Q7Z0JBQ2hELDJDQUEyQztnQkFDM0MsT0FBT0YsaUJBQWlCLENBQUNJLElBQUksQ0FBQyxDQUFDO2FBQ2xDLEVBQUVOLE1BQU0sR0FBR0csSUFBSSxFQUFFQSxJQUFJLENBQUM7U0FDMUI7UUFDRCw4Q0FBOEM7UUFDOUMsT0FBT0wsSUFBSSxDQUFDRSxNQUFNLENBQUM7S0FDdEI7SUFDRCxJQUFJTyxTQUFTLEdBQUcsRUFBRTtJQUNsQixJQUFJQyxjQUFjLENBQUM3QyxHQUFHLENBQUMsRUFBRTtRQUNyQixJQUFNOEMsZUFBZSxHQUFHQyxlQUFlLENBQUMvQyxHQUFHLENBQUMsR0FBR0EsR0FBRyxDQUFDYixPQUFPLEdBQUdhLEdBQUc7UUFDaEUsSUFBSSxDQUFDOEMsZUFBZSxDQUFDOUMsR0FBRyxFQUFFO1lBQ3RCLE1BQU0sSUFBSWdELEtBQUssQ0FBQyw2SUFBNEksQ0FBa0MsT0FBaENDLElBQUksQ0FBQ0MsU0FBUyxDQUFDSixlQUFlLENBQUMsQ0FBRSxDQUFDLENBQUM7U0FDcE07UUFDRDdCLFdBQVcsR0FBR0EsV0FBVyxJQUFJNkIsZUFBZSxDQUFDN0IsV0FBVyxDQUFDO1FBQ3pEMkIsU0FBUyxHQUFHRSxlQUFlLENBQUM5QyxHQUFHLENBQUM7UUFDaEMsSUFBSSxDQUFDb0MsTUFBTSxJQUFJQSxNQUFNLEtBQUssTUFBTSxFQUFFO1lBQzlCMUIsTUFBTSxHQUFHQSxNQUFNLElBQUlvQyxlQUFlLENBQUNwQyxNQUFNLENBQUM7WUFDMUNELEtBQUssR0FBR0EsS0FBSyxJQUFJcUMsZUFBZSxDQUFDckMsS0FBSyxDQUFDO1lBQ3ZDLElBQUksQ0FBQ3FDLGVBQWUsQ0FBQ3BDLE1BQU0sSUFBSSxDQUFDb0MsZUFBZSxDQUFDckMsS0FBSyxFQUFFO2dCQUNuRCxNQUFNLElBQUl1QyxLQUFLLENBQUMsMEpBQXlKLENBQWtDLE9BQWhDQyxJQUFJLENBQUNDLFNBQVMsQ0FBQ0osZUFBZSxDQUFDLENBQUUsQ0FBQyxDQUFDO2FBQ2pOO1NBQ0o7S0FDSjtJQUNEOUMsR0FBRyxHQUFHLE9BQU9BLEdBQUcsS0FBSyxRQUFRLEdBQUdBLEdBQUcsR0FBRzRDLFNBQVMsQ0FBQztJQUNoRCxJQUFNTyxRQUFRLEdBQUdDLE1BQU0sQ0FBQzNDLEtBQUssQ0FBQztJQUM5QixJQUFNNEMsU0FBUyxHQUFHRCxNQUFNLENBQUMxQyxNQUFNLENBQUM7SUFDaEMsSUFBTTRDLFVBQVUsR0FBR0YsTUFBTSxDQUFDNUMsT0FBTyxDQUFDO0lBQ2xDLElBQUkrQyxNQUFNLEdBQUcsQ0FBQ3BELFFBQVEsSUFBSSxDQUFDQyxPQUFPLEtBQUssTUFBTSxJQUFJLE9BQU9BLE9BQU8sS0FBSyxXQUFXLENBQUM7SUFDaEYsSUFBSUosR0FBRyxDQUFDd0QsVUFBVSxDQUFDLE9BQU8sQ0FBQyxJQUFJeEQsR0FBRyxDQUFDd0QsVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ3BELDZFQUE2RTtRQUM3RXRELFdBQVcsR0FBRyxJQUFJLENBQUM7UUFDbkJxRCxNQUFNLEdBQUcsS0FBSyxDQUFDO0tBQ2xCO0lBQ0QsSUFBSSxLQUE2QixJQUFJRSxlQUFlLENBQUNDLEdBQUcsQ0FBQzFELEdBQUcsQ0FBQyxFQUFFO1FBQzNEdUQsTUFBTSxHQUFHLEtBQUssQ0FBQztLQUNsQjtJQUNELElBQXdDLElBQTJCLGtCQUEzQixDQUFDLENBQUMsRUFBRWxFLE1BQU0sQ0FBQyxDQUFDc0UsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUE1REMsWUFBWSxHQUFxQixJQUEyQixHQUFoRCxFQUFFQyxlQUFlLEdBQUksSUFBMkIsR0FBL0I7SUFDcEMsSUFBMkQsSUFJekQsa0JBSnlELENBQUMsQ0FBQyxFQUFFbEUsZ0JBQWdCLENBQUMsQ0FBQ21FLGVBQWUsQ0FBQztRQUM3RkMsT0FBTyxFQUFFMUQsUUFBUTtRQUNqQjJELFVBQVUsRUFBRTFELFlBQVk7UUFDeEIyRCxRQUFRLEVBQUUsQ0FBQ1YsTUFBTTtLQUNwQixDQUFDLE1BSktXLGVBQWUsR0FBcUMsSUFJekQsR0FKb0IsRUFBRUMsYUFBYSxHQUFzQixJQUl6RCxHQUptQyxFQUFFQyxnQkFBZ0IsR0FBSSxJQUl6RCxHQUpxRDtJQUt2RCxJQUFNQyxTQUFTLEdBQUcsQ0FBQ2QsTUFBTSxJQUFJWSxhQUFhO0lBQzFDLElBQU1HLFlBQVksR0FBRztRQUNqQkMsU0FBUyxFQUFFLFlBQVk7UUFDdkJDLE9BQU8sRUFBRSxPQUFPO1FBQ2hCQyxRQUFRLEVBQUUsUUFBUTtRQUNsQmhFLEtBQUssRUFBRSxTQUFTO1FBQ2hCQyxNQUFNLEVBQUUsU0FBUztRQUNqQmdFLFVBQVUsRUFBRSxNQUFNO1FBQ2xCQyxPQUFPLEVBQUUsQ0FBQztRQUNWQyxNQUFNLEVBQUUsQ0FBQztRQUNUQyxNQUFNLEVBQUUsQ0FBQztRQUNUQyxPQUFPLEVBQUUsQ0FBQztLQUNiO0lBQ0QsSUFBTUMsVUFBVSxHQUFHO1FBQ2ZSLFNBQVMsRUFBRSxZQUFZO1FBQ3ZCQyxPQUFPLEVBQUUsT0FBTztRQUNoQi9ELEtBQUssRUFBRSxTQUFTO1FBQ2hCQyxNQUFNLEVBQUUsU0FBUztRQUNqQmdFLFVBQVUsRUFBRSxNQUFNO1FBQ2xCQyxPQUFPLEVBQUUsQ0FBQztRQUNWQyxNQUFNLEVBQUUsQ0FBQztRQUNUQyxNQUFNLEVBQUUsQ0FBQztRQUNUQyxPQUFPLEVBQUUsQ0FBQztLQUNiO0lBQ0QsSUFBSUUsUUFBUSxHQUFHLEtBQUs7SUFDcEIsSUFBSUMsV0FBVztJQUNmLElBQU1DLFdBQVcsR0FBRztRQUNoQkMsUUFBUSxFQUFFLFVBQVU7UUFDcEJDLEdBQUcsRUFBRSxDQUFDO1FBQ05DLElBQUksRUFBRSxDQUFDO1FBQ1BDLE1BQU0sRUFBRSxDQUFDO1FBQ1RDLEtBQUssRUFBRSxDQUFDO1FBQ1JoQixTQUFTLEVBQUUsWUFBWTtRQUN2Qk8sT0FBTyxFQUFFLENBQUM7UUFDVkYsTUFBTSxFQUFFLE1BQU07UUFDZEMsTUFBTSxFQUFFLE1BQU07UUFDZEwsT0FBTyxFQUFFLE9BQU87UUFDaEIvRCxLQUFLLEVBQUUsQ0FBQztRQUNSQyxNQUFNLEVBQUUsQ0FBQztRQUNUOEUsUUFBUSxFQUFFLE1BQU07UUFDaEJDLFFBQVEsRUFBRSxNQUFNO1FBQ2hCQyxTQUFTLEVBQUUsTUFBTTtRQUNqQkMsU0FBUyxFQUFFLE1BQU07UUFDakIvRSxTQUFTLEVBQVRBLFNBQVM7UUFDVEMsY0FBYyxFQUFkQSxjQUFjO0tBQ2pCO0lBQ0QsSUFBSStFLEtBQXFDLElBQUl4RCxNQUFNLEtBQUssS0FBSyxJQUFJekIsS0FBSyxFQUFFLEVBQUU7SUFDMUUsSUFBSWlGLElBQXFDLEVBQUU7UUFDdkMsSUFBSSxDQUFDNUYsR0FBRyxFQUFFO1lBQ04sTUFBTSxJQUFJZ0QsS0FBSyxDQUFDLHVIQUF3SCxDQUlySSxPQUp1SUMsSUFBSSxDQUFDQyxTQUFTLENBQUM7Z0JBQ3JKekMsS0FBSyxFQUFMQSxLQUFLO2dCQUNMQyxNQUFNLEVBQU5BLE1BQU07Z0JBQ05GLE9BQU8sRUFBUEEsT0FBTzthQUNWLENBQUMsQ0FBRSxDQUFDLENBQUM7U0FDVDtRQUNELElBQUksQ0FBQ3FGLG1CQUFtQixDQUFDQyxRQUFRLENBQUMxRCxNQUFNLENBQUMsRUFBRTtZQUN2QyxNQUFNLElBQUlZLEtBQUssQ0FBQyxrQkFBaUIsQ0FBbURaLE1BQU0sQ0FBdkRwQyxHQUFHLEVBQUMsNkNBQTJDLENBQVMsQ0FBcUI2RixNQUF5QyxDQUFyRXpELE1BQU0sRUFBQyxxQkFBbUIsQ0FBNEMsT0FBQyxDQUEzQ3lELG1CQUFtQixDQUFDRSxHQUFHLENBQUNDLE1BQU0sQ0FBQyxDQUFDQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQztTQUNqSztRQUNELElBQUk3RCxNQUFNLEtBQUssS0FBSyxJQUFJLENBQUM4RCxxQkFBcUIsRUFBRTtZQUM1QyxNQUFNLElBQUlsRCxLQUFLLENBQUUsOExBQThMLENBQUUsQ0FBQztTQUNyTjtRQUNELElBQUksT0FBT0csUUFBUSxLQUFLLFdBQVcsSUFBSWdELEtBQUssQ0FBQ2hELFFBQVEsQ0FBQyxJQUFJLE9BQU9FLFNBQVMsS0FBSyxXQUFXLElBQUk4QyxLQUFLLENBQUM5QyxTQUFTLENBQUMsRUFBRTtZQUM1RyxNQUFNLElBQUlMLEtBQUssQ0FBQyxrQkFBaUIsQ0FBTSxNQUEyRSxDQUEvRWhELEdBQUcsRUFBQyw2RUFBMkUsQ0FBQyxDQUFDLENBQUM7U0FDeEg7UUFDRCxJQUFJb0MsTUFBTSxLQUFLLE1BQU0sSUFBSSxDQUFDM0IsS0FBSyxJQUFJQyxNQUFNLENBQUMsRUFBRTtZQUN4QyxDQUFDLENBQUMsRUFBRWIsTUFBTSxDQUFDLENBQUN1RyxRQUFRLENBQUMsa0JBQWlCLENBQU0sTUFBeUYsQ0FBN0ZwRyxHQUFHLEVBQUMsNkZBQXlGLENBQUMsQ0FBQyxDQUFDO1NBQzNJO1FBQ0QsSUFBSSxDQUFDcUcsb0JBQW9CLENBQUNQLFFBQVEsQ0FBQzFGLE9BQU8sQ0FBQyxFQUFFO1lBQ3pDLE1BQU0sSUFBSTRDLEtBQUssQ0FBQyxrQkFBaUIsQ0FBb0Q1QyxNQUFPLENBQXpESixHQUFHLEVBQUMsOENBQTRDLENBQVUsQ0FBcUJxRyxNQUEwQyxDQUF2RWpHLE9BQU8sRUFBQyxxQkFBbUIsQ0FBNkMsT0FBQyxDQUE1Q2lHLG9CQUFvQixDQUFDTixHQUFHLENBQUNDLE1BQU0sQ0FBQyxDQUFDQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQztTQUNwSztRQUNELElBQUk5RixRQUFRLElBQUlDLE9BQU8sS0FBSyxNQUFNLEVBQUU7WUFDaEMsTUFBTSxJQUFJNEMsS0FBSyxDQUFDLGtCQUFpQixDQUFNLE1BQStFLENBQW5GaEQsR0FBRyxFQUFDLG1GQUErRSxDQUFDLENBQUMsQ0FBQztTQUM1SDtRQUNELElBQUlvQyxNQUFNLEtBQUssS0FBSyxJQUFJLENBQUN4QixTQUFTLElBQUlDLGNBQWMsQ0FBQyxFQUFFO1lBQ25ELE1BQU0sSUFBSW1DLEtBQUssQ0FBQyxrQkFBaUIsQ0FBTSxNQUFpSixDQUFySmhELEdBQUcsRUFBQyxzSkFBaUosQ0FBQyxDQUFDLENBQUM7U0FDOUw7UUFDRCxJQUFJQyxLQUFLLElBQUltQyxNQUFNLEtBQUssTUFBTSxJQUFJQSxNQUFNLEtBQUssWUFBWSxJQUFJQSxNQUFNLEtBQUssS0FBSyxFQUFFO1lBQzNFLENBQUMsQ0FBQyxFQUFFdkMsTUFBTSxDQUFDLENBQUN1RyxRQUFRLENBQUMsa0JBQWlCLENBQU0sTUFBNkgsQ0FBaklwRyxHQUFHLEVBQUMscUlBQTZILENBQUMsQ0FBQyxDQUFDO1NBQy9LO1FBQ0QsSUFBSWdCLFdBQVcsS0FBSyxNQUFNLEVBQUU7WUFDeEIsSUFBSW9CLE1BQU0sS0FBSyxNQUFNLElBQUksQ0FBQ2UsUUFBUSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUNFLFNBQVMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLEVBQUU7Z0JBQ2hFLENBQUMsQ0FBQyxFQUFFeEQsTUFBTSxDQUFDLENBQUN1RyxRQUFRLENBQUMsa0JBQWlCLENBQU0sTUFBb0csQ0FBeEdwRyxHQUFHLEVBQUMsd0dBQW9HLENBQUMsQ0FBQyxDQUFDO2FBQ3RKO1lBQ0QsSUFBSSxDQUFDaUIsV0FBVyxFQUFFO2dCQUNkLElBQU1xRixjQUFjLEdBQUc7b0JBQ25CLE1BQU07b0JBQ04sS0FBSztvQkFDTCxNQUFNO29CQUNOLE1BQU07aUJBQ1QsQ0FBQyxpQ0FBaUM7Z0JBQ2xDO2dCQUNELE1BQU0sSUFBSXRELEtBQUssQ0FBQyxrQkFBaUIsQ0FHa0RzRCxNQUF3QixDQUh4RXRHLEdBQUcsRUFBQyxnVUFHMEMsQ0FBMkIsT0FFN0MsQ0FGb0JzRyxjQUFjLENBQUNMLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBQyxnS0FFN0MsQ0FBQyxDQUFDLENBQUM7YUFDckU7U0FDSjtRQUNELElBQUksS0FBSyxJQUFJOUQsSUFBSSxFQUFFO1lBQ2YsQ0FBQyxDQUFDLEVBQUV0QyxNQUFNLENBQUMsQ0FBQ3VHLFFBQVEsQ0FBQyxrQkFBaUIsQ0FBTSxNQUErRixDQUFuR3BHLEdBQUcsRUFBQyxpR0FBK0YsQ0FBQyxDQUFDLENBQUM7U0FDako7UUFDRCxJQUFJLENBQUNFLFdBQVcsSUFBSW1DLE1BQU0sS0FBS0Msa0JBQWtCLEVBQUU7WUFDL0MsSUFBTWlFLE1BQU0sR0FBR2xFLE1BQU0sQ0FBQztnQkFDbEJkLE1BQU0sRUFBTkEsTUFBTTtnQkFDTnZCLEdBQUcsRUFBSEEsR0FBRztnQkFDSFMsS0FBSyxFQUFFMEMsUUFBUSxJQUFJLEdBQUc7Z0JBQ3RCM0MsT0FBTyxFQUFFOEMsVUFBVSxJQUFJLEVBQUU7YUFDNUIsQ0FBQztZQUNGLElBQUlrRCxHQUFHO1lBQ1AsSUFBSTtnQkFDQUEsR0FBRyxHQUFHLElBQUlDLEdBQUcsQ0FBQ0YsTUFBTSxDQUFDLENBQUM7YUFDekIsQ0FBQyxPQUFPRyxHQUFHLEVBQUUsRUFBRTtZQUNoQixJQUFJSCxNQUFNLEtBQUt2RyxHQUFHLElBQUl3RyxHQUFHLElBQUlBLEdBQUcsQ0FBQ0csUUFBUSxLQUFLM0csR0FBRyxJQUFJLENBQUN3RyxHQUFHLENBQUNJLE1BQU0sRUFBRTtnQkFDOUQsQ0FBQyxDQUFDLEVBQUUvRyxNQUFNLENBQUMsQ0FBQ3VHLFFBQVEsQ0FBQyxrQkFBaUIsQ0FBTSxNQUF1SCxDQUEzSHBHLEdBQUcsRUFBQyx5SEFBdUgsQ0FBQyxHQUFJLCtFQUE2RSxDQUFFLENBQUM7YUFDM1A7U0FDSjtRQUNELElBQUlXLEtBQUssSUFBSXlCLE1BQU0sS0FBSyxLQUFLLEVBQUU7WUFDM0IsSUFBSXlFLGlCQUFpQixHQUFHOUgsTUFBTSxDQUFDK0gsSUFBSSxDQUFDbkcsS0FBSyxDQUFDLENBQUNvRyxNQUFNLENBQUMsU0FBQ0MsR0FBRzt1QkFBR0EsR0FBRyxJQUFJOUIsV0FBVzthQUFBLENBQzFFO1lBQ0QsSUFBSTJCLGlCQUFpQixDQUFDSSxNQUFNLEVBQUU7Z0JBQzFCLENBQUMsQ0FBQyxFQUFFcEgsTUFBTSxDQUFDLENBQUN1RyxRQUFRLENBQUMsaUJBQWdCLENBQW9HUyxNQUE0QixDQUE5SDdHLEdBQUcsRUFBQyw4RkFBNEYsQ0FBK0IsUUFBN0I2RyxpQkFBaUIsQ0FBQ1osSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFFLENBQUMsQ0FBQzthQUM1SztTQUNKO1FBQ0QsSUFBSSxLQUE2QixJQUFJLENBQUNpQixZQUFZLElBQUlDLE1BQU0sQ0FBQ0MsbUJBQW1CLEVBQUU7WUFDOUVGLFlBQVksR0FBRyxJQUFJRSxtQkFBbUIsQ0FBQyxTQUFDQyxTQUFTLEVBQUc7b0JBQzNDLHlCQUFXLFNBQVgsaUJBQVcsVUFBWCxjQUFXOztvQkFBaEIsUUFBSyxTQUFXLEdBQUlBLFNBQVMsQ0FBQ0MsVUFBVSxFQUFFLHFCQUFyQyxLQUFXLElBQVgseUJBQVcsSUFBWCxLQUFXLEdBQVgsU0FBVyxnQkFBWCx5QkFBVyxRQUEyQjt3QkFBdEMsSUFBTUMsS0FBSyxHQUFYLEtBQVc7d0JBQ1osSUFBSUMsSUFBSTt3QkFDUiwwRUFBMEU7d0JBQzFFLElBQU1DLE1BQU0sR0FBRyxDQUFDRixLQUFLLEtBQUssSUFBSSxJQUFJQSxLQUFLLEtBQUssS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHRCxLQUFLLENBQUNHLE9BQU8sQ0FBQyxLQUFLLElBQUksSUFBSUYsSUFBSSxLQUFLLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHQSxJQUFJLENBQUN4SCxHQUFHLENBQUMsSUFBSSxFQUFFO3dCQUMzSSxJQUFNMkgsUUFBUSxHQUFHQyxPQUFPLENBQUNDLEdBQUcsQ0FBQ0osTUFBTSxDQUFDO3dCQUNwQyxJQUFJRSxRQUFRLElBQUksQ0FBQ0EsUUFBUSxDQUFDeEgsUUFBUSxJQUFJd0gsUUFBUSxDQUFDM0csV0FBVyxLQUFLLE1BQU0sSUFBSSxDQUFDMkcsUUFBUSxDQUFDM0gsR0FBRyxDQUFDd0QsVUFBVSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUNtRSxRQUFRLENBQUMzSCxHQUFHLENBQUN3RCxVQUFVLENBQUMsT0FBTyxDQUFDLEVBQUU7NEJBQzdJLGlEQUFpRDs0QkFDakQsQ0FBQyxDQUFDLEVBQUUzRCxNQUFNLENBQUMsQ0FBQ3VHLFFBQVEsQ0FBQyxrQkFBaUIsQ0FBZSxNQUF5SCxDQUF0SXVCLFFBQVEsQ0FBQzNILEdBQUcsRUFBQywySEFBeUgsQ0FBQyxHQUFJLHdFQUFzRSxDQUFFLENBQUM7eUJBQy9QO3FCQUNKOztvQkFUSSxpQkFBVztvQkFBWCxjQUFXOzs7NkJBQVgseUJBQVcsSUFBWCxTQUFXOzRCQUFYLFNBQVc7Ozs0QkFBWCxpQkFBVztrQ0FBWCxjQUFXOzs7O2FBVW5CLENBQUMsQ0FBQztZQUNILElBQUk7Z0JBQ0FrSCxZQUFZLENBQUNZLE9BQU8sQ0FBQztvQkFDakJDLElBQUksRUFBRSwwQkFBMEI7b0JBQ2hDQyxRQUFRLEVBQUUsSUFBSTtpQkFDakIsQ0FBQyxDQUFDO2FBQ04sQ0FBQyxPQUFPdEIsR0FBRyxFQUFFO2dCQUNWLG9DQUFvQztnQkFDcEN1QixPQUFPLENBQUNDLEtBQUssQ0FBQ3hCLEdBQUcsQ0FBQyxDQUFDO2FBQ3RCO1NBQ0o7S0FDSjtJQUNELElBQU15QixRQUFRLEdBQUdwSixNQUFNLENBQUNxSixNQUFNLENBQUMsRUFBRSxFQUFFekgsS0FBSyxFQUFFeUIsTUFBTSxLQUFLLEtBQUssR0FBRztRQUN6RGlHLFdBQVcsRUFBRSxFQUFDLENBQWdCaEYsTUFBUyxDQUF2QkYsUUFBUSxFQUFDLEtBQUcsQ0FBWSxRQUFWRSxTQUFTLENBQUU7S0FDNUMsR0FBRzZCLFdBQVcsQ0FBQztJQUNoQixJQUFNb0QsU0FBUyxHQUFHdEgsV0FBVyxLQUFLLE1BQU0sSUFBSSxDQUFDNEMsWUFBWSxHQUFHO1FBQ3hEbUQsTUFBTSxFQUFFLFlBQVk7UUFDcEJ3QixjQUFjLEVBQUUzSCxTQUFTLElBQUksT0FBTztRQUNwQzRILGVBQWUsRUFBRSxPQUFNLENBQWMsTUFBRSxDQUFkdkgsV0FBVyxFQUFDLElBQUUsQ0FBQztRQUN4Q3dILGtCQUFrQixFQUFFNUgsY0FBYyxJQUFJLE9BQU87S0FDaEQsR0FBRyxFQUFFO0lBQ04sSUFBSXVCLE1BQU0sS0FBSyxNQUFNLEVBQUU7UUFDbkIsc0NBQXNDO1FBQ3RDa0MsWUFBWSxDQUFDRSxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQy9CRixZQUFZLENBQUNhLFFBQVEsR0FBRyxVQUFVLENBQUM7UUFDbkNiLFlBQVksQ0FBQ2MsR0FBRyxHQUFHLENBQUMsQ0FBQztRQUNyQmQsWUFBWSxDQUFDZSxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ3RCZixZQUFZLENBQUNnQixNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQ3hCaEIsWUFBWSxDQUFDaUIsS0FBSyxHQUFHLENBQUMsQ0FBQztLQUMxQixNQUFNLElBQUksT0FBT3BDLFFBQVEsS0FBSyxXQUFXLElBQUksT0FBT0UsU0FBUyxLQUFLLFdBQVcsRUFBRTtRQUM1RSxpREFBaUQ7UUFDakQsSUFBTXFGLFFBQVEsR0FBR3JGLFNBQVMsR0FBR0YsUUFBUTtRQUNyQyxJQUFNd0YsVUFBVSxHQUFHeEMsS0FBSyxDQUFDdUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxHQUFHLEVBQUMsQ0FBaUIsTUFBQyxDQUFoQkEsUUFBUSxHQUFHLEdBQUcsRUFBQyxHQUFDLENBQUM7UUFDbEUsSUFBSXRHLE1BQU0sS0FBSyxZQUFZLEVBQUU7WUFDekIscUVBQXFFO1lBQ3JFa0MsWUFBWSxDQUFDRSxPQUFPLEdBQUcsT0FBTyxDQUFDO1lBQy9CRixZQUFZLENBQUNhLFFBQVEsR0FBRyxVQUFVLENBQUM7WUFDbkNILFFBQVEsR0FBRyxJQUFJLENBQUM7WUFDaEJELFVBQVUsQ0FBQzRELFVBQVUsR0FBR0EsVUFBVSxDQUFDO1NBQ3RDLE1BQU0sSUFBSXZHLE1BQU0sS0FBSyxXQUFXLEVBQUU7WUFDL0Isb0VBQW9FO1lBQ3BFa0MsWUFBWSxDQUFDRSxPQUFPLEdBQUcsY0FBYyxDQUFDO1lBQ3RDRixZQUFZLENBQUNhLFFBQVEsR0FBRyxVQUFVLENBQUM7WUFDbkNiLFlBQVksQ0FBQ21CLFFBQVEsR0FBRyxNQUFNLENBQUM7WUFDL0JULFFBQVEsR0FBRyxJQUFJLENBQUM7WUFDaEJELFVBQVUsQ0FBQ1UsUUFBUSxHQUFHLE1BQU0sQ0FBQztZQUM3QlIsV0FBVyxHQUFHLG9HQUFtRyxDQUE2QjVCLE1BQVMsQ0FBcENGLFFBQVEsRUFBQyxrQkFBZ0IsQ0FBWSxPQUFPLENBQWpCRSxTQUFTLEVBQUMsU0FBTyxDQUFDLENBQUM7U0FDcEssTUFBTSxJQUFJakIsTUFBTSxLQUFLLE9BQU8sRUFBRTtZQUMzQixnRUFBZ0U7WUFDaEVrQyxZQUFZLENBQUNFLE9BQU8sR0FBRyxjQUFjLENBQUM7WUFDdENGLFlBQVksQ0FBQ2EsUUFBUSxHQUFHLFVBQVUsQ0FBQztZQUNuQ2IsWUFBWSxDQUFDN0QsS0FBSyxHQUFHMEMsUUFBUSxDQUFDO1lBQzlCbUIsWUFBWSxDQUFDNUQsTUFBTSxHQUFHMkMsU0FBUyxDQUFDO1NBQ25DO0tBQ0osTUFBTTtRQUNILHdCQUF3QjtRQUN4QixJQUFJdUMsSUFBcUMsRUFBRTtZQUN2QyxNQUFNLElBQUk1QyxLQUFLLENBQUMsa0JBQWlCLENBQU0sTUFBdUUsQ0FBM0VoRCxHQUFHLEVBQUMsMkVBQXVFLENBQUMsQ0FBQyxDQUFDO1NBQ3BIO0tBQ0o7SUFDRCxJQUFJNEksYUFBYSxHQUFHO1FBQ2hCNUksR0FBRyxFQUFFNkksWUFBWTtRQUNqQkMsTUFBTSxFQUFFQyxTQUFTO1FBQ2pCOUksS0FBSyxFQUFFOEksU0FBUztLQUNuQjtJQUNELElBQUkxRSxTQUFTLEVBQUU7UUFDWHVFLGFBQWEsR0FBR0ksZ0JBQWdCLENBQUM7WUFDN0J6SCxNQUFNLEVBQU5BLE1BQU07WUFDTnZCLEdBQUcsRUFBSEEsR0FBRztZQUNIRSxXQUFXLEVBQVhBLFdBQVc7WUFDWGtDLE1BQU0sRUFBTkEsTUFBTTtZQUNOM0IsS0FBSyxFQUFFMEMsUUFBUTtZQUNmM0MsT0FBTyxFQUFFOEMsVUFBVTtZQUNuQnJELEtBQUssRUFBTEEsS0FBSztZQUNMb0MsTUFBTSxFQUFOQSxNQUFNO1NBQ1QsQ0FBQyxDQUFDO0tBQ047SUFDRCxJQUFJNEcsU0FBUyxHQUFHakosR0FBRztJQUNuQixJQUFJNEYsSUFBcUMsRUFBRTtRQUN2QyxJQUFJLElBQTZCLEVBQUU7WUFDL0IsSUFBSXNELE9BQU87WUFDWCxJQUFJO2dCQUNBQSxPQUFPLEdBQUcsSUFBSXpDLEdBQUcsQ0FBQ21DLGFBQWEsQ0FBQzVJLEdBQUcsQ0FBQyxDQUFDO2FBQ3hDLENBQUMsT0FBT21KLENBQUMsRUFBRTtnQkFDUkQsT0FBTyxHQUFHLElBQUl6QyxHQUFHLENBQUNtQyxhQUFhLENBQUM1SSxHQUFHLEVBQUVtSCxNQUFNLENBQUNpQyxRQUFRLENBQUNDLElBQUksQ0FBQyxDQUFDO2FBQzlEO1lBQ0R6QixPQUFPLENBQUMwQixHQUFHLENBQUNKLE9BQU8sQ0FBQ0csSUFBSSxFQUFFO2dCQUN0QnJKLEdBQUcsRUFBSEEsR0FBRztnQkFDSEcsUUFBUSxFQUFSQSxRQUFRO2dCQUNSYSxXQUFXLEVBQVhBLFdBQVc7YUFDZCxDQUFDLENBQUM7U0FDTjtLQUNKO0lBQ0QsSUFBSXVJLG1CQUFtQixHQUFHLGFBQWE7SUFDdkMsSUFBSUMsa0JBQWtCLEdBQUcsWUFBWTtJQUNyQyxJQUFJNUQsSUFBNkIsRUFBRTtRQUMvQjJELG1CQUFtQixHQUFHLGFBQWEsQ0FBQztRQUNwQ0Msa0JBQWtCLEdBQUcsWUFBWSxDQUFDO0tBQ3JDO1FBQ2lCLElBSWpCO0lBSkQsSUFBTUcsU0FBUyxJQUFHLElBSWpCLE9BSEcsbUZBQW1GO0lBQ25GLGdCQUZjLElBSWpCLEVBRklKLG1CQUFtQixFQUFHWCxhQUFhLENBQUNFLE1BQU0sR0FDM0MsZ0JBSGMsSUFJakIsRUFESVUsa0JBQWtCLEVBQUdaLGFBQWEsQ0FBQzNJLEtBQUssR0FIM0IsSUFJakI7SUFDRCxJQUFNMkosZUFBZSxHQUFHLE1BQTZCLEdBQUd2SyxDQUF3QixHQUFHQSxNQUFNLENBQUNGLE9BQU8sQ0FBQ3lLLGVBQWU7SUFDakgsSUFBTUUsb0JBQW9CLEdBQUcsQ0FBQyxDQUFDLEVBQUV6SyxNQUFNLENBQUMsQ0FBQzBLLE1BQU0sQ0FBQ2pKLGlCQUFpQixDQUFDO0lBQ2xFLElBQU1rSixnQkFBZ0IsR0FBRyxDQUFDLENBQUMsRUFBRTNLLE1BQU0sQ0FBQyxDQUFDMEssTUFBTSxDQUFDL0osR0FBRyxDQUFDO0lBQ2hELENBQUMsQ0FBQyxFQUFFWCxNQUFNLENBQUMsQ0FBQ3dLLFNBQVMsQ0FBQyxXQUFJO1FBQ3RCQyxvQkFBb0IsQ0FBQ0csT0FBTyxHQUFHbkosaUJBQWlCLENBQUM7S0FDcEQsRUFBRTtRQUNDQSxpQkFBaUI7S0FDcEIsQ0FBQyxDQUFDO0lBQ0g4SSxlQUFlLENBQUMsV0FBSTtRQUNoQixJQUFJSSxnQkFBZ0IsQ0FBQ0MsT0FBTyxLQUFLakssR0FBRyxFQUFFO1lBQ2xDb0UsZ0JBQWdCLEVBQUUsQ0FBQztZQUNuQjRGLGdCQUFnQixDQUFDQyxPQUFPLEdBQUdqSyxHQUFHLENBQUM7U0FDbEM7S0FDSixFQUFFO1FBQ0NvRSxnQkFBZ0I7UUFDaEJwRSxHQUFHO0tBQ04sQ0FBQyxDQUFDO0lBQ0gsSUFBTWtLLGNBQWMsR0FBR2hJLGFBQWEsQ0FBQztRQUNqQ3FCLE1BQU0sRUFBTkEsTUFBTTtRQUNOcUYsYUFBYSxFQUFiQSxhQUFhO1FBQ2J2RixTQUFTLEVBQVRBLFNBQVM7UUFDVEYsUUFBUSxFQUFSQSxRQUFRO1FBQ1JHLFVBQVUsRUFBVkEsVUFBVTtRQUNWbEIsTUFBTSxFQUFOQSxNQUFNO1FBQ043QixTQUFTLEVBQVRBLFNBQVM7UUFDVDRILFFBQVEsRUFBUkEsUUFBUTtRQUNSRyxTQUFTLEVBQVRBLFNBQVM7UUFDVGxJLE9BQU8sRUFBUEEsT0FBTztRQUNQbUIsTUFBTSxFQUFOQSxNQUFNO1FBQ05yQixXQUFXLEVBQVhBLFdBQVc7UUFDWGMsV0FBVyxFQUFYQSxXQUFXO1FBQ1hxQixNQUFNLEVBQU5BLE1BQU07UUFDTjRHLFNBQVMsRUFBVEEsU0FBUztRQUNUYSxvQkFBb0IsRUFBcEJBLG9CQUFvQjtRQUNwQmpHLGVBQWUsRUFBZkEsZUFBZTtRQUNmSyxlQUFlLEVBQWZBLGVBQWU7UUFDZkcsU0FBUyxFQUFUQSxTQUFTO0tBQ1osRUFBRWxDLElBQUksQ0FBQztJQUNSLE9BQU8sYUFBYSxDQUFDOUMsTUFBTSxDQUFDRixPQUFPLENBQUNnTCxhQUFhLENBQUM5SyxNQUFNLENBQUNGLE9BQU8sQ0FBQ2lMLFFBQVEsRUFBRSxJQUFJLEVBQUVoSSxNQUFNLEtBQUssS0FBSyxHQUFHLGFBQWEsQ0FBQy9DLE1BQU0sQ0FBQ0YsT0FBTyxDQUFDZ0wsYUFBYSxDQUFDRSxZQUFZLEVBQUV0TCxNQUFNLENBQUNxSixNQUFNLENBQUMsRUFBRSxFQUFFOEIsY0FBYyxDQUFDLENBQUMsR0FBRyxhQUFhLENBQUM3SyxNQUFNLENBQUNGLE9BQU8sQ0FBQ2dMLGFBQWEsQ0FBQyxNQUFNLEVBQUU7UUFDalB4SixLQUFLLEVBQUUyRCxZQUFZO0tBQ3RCLEVBQUVVLFFBQVEsR0FBRyxhQUFhLENBQUMzRixNQUFNLENBQUNGLE9BQU8sQ0FBQ2dMLGFBQWEsQ0FBQyxNQUFNLEVBQUU7UUFDN0R4SixLQUFLLEVBQUVvRSxVQUFVO0tBQ3BCLEVBQUVFLFdBQVcsR0FBRyxhQUFhLENBQUM1RixNQUFNLENBQUNGLE9BQU8sQ0FBQ2dMLGFBQWEsQ0FBQyxLQUFLLEVBQUU7UUFDL0R4SixLQUFLLEVBQUU7WUFDSDZELE9BQU8sRUFBRSxPQUFPO1lBQ2hCaUIsUUFBUSxFQUFFLE1BQU07WUFDaEJoRixLQUFLLEVBQUUsU0FBUztZQUNoQkMsTUFBTSxFQUFFLFNBQVM7WUFDakJnRSxVQUFVLEVBQUUsTUFBTTtZQUNsQkMsT0FBTyxFQUFFLENBQUM7WUFDVkMsTUFBTSxFQUFFLENBQUM7WUFDVEMsTUFBTSxFQUFFLENBQUM7WUFDVEMsT0FBTyxFQUFFLENBQUM7U0FDYjtRQUNEd0YsR0FBRyxFQUFFLEVBQUU7UUFDUCxhQUFhLEVBQUUsSUFBSTtRQUNuQnRLLEdBQUcsRUFBRWlGLFdBQVc7S0FDbkIsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLElBQUksRUFBRSxhQUFhLENBQUM1RixNQUFNLENBQUNGLE9BQU8sQ0FBQ2dMLGFBQWEsQ0FBQ0UsWUFBWSxFQUFFdEwsTUFBTSxDQUFDcUosTUFBTSxDQUFDLEVBQUUsRUFBRThCLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRS9KLFFBQVEsR0FDekgscUVBQXFFO0lBQ3JFLDZEQUE2RDtJQUM3RCxFQUFFO0lBQ0YsOEVBQThFO0lBQzlFLGFBQWEsQ0FBQ2QsTUFBTSxDQUFDRixPQUFPLENBQUNnTCxhQUFhLENBQUMzSyxLQUFLLENBQUNMLE9BQU8sRUFBRSxJQUFJLEVBQUUsYUFBYSxDQUFDRSxNQUFNLENBQUNGLE9BQU8sQ0FBQ2dMLGFBQWEsQ0FBQyxNQUFNLEVBQUVwTCxNQUFNLENBQUNxSixNQUFNLENBQUM7UUFDN0hwQixHQUFHLEVBQUUsU0FBUyxHQUFHNEIsYUFBYSxDQUFDNUksR0FBRyxHQUFHNEksYUFBYSxDQUFDRSxNQUFNLEdBQUdGLGFBQWEsQ0FBQzNJLEtBQUs7UUFDL0VzSyxHQUFHLEVBQUUsU0FBUztRQUNkQyxFQUFFLEVBQUUsT0FBTztRQUNYbkIsSUFBSSxFQUFFVCxhQUFhLENBQUNFLE1BQU0sR0FBR0MsU0FBUyxHQUFHSCxhQUFhLENBQUM1SSxHQUFHO0tBQzdELEVBQUUySixTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUU7Q0FDNUI7R0F0WlF2SyxLQUFLO0FBQUxBLEtBQUFBLEtBQUs7QUF1WmQsU0FBU3FMLGdCQUFlLENBQUNoSSxHQUFHLEVBQUV1RSxHQUFHLEVBQUU5SCxLQUFLLEVBQUU7SUFDdEMsSUFBSThILEdBQUcsSUFBSXZFLEdBQUcsRUFBRTtRQUNaMUQsTUFBTSxDQUFDQyxjQUFjLENBQUN5RCxHQUFHLEVBQUV1RSxHQUFHLEVBQUU7WUFDNUI5SCxLQUFLLEVBQUVBLEtBQUs7WUFDWndMLFVBQVUsRUFBRSxJQUFJO1lBQ2hCQyxZQUFZLEVBQUUsSUFBSTtZQUNsQkMsUUFBUSxFQUFFLElBQUk7U0FDakIsQ0FBQyxDQUFDO0tBQ04sTUFBTTtRQUNIbkksR0FBRyxDQUFDdUUsR0FBRyxDQUFDLEdBQUc5SCxLQUFLLENBQUM7S0FDcEI7SUFDRCxPQUFPdUQsR0FBRyxDQUFDO0NBQ2Q7QUFDRCxTQUFTaEQsc0JBQXNCLENBQUNnRCxHQUFHLEVBQUU7SUFDakMsT0FBT0EsR0FBRyxJQUFJQSxHQUFHLENBQUNvSSxVQUFVLEdBQUdwSSxHQUFHLEdBQUc7UUFDakN0RCxPQUFPLEVBQUVzRCxHQUFHO0tBQ2YsQ0FBQztDQUNMO0FBQ0QsU0FBU25ELHVCQUF1QixDQUFDbUQsR0FBRyxFQUFFO0lBQ2xDLElBQUlBLEdBQUcsSUFBSUEsR0FBRyxDQUFDb0ksVUFBVSxFQUFFO1FBQ3ZCLE9BQU9wSSxHQUFHLENBQUM7S0FDZCxNQUFNO1FBQ0gsSUFBSXFJLE1BQU0sR0FBRyxFQUFFO1FBQ2YsSUFBSXJJLEdBQUcsSUFBSSxJQUFJLEVBQUU7WUFDYixJQUFJLElBQUl1RSxHQUFHLElBQUl2RSxHQUFHLENBQUM7Z0JBQ2YsSUFBSTFELE1BQU0sQ0FBQ2dNLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUN4SSxHQUFHLEVBQUV1RSxHQUFHLENBQUMsRUFBRTtvQkFDaEQsSUFBSWtFLElBQUksR0FBR25NLE1BQU0sQ0FBQ0MsY0FBYyxJQUFJRCxNQUFNLENBQUNvTSx3QkFBd0IsR0FBR3BNLE1BQU0sQ0FBQ29NLHdCQUF3QixDQUFDMUksR0FBRyxFQUFFdUUsR0FBRyxDQUFDLEdBQUcsRUFBRTtvQkFDcEgsSUFBSWtFLElBQUksQ0FBQ3JELEdBQUcsSUFBSXFELElBQUksQ0FBQzVCLEdBQUcsRUFBRTt3QkFDdEJ2SyxNQUFNLENBQUNDLGNBQWMsQ0FBQzhMLE1BQU0sRUFBRTlELEdBQUcsRUFBRWtFLElBQUksQ0FBQyxDQUFDO3FCQUM1QyxNQUFNO3dCQUNISixNQUFNLENBQUM5RCxHQUFHLENBQUMsR0FBR3ZFLEdBQUcsQ0FBQ3VFLEdBQUcsQ0FBQyxDQUFDO3FCQUMxQjtpQkFDSjthQUNKO1NBQ0o7UUFDRDhELE1BQU0sQ0FBQzNMLE9BQU8sR0FBR3NELEdBQUcsQ0FBQztRQUNyQixPQUFPcUksTUFBTSxDQUFDO0tBQ2pCO0NBQ0o7QUFDRCxTQUFTNUksYUFBYSxDQUFDa0osTUFBTSxFQUFFO29EQUNjO1FBQ3JDLElBQUlDLE1BQU0sR0FBR0MsVUFBUyxDQUFDQyxDQUFDLENBQUMsSUFBSSxJQUFJLEdBQUdELFVBQVMsQ0FBQ0MsQ0FBQyxDQUFDLEdBQUcsRUFBRTtRQUNyRCxJQUFJQyxPQUFPLEdBQUd6TSxNQUFNLENBQUMrSCxJQUFJLENBQUN1RSxNQUFNLENBQUM7UUFDakMsSUFBSSxPQUFPdE0sTUFBTSxDQUFDME0scUJBQXFCLEtBQUssVUFBVSxFQUFFO1lBQ3BERCxPQUFPLEdBQUdBLE9BQU8sQ0FBQ0UsTUFBTSxDQUFDM00sTUFBTSxDQUFDME0scUJBQXFCLENBQUNKLE1BQU0sQ0FBQyxDQUFDdEUsTUFBTSxDQUFDLFNBQVM0RSxHQUFHLEVBQUU7Z0JBQy9FLE9BQU81TSxNQUFNLENBQUNvTSx3QkFBd0IsQ0FBQ0UsTUFBTSxFQUFFTSxHQUFHLENBQUMsQ0FBQ2pCLFVBQVUsQ0FBQzthQUNsRSxDQUFDLENBQUMsQ0FBQztTQUNQO1FBQ0RjLE9BQU8sQ0FBQ0ksT0FBTyxDQUFDLFNBQVM1RSxHQUFHLEVBQUU7WUFDMUJ5RCxnQkFBZSxDQUFDVyxNQUFNLEVBQUVwRSxHQUFHLEVBQUVxRSxNQUFNLENBQUNyRSxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQzdDLENBQUMsQ0FBQztLQUNOO0lBWEQsSUFBSSxJQUFJdUUsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHRCxTQUFTLENBQUNyRSxNQUFNLEVBQUVzRSxDQUFDLEVBQUU7SUFZeEMsT0FBT0gsTUFBTSxDQUFDO0NBQ2pCO0FBQ0QsU0FBU2pLLHdCQUF3QixDQUFDa0ssTUFBTSxFQUFFUSxRQUFRLEVBQUU7SUFDaEQsSUFBSVIsTUFBTSxJQUFJLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQztJQUM5QixJQUFJRCxNQUFNLEdBQUdVLDZCQUE2QixDQUFDVCxNQUFNLEVBQUVRLFFBQVEsQ0FBQztJQUM1RCxJQUFJN0UsR0FBRyxFQUFFdUUsQ0FBQztJQUNWLElBQUl4TSxNQUFNLENBQUMwTSxxQkFBcUIsRUFBRTtRQUM5QixJQUFJTSxnQkFBZ0IsR0FBR2hOLE1BQU0sQ0FBQzBNLHFCQUFxQixDQUFDSixNQUFNLENBQUM7UUFDM0QsSUFBSUUsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHUSxnQkFBZ0IsQ0FBQzlFLE1BQU0sRUFBRXNFLENBQUMsRUFBRSxDQUFDO1lBQ3hDdkUsR0FBRyxHQUFHK0UsZ0JBQWdCLENBQUNSLENBQUMsQ0FBQyxDQUFDO1lBQzFCLElBQUlNLFFBQVEsQ0FBQ0csT0FBTyxDQUFDaEYsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLFNBQVM7WUFDekMsSUFBSSxDQUFDakksTUFBTSxDQUFDZ00sU0FBUyxDQUFDa0Isb0JBQW9CLENBQUNoQixJQUFJLENBQUNJLE1BQU0sRUFBRXJFLEdBQUcsQ0FBQyxFQUFFLFNBQVM7WUFDdkVvRSxNQUFNLENBQUNwRSxHQUFHLENBQUMsR0FBR3FFLE1BQU0sQ0FBQ3JFLEdBQUcsQ0FBQyxDQUFDO1NBQzdCO0tBQ0o7SUFDRCxPQUFPb0UsTUFBTSxDQUFDO0NBQ2pCO0FBQ0QsU0FBU1UsNkJBQTZCLENBQUNULE1BQU0sRUFBRVEsUUFBUSxFQUFFO0lBQ3JELElBQUlSLE1BQU0sSUFBSSxJQUFJLEVBQUUsT0FBTyxFQUFFLENBQUM7SUFDOUIsSUFBSUQsTUFBTSxHQUFHLEVBQUU7SUFDZixJQUFJYyxVQUFVLEdBQUduTixNQUFNLENBQUMrSCxJQUFJLENBQUN1RSxNQUFNLENBQUM7SUFDcEMsSUFBSXJFLEdBQUcsRUFBRXVFLENBQUM7SUFDVixJQUFJQSxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdXLFVBQVUsQ0FBQ2pGLE1BQU0sRUFBRXNFLENBQUMsRUFBRSxDQUFDO1FBQ2xDdkUsR0FBRyxHQUFHa0YsVUFBVSxDQUFDWCxDQUFDLENBQUMsQ0FBQztRQUNwQixJQUFJTSxRQUFRLENBQUNHLE9BQU8sQ0FBQ2hGLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxTQUFTO1FBQ3pDb0UsTUFBTSxDQUFDcEUsR0FBRyxDQUFDLEdBQUdxRSxNQUFNLENBQUNyRSxHQUFHLENBQUMsQ0FBQztLQUM3QjtJQUNELE9BQU9vRSxNQUFNLENBQUM7Q0FDakI7QUFDRCxJQUFJZSxHQUFHO0FBQ1AsSUFBTWpHLHFCQUFxQixHQUFHLENBQUNpRyxHQUFHLEdBQUd2RyxvTEFBNkIsQ0FBQyxLQUFLLElBQUksSUFBSXVHLEdBQUcsS0FBSyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBR0EsR0FBRyxDQUFDakcscUJBQXFCO0FBQ25JLElBQU14RSxTQUFTLEdBQUdrRSxvTEFBNkI7QUFDL0MsSUFBTW5DLGVBQWUsR0FBRyxJQUFJNEksR0FBRyxFQUFFO0FBQ2pDLElBQU16RSxPQUFPLEdBQUcsSUFBSTBFLEdBQUcsRUFBRTtBQUN6QixJQUFJcEYsWUFBWTtBQUNoQixJQUFNMkIsWUFBWSxHQUFHLGdGQUFnRjtBQUNyRyxJQUFJLEtBQTZCLEVBQUUsRUFFbEM7QUFDRCxJQUFNeEMsb0JBQW9CLEdBQUc7SUFDekIsTUFBTTtJQUNOLE9BQU87SUFDUDBDLFNBQVM7Q0FDWjtBQUNELElBQU0wRCxPQUFPLEdBQUcsSUFBSUgsR0FBRyxDQUFDO0lBQ3BCO1FBQ0ksU0FBUztRQUNUSSxhQUFhO0tBQ2hCO0lBQ0Q7UUFDSSxPQUFPO1FBQ1BDLFdBQVc7S0FDZDtJQUNEO1FBQ0ksWUFBWTtRQUNaQyxnQkFBZ0I7S0FDbkI7SUFDRDtRQUNJLFFBQVE7UUFDUkMsWUFBWTtLQUNmO0lBQ0Q7UUFDSSxRQUFRO1FBQ1JDLFlBQVk7S0FDZjtDQUNKLENBQUM7QUFDRixJQUFNakgsbUJBQW1CLEdBQUc7SUFDeEIsTUFBTTtJQUNOLE9BQU87SUFDUCxXQUFXO0lBQ1gsWUFBWTtJQUNaLEtBQUs7SUFDTGtELFNBQVM7Q0FDWjtBQUNELFNBQVNoRyxlQUFlLENBQUMvQyxHQUFHLEVBQUU7SUFDMUIsT0FBT0EsR0FBRyxDQUFDYixPQUFPLEtBQUs0SixTQUFTLENBQUM7Q0FDcEM7QUFDRCxTQUFTZ0UsaUJBQWlCLENBQUMvTSxHQUFHLEVBQUU7SUFDNUIsT0FBT0EsR0FBRyxDQUFDQSxHQUFHLEtBQUsrSSxTQUFTLENBQUM7Q0FDaEM7QUFDRCxTQUFTbEcsY0FBYyxDQUFDN0MsR0FBRyxFQUFFO0lBQ3pCLE9BQU8sT0FBT0EsR0FBRyxLQUFLLFFBQVEsSUFBSSxDQUFDK0MsZUFBZSxDQUFDL0MsR0FBRyxDQUFDLElBQUkrTSxpQkFBaUIsQ0FBQy9NLEdBQUcsQ0FBQyxDQUFDLENBQUM7Q0FDdEY7QUFDRCxTQUFTZ04sU0FBUyxDQUFDLEtBQTJCLEVBQUV2TSxLQUFLLEVBQUUyQixNQUFNLEVBQUVuQyxLQUFLLEVBQUU7UUFBakQ0QixXQUFXLEdBQWIsS0FBMkIsQ0FBekJBLFdBQVcsRUFBR0QsUUFBUSxHQUF4QixLQUEyQixDQUFYQSxRQUFRO0lBQ3ZDLElBQUkzQixLQUFLLElBQUksQ0FBQ21DLE1BQU0sS0FBSyxNQUFNLElBQUlBLE1BQU0sS0FBSyxZQUFZLElBQUlBLE1BQU0sS0FBSyxLQUFLLENBQUMsRUFBRTtRQUM3RSx5REFBeUQ7UUFDekQsSUFBTTZLLGVBQWUsdUJBQXVCO1FBQzVDLElBQU1DLFlBQVksR0FBRyxFQUFFO1FBQ3ZCLElBQUksSUFBSUMsS0FBSyxFQUFFQSxLQUFLLEdBQUdGLGVBQWUsQ0FBQ0csSUFBSSxDQUFDbk4sS0FBSyxDQUFDLEVBQUVrTixLQUFLLENBQUM7WUFDdERELFlBQVksQ0FBQ0csSUFBSSxDQUFDQyxRQUFRLENBQUNILEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDekM7UUFDRCxJQUFJRCxZQUFZLENBQUNqRyxNQUFNLEVBQUU7Z0JBQ0NzRyxLQUFJO1lBQTFCLElBQU1DLGFBQWEsR0FBR0QsQ0FBQUEsS0FBSSxHQUFKQSxJQUFJLEVBQUNFLEdBQUcsQ0FBUkYsS0FBeUIsQ0FBekJBLEtBQUksRUFBSyxtQkFBR0wsWUFBWSxDQUFaQSxDQUFhLEdBQUcsSUFBSTtZQUN0RCxPQUFPO2dCQUNIUSxNQUFNLEVBQUU5TCxRQUFRLENBQUNtRixNQUFNLENBQUMsU0FBQzRHLENBQUM7MkJBQUdBLENBQUMsSUFBSTlMLFdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRzJMLGFBQWE7aUJBQUEsQ0FDL0Q7Z0JBQ0RJLElBQUksRUFBRSxHQUFHO2FBQ1osQ0FBQztTQUNMO1FBQ0QsT0FBTztZQUNIRixNQUFNLEVBQUU5TCxRQUFRO1lBQ2hCZ00sSUFBSSxFQUFFLEdBQUc7U0FDWixDQUFDO0tBQ0w7SUFDRCxJQUFJLE9BQU9uTixLQUFLLEtBQUssUUFBUSxJQUFJMkIsTUFBTSxLQUFLLE1BQU0sSUFBSUEsTUFBTSxLQUFLLFlBQVksRUFBRTtRQUMzRSxPQUFPO1lBQ0hzTCxNQUFNLEVBQUU3TCxXQUFXO1lBQ25CK0wsSUFBSSxFQUFFLEdBQUc7U0FDWixDQUFDO0tBQ0w7SUFDRCxJQUFNRixNQUFNLEdBQ1IsbUJBQUcsSUFBSXJCLEdBQUcsQ0FDVixxRUFBcUU7SUFDckUsa0VBQWtFO0lBQ2xFLG9FQUFvRTtJQUNwRSx1RUFBdUU7SUFDdkUsc0VBQXNFO0lBQ3RFLHVDQUF1QztJQUN2QyxxSUFBcUk7SUFDckk7UUFDSTVMLEtBQUs7UUFDTEEsS0FBSyxHQUFHLENBQUMsQ0FBQyxlQUFlLENBQWhCO0tBQ1osQ0FBQ3NGLEdBQUcsQ0FBQyxTQUFDOEgsQ0FBQztlQUFHak0sUUFBUSxDQUFDa00sSUFBSSxDQUFDLFNBQUNDLENBQUM7bUJBQUdBLENBQUMsSUFBSUYsQ0FBQztTQUFBLENBQy9CLElBQUlqTSxRQUFRLENBQUNBLFFBQVEsQ0FBQ3FGLE1BQU0sR0FBRyxDQUFDLENBQUM7S0FBQSxDQUNyQyxDQUFDLENBYkM7SUFlUCxPQUFPO1FBQ0h5RyxNQUFNLEVBQU5BLE1BQU07UUFDTkUsSUFBSSxFQUFFLEdBQUc7S0FDWixDQUFDO0NBQ0w7QUFDRCxTQUFTNUUsZ0JBQWdCLENBQUMsS0FBMkUsRUFBRTtRQUEzRXpILE1BQU0sR0FBUixLQUEyRSxDQUF6RUEsTUFBTSxFQUFHdkIsR0FBRyxHQUFkLEtBQTJFLENBQWhFQSxHQUFHLEVBQUdFLFdBQVcsR0FBNUIsS0FBMkUsQ0FBMURBLFdBQVcsRUFBR2tDLE1BQU0sR0FBckMsS0FBMkUsQ0FBNUNBLE1BQU0sRUFBRzNCLEtBQUssR0FBN0MsS0FBMkUsQ0FBbkNBLEtBQUssRUFBR0QsT0FBTyxHQUF2RCxLQUEyRSxDQUEzQkEsT0FBTyxFQUFHUCxLQUFLLEdBQS9ELEtBQTJFLENBQWpCQSxLQUFLLEVBQUdvQyxNQUFNLEdBQXhFLEtBQTJFLENBQVRBLE1BQU07SUFDOUYsSUFBSW5DLFdBQVcsRUFBRTtRQUNiLE9BQU87WUFDSEYsR0FBRyxFQUFIQSxHQUFHO1lBQ0g4SSxNQUFNLEVBQUVDLFNBQVM7WUFDakI5SSxLQUFLLEVBQUU4SSxTQUFTO1NBQ25CLENBQUM7S0FDTDtJQUNELElBQTJCaUUsSUFBdUMsR0FBdkNBLFNBQVMsQ0FBQ3pMLE1BQU0sRUFBRWQsS0FBSyxFQUFFMkIsTUFBTSxFQUFFbkMsS0FBSyxDQUFDLEVBQTFEeU4sTUFBTSxHQUFhVixJQUF1QyxDQUExRFUsTUFBTSxFQUFHRSxJQUFJLEdBQU1aLElBQXVDLENBQWpEWSxJQUFJO0lBQ3JCLElBQU1JLElBQUksR0FBR04sTUFBTSxDQUFDekcsTUFBTSxHQUFHLENBQUM7SUFDOUIsT0FBTztRQUNIaEgsS0FBSyxFQUFFLENBQUNBLEtBQUssSUFBSTJOLElBQUksS0FBSyxHQUFHLEdBQUcsT0FBTyxHQUFHM04sS0FBSztRQUMvQzZJLE1BQU0sRUFBRTRFLE1BQU0sQ0FBQzNILEdBQUcsQ0FBQyxTQUFDOEgsQ0FBQyxFQUFFdEMsQ0FBQzttQkFBRyxFQUFDLENBS2xCcUMsTUFBd0IsQ0FMSnZMLE1BQU0sQ0FBQztnQkFDN0JkLE1BQU0sRUFBTkEsTUFBTTtnQkFDTnZCLEdBQUcsRUFBSEEsR0FBRztnQkFDSFEsT0FBTyxFQUFQQSxPQUFPO2dCQUNQQyxLQUFLLEVBQUVvTixDQUFDO2FBQ1gsQ0FBQyxFQUFDLEdBQUMsQ0FBMkIsQ0FBRUQsTUFBSSxDQUEvQkEsSUFBSSxLQUFLLEdBQUcsR0FBR0MsQ0FBQyxHQUFHdEMsQ0FBQyxHQUFHLENBQUMsQ0FBUSxRQUFMcUMsSUFBSSxDQUFFO1NBQUEsQ0FDMUMsQ0FBQzNILElBQUksQ0FBQyxJQUFJLENBQUM7UUFDWix1RUFBdUU7UUFDdkUsbUVBQW1FO1FBQ25FLHlFQUF5RTtRQUN6RSwwRUFBMEU7UUFDMUUsMkJBQTJCO1FBQzNCLHNEQUFzRDtRQUN0RGpHLEdBQUcsRUFBRXFDLE1BQU0sQ0FBQztZQUNSZCxNQUFNLEVBQU5BLE1BQU07WUFDTnZCLEdBQUcsRUFBSEEsR0FBRztZQUNIUSxPQUFPLEVBQVBBLE9BQU87WUFDUEMsS0FBSyxFQUFFaU4sTUFBTSxDQUFDTSxJQUFJLENBQUM7U0FDdEIsQ0FBQztLQUNMLENBQUM7Q0FDTDtBQUNELFNBQVM1SyxNQUFNLENBQUM2SyxDQUFDLEVBQUU7SUFDZixJQUFJLE9BQU9BLENBQUMsS0FBSyxRQUFRLEVBQUU7UUFDdkIsT0FBT0EsQ0FBQyxDQUFDO0tBQ1o7SUFDRCxJQUFJLE9BQU9BLENBQUMsS0FBSyxRQUFRLEVBQUU7UUFDdkIsT0FBT1gsUUFBUSxDQUFDVyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7S0FDMUI7SUFDRCxPQUFPbEYsU0FBUyxDQUFDO0NBQ3BCO0FBQ0QsU0FBU3pHLGtCQUFrQixDQUFDNEwsV0FBVyxFQUFFO0lBQ3JDLElBQUlDLElBQUk7SUFDUixJQUFNQyxTQUFTLEdBQUcsQ0FBQyxDQUFDRCxJQUFJLEdBQUdELFdBQVcsQ0FBQzNNLE1BQU0sQ0FBQyxLQUFLLElBQUksSUFBSTRNLElBQUksS0FBSyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBR0EsSUFBSSxDQUFDOUwsTUFBTSxDQUFDLElBQUksU0FBUztJQUMvRyxJQUFNZ00sSUFBSSxHQUFHNUIsT0FBTyxDQUFDNUUsR0FBRyxDQUFDdUcsU0FBUyxDQUFDO0lBQ25DLElBQUlDLElBQUksRUFBRTtRQUNOLE9BQU9BLElBQUksQ0FBQ0gsV0FBVyxDQUFDLENBQUM7S0FDNUI7SUFDRCxNQUFNLElBQUlsTCxLQUFLLENBQUMsd0RBQXVELENBQXNEb0wsTUFBUyxDQUE3RDFPLFlBQVksQ0FBQzRPLGFBQWEsQ0FBQ3JJLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBQyxjQUFZLENBQVksUUFBVm1JLFNBQVMsQ0FBRSxDQUFDLENBQUM7Q0FDN0k7QUFDRCwwRUFBMEU7QUFDMUUsaURBQWlEO0FBQ2pELFNBQVNHLGFBQWEsQ0FBQ0MsR0FBRyxFQUFFeE8sR0FBRyxFQUFFb0MsTUFBTSxFQUFFcEIsV0FBVyxFQUFFOEksb0JBQW9CLEVBQUVqRyxlQUFlLEVBQUU7SUFDekYsSUFBSSxDQUFDMkssR0FBRyxJQUFJQSxHQUFHLENBQUN4TyxHQUFHLEtBQUs2SSxZQUFZLElBQUkyRixHQUFHLENBQUMsaUJBQWlCLENBQUMsS0FBS3hPLEdBQUcsRUFBRTtRQUNwRSxPQUFPO0tBQ1Y7SUFDRHdPLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHeE8sR0FBRyxDQUFDO0lBQzdCLElBQU0rTixDQUFDLEdBQUcsUUFBUSxJQUFJUyxHQUFHLEdBQUdBLEdBQUcsQ0FBQ0MsTUFBTSxFQUFFLEdBQUdDLE9BQU8sQ0FBQ0MsT0FBTyxFQUFFO0lBQzVEWixDQUFDLENBQUNhLEtBQUssQ0FBQyxXQUFJLEVBQUUsQ0FBQyxDQUFDQyxJQUFJLENBQUMsV0FBSTtRQUNyQixJQUFJLENBQUNMLEdBQUcsQ0FBQ00sVUFBVSxFQUFFO1lBQ2pCLHdDQUF3QztZQUN4Qyx1QkFBdUI7WUFDdkIsc0NBQXNDO1lBQ3RDLHNCQUFzQjtZQUN0Qix1QkFBdUI7WUFDdkIsT0FBTztTQUNWO1FBQ0RyTCxlQUFlLENBQUNzTCxHQUFHLENBQUMvTyxHQUFHLENBQUMsQ0FBQztRQUN6QixJQUFJZ0IsV0FBVyxLQUFLLE1BQU0sRUFBRTtZQUN4QjZDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN6QjtRQUNELElBQUlpRyxvQkFBb0IsS0FBSyxJQUFJLElBQUlBLG9CQUFvQixLQUFLLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHQSxvQkFBb0IsQ0FBQ0csT0FBTyxFQUFFO1lBQzFHLElBQVErRSxZQUFZLEdBQXNCUixHQUFHLENBQXJDUSxZQUFZLEVBQUdDLGFBQWEsR0FBTVQsR0FBRyxDQUF0QlMsYUFBYTtZQUNwQyxtREFBbUQ7WUFDbkQsc0RBQXNEO1lBQ3REbkYsb0JBQW9CLENBQUNHLE9BQU8sQ0FBQztnQkFDekIrRSxZQUFZLEVBQVpBLFlBQVk7Z0JBQ1pDLGFBQWEsRUFBYkEsYUFBYTthQUNoQixDQUFDLENBQUM7U0FDTjtRQUNELElBQUlySixJQUFxQyxFQUFFO1lBQ3ZDLElBQUlzSixJQUFJO1lBQ1IsSUFBSSxDQUFDQSxJQUFJLEdBQUdWLEdBQUcsQ0FBQ1csYUFBYSxDQUFDLEtBQUssSUFBSSxJQUFJRCxJQUFJLEtBQUssS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUdBLElBQUksQ0FBQ0MsYUFBYSxFQUFFO2dCQUN0RixJQUFNQyxNQUFNLEdBQUdDLGdCQUFnQixDQUFDYixHQUFHLENBQUNXLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDO2dCQUNoRSxJQUFJLENBQUNDLE1BQU0sQ0FBQ2pLLFFBQVEsRUFBRTtnQkFDdEIsc0hBQXNIO2lCQUNySCxNQUFNLElBQUkvQyxNQUFNLEtBQUssWUFBWSxJQUFJZ04sTUFBTSxDQUFDNUssT0FBTyxLQUFLLE1BQU0sRUFBRTtvQkFDN0QsQ0FBQyxDQUFDLEVBQUUzRSxNQUFNLENBQUMsQ0FBQ3VHLFFBQVEsQ0FBQyxrQkFBaUIsQ0FBTSxNQUF3SCxDQUE1SHBHLEdBQUcsRUFBQywwSEFBd0gsQ0FBQyxDQUFDLENBQUM7aUJBQzFLLE1BQU0sSUFBSW9DLE1BQU0sS0FBSyxNQUFNLElBQUlnTixNQUFNLENBQUNqSyxRQUFRLEtBQUssVUFBVSxJQUFJaUssTUFBTSxDQUFDakssUUFBUSxLQUFLLE9BQU8sSUFBSWlLLE1BQU0sQ0FBQ2pLLFFBQVEsS0FBSyxVQUFVLEVBQUU7b0JBQzdILENBQUMsQ0FBQyxFQUFFdEYsTUFBTSxDQUFDLENBQUN1RyxRQUFRLENBQUMsa0JBQWlCLENBQWdFZ0osTUFBZSxDQUE3RXBQLEdBQUcsRUFBQywwREFBd0QsQ0FBa0IsT0FBcUYsQ0FBckdvUCxNQUFNLENBQUNqSyxRQUFRLEVBQUMsdUZBQXFGLENBQUMsQ0FBQyxDQUFDO2lCQUNqTjthQUNKO1NBQ0o7S0FDSixDQUFDLENBQUM7Q0FDTjtBQUNELElBQU1rRixZQUFZLEdBQUcsU0FBQ3RLLE1BQU0sRUFBRzs7SUFDM0IsSUFBTTZJLGFBQWEsR0FBb1A3SSxNQUFNLENBQXZRNkksYUFBYSxFQUFHdkYsU0FBUyxHQUF3T3RELE1BQU0sQ0FBdlBzRCxTQUFTLEVBQUdGLFFBQVEsR0FBNk5wRCxNQUFNLENBQTNPb0QsUUFBUSxFQUFHRyxVQUFVLEdBQWdOdkQsTUFBTSxDQUFoT3VELFVBQVUsRUFBR2xCLE1BQU0sR0FBdU1yQyxNQUFNLENBQW5OcUMsTUFBTSxFQUFHN0IsU0FBUyxHQUEyTFIsTUFBTSxDQUExTVEsU0FBUyxFQUFHNEgsUUFBUSxHQUFnTHBJLE1BQU0sQ0FBOUxvSSxRQUFRLEVBQUdHLFNBQVMsR0FBb0t2SSxNQUFNLENBQW5MdUksU0FBUyxFQUFHL0UsTUFBTSxHQUEySnhELE1BQU0sQ0FBdkt3RCxNQUFNLEVBQUd2QyxXQUFXLEdBQTZJakIsTUFBTSxDQUE5SmlCLFdBQVcsRUFBR1osT0FBTyxHQUFtSUwsTUFBTSxDQUFoSkssT0FBTyxFQUFHNkksU0FBUyxHQUF1SGxKLE1BQU0sQ0FBdElrSixTQUFTLEVBQUcxSCxNQUFNLEdBQThHeEIsTUFBTSxDQUExSHdCLE1BQU0sRUFBR3JCLFdBQVcsR0FBZ0dILE1BQU0sQ0FBakhHLFdBQVcsRUFBR21DLE1BQU0sR0FBdUZ0QyxNQUFNLENBQW5Hc0MsTUFBTSxFQUFHeUgsb0JBQW9CLEdBQWdFL0osTUFBTSxDQUExRitKLG9CQUFvQixFQUFHakcsZUFBZSxHQUE4QzlELE1BQU0sQ0FBbkU4RCxlQUFlLEVBQUdLLGVBQWUsR0FBNEJuRSxNQUFNLENBQWpEbUUsZUFBZSxFQUFHbkQsT0FBTyxHQUFrQmhCLE1BQU0sQ0FBL0JnQixPQUFPLEVBQUdzRCxTQUFTLEdBQU10RSxNQUFNLENBQXJCc0UsU0FBUyxFQUFjbEMsSUFBSSxHQUFHaEIsd0JBQXdCLENBQUNwQixNQUFNLEVBQUU7UUFDblQsZUFBZTtRQUNmLFdBQVc7UUFDWCxVQUFVO1FBQ1YsWUFBWTtRQUNaLFFBQVE7UUFDUixXQUFXO1FBQ1gsVUFBVTtRQUNWLFdBQVc7UUFDWCxRQUFRO1FBQ1IsYUFBYTtRQUNiLFNBQVM7UUFDVCxXQUFXO1FBQ1gsUUFBUTtRQUNSLGFBQWE7UUFDYixRQUFRO1FBQ1Isc0JBQXNCO1FBQ3RCLGlCQUFpQjtRQUNqQixpQkFBaUI7UUFDakIsU0FBUztRQUNULFdBQVc7S0FDZCxDQUFDO0lBQ0YsT0FBTyxhQUFhLENBQUNWLE1BQU0sQ0FBQ0YsT0FBTyxDQUFDZ0wsYUFBYSxDQUFDOUssTUFBTSxDQUFDRixPQUFPLENBQUNpTCxRQUFRLEVBQUUsSUFBSSxFQUFFLGFBQWEsQ0FBQy9LLE1BQU0sQ0FBQ0YsT0FBTyxDQUFDZ0wsYUFBYSxDQUFDLEtBQUssRUFBRXBMLE1BQU0sQ0FBQ3FKLE1BQU0sQ0FBQyxFQUFFLEVBQUVqRyxJQUFJLEVBQUV5RyxhQUFhLEVBQUV4RyxNQUFNLEtBQUssS0FBSyxJQUFJLENBQUN3RyxhQUFhLENBQUMzSSxLQUFLLEdBQUc7UUFDak5TLE1BQU0sRUFBRTJDLFNBQVM7UUFDakI1QyxLQUFLLEVBQUUwQyxRQUFRO0tBQ2xCLEdBQUcsRUFBRSxFQUFFO1FBQ0ptTSxRQUFRLEVBQUUsT0FBTztRQUNqQixXQUFXLEVBQUVsTixNQUFNO1FBQ25CN0IsU0FBUyxFQUFFQSxTQUFTO1FBQ3BCSSxLQUFLLEVBQUV1QixhQUFhLENBQUMsRUFBRSxFQUFFaUcsUUFBUSxFQUFFRyxTQUFTLENBQUM7UUFDN0M2RCxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUU5TSxNQUFNLENBQUMsQ0FBQ2tRLFdBQVcsQ0FBQyxTQUFDZixHQUFHLEVBQUc7WUFDaEN0SyxlQUFlLENBQUNzSyxHQUFHLENBQUMsQ0FBQztZQUNyQixJQUFJQSxHQUFHLEtBQUssSUFBSSxJQUFJQSxHQUFHLEtBQUssS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUdBLEdBQUcsQ0FBQ2dCLFFBQVEsRUFBRTtnQkFDeERqQixhQUFhLENBQUNDLEdBQUcsRUFBRXZGLFNBQVMsRUFBRTdHLE1BQU0sRUFBRXBCLFdBQVcsRUFBRThJLG9CQUFvQixFQUFFakcsZUFBZSxDQUFDLENBQUM7YUFDN0Y7U0FDSixFQUFFO1lBQ0NLLGVBQWU7WUFDZitFLFNBQVM7WUFDVDdHLE1BQU07WUFDTnBCLFdBQVc7WUFDWDhJLG9CQUFvQjtZQUNwQmpHLGVBQWU7U0FDbEIsQ0FBQztRQUNGNEwsTUFBTSxFQUFFLFNBQUNDLEtBQUssRUFBRztZQUNiLElBQU1sQixHQUFHLEdBQUdrQixLQUFLLENBQUNDLGFBQWE7WUFDL0JwQixhQUFhLENBQUNDLEdBQUcsRUFBRXZGLFNBQVMsRUFBRTdHLE1BQU0sRUFBRXBCLFdBQVcsRUFBRThJLG9CQUFvQixFQUFFakcsZUFBZSxDQUFDLENBQUM7U0FDN0Y7UUFDRDlDLE9BQU8sRUFBRSxTQUFDMk8sS0FBSyxFQUFHO1lBQ2QsSUFBSTFPLFdBQVcsS0FBSyxNQUFNLEVBQUU7Z0JBQ3hCLDJFQUEyRTtnQkFDM0U2QyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDekI7WUFDRCxJQUFJOUMsT0FBTyxFQUFFO2dCQUNUQSxPQUFPLENBQUMyTyxLQUFLLENBQUMsQ0FBQzthQUNsQjtTQUNKO0tBQ0osQ0FBQyxDQUFDLEVBQUUsQ0FBQ25NLE1BQU0sSUFBSXZDLFdBQVcsS0FBSyxNQUFNLENBQUMsSUFBSSxhQUFhLENBQUMzQixNQUFNLENBQUNGLE9BQU8sQ0FBQ2dMLGFBQWEsQ0FBQyxVQUFVLEVBQUUsSUFBSSxFQUFFLGFBQWEsQ0FBQzlLLE1BQU0sQ0FBQ0YsT0FBTyxDQUFDZ0wsYUFBYSxDQUFDLEtBQUssRUFBRXBMLE1BQU0sQ0FBQ3FKLE1BQU0sQ0FBQyxFQUFFLEVBQUVqRyxJQUFJLEVBQUU2RyxnQkFBZ0IsQ0FBQztRQUMvTHpILE1BQU0sRUFBTkEsTUFBTTtRQUNOdkIsR0FBRyxFQUFFaUosU0FBUztRQUNkL0ksV0FBVyxFQUFYQSxXQUFXO1FBQ1hrQyxNQUFNLEVBQU5BLE1BQU07UUFDTjNCLEtBQUssRUFBRTBDLFFBQVE7UUFDZjNDLE9BQU8sRUFBRThDLFVBQVU7UUFDbkJyRCxLQUFLLEVBQUUySSxhQUFhLENBQUMzSSxLQUFLO1FBQzFCb0MsTUFBTSxFQUFOQSxNQUFNO0tBQ1QsQ0FBQyxFQUFFRCxNQUFNLEtBQUssS0FBSyxJQUFJLENBQUN3RyxhQUFhLENBQUMzSSxLQUFLLEdBQUc7UUFDM0NTLE1BQU0sRUFBRTJDLFNBQVM7UUFDakI1QyxLQUFLLEVBQUUwQyxRQUFRO0tBQ2xCLEdBQUcsRUFBRSxFQUFFO1FBQ0ptTSxRQUFRLEVBQUUsT0FBTztRQUNqQixXQUFXLEVBQUVsTixNQUFNO1FBQ25CekIsS0FBSyxFQUFFd0gsUUFBUTtRQUNmNUgsU0FBUyxFQUFFQSxTQUFTO1FBQ3BCLGtEQUFrRDtRQUNsREgsT0FBTyxFQUFFQSxPQUFPLElBQUksTUFBTTtLQUM3QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUU7Q0FDVjtJQTdFS2lLLFlBQVk7QUFBWkEsTUFBQUEsWUFBWTtBQThFbEIsU0FBU3VGLFlBQVksQ0FBQzVQLEdBQUcsRUFBRTtJQUN2QixPQUFPQSxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHQSxHQUFHLENBQUM2UCxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUc3UCxHQUFHLENBQUM7Q0FDOUM7QUFDRCxTQUFTMk0sV0FBVyxDQUFDLEtBQW1DLEVBQUU7UUFBbkNwTCxNQUFNLEdBQVIsS0FBbUMsQ0FBakNBLE1BQU0sRUFBR3ZCLEdBQUcsR0FBZCxLQUFtQyxDQUF4QkEsR0FBRyxFQUFHUyxLQUFLLEdBQXRCLEtBQW1DLENBQWxCQSxLQUFLLEVBQUdELE9BQU8sR0FBaEMsS0FBbUMsQ0FBVkEsT0FBTztJQUNqRCxxRUFBcUU7SUFDckUsSUFBTWdHLEdBQUcsR0FBRyxJQUFJQyxHQUFHLENBQUMsRUFBQyxDQUFnQm1KLE1BQWlCLENBQS9Cck8sTUFBTSxDQUFDdU8sSUFBSSxDQUFxQixRQUFsQkYsWUFBWSxDQUFDNVAsR0FBRyxDQUFDLENBQUUsQ0FBQztJQUN6RCxJQUFNK1AsTUFBTSxHQUFHdkosR0FBRyxDQUFDd0osWUFBWTtJQUMvQkQsTUFBTSxDQUFDekcsR0FBRyxDQUFDLE1BQU0sRUFBRXlHLE1BQU0sQ0FBQ2xJLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxRQUFRLENBQUMsQ0FBQztJQUNuRGtJLE1BQU0sQ0FBQ3pHLEdBQUcsQ0FBQyxLQUFLLEVBQUV5RyxNQUFNLENBQUNsSSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUM7SUFDOUNrSSxNQUFNLENBQUN6RyxHQUFHLENBQUMsR0FBRyxFQUFFeUcsTUFBTSxDQUFDbEksR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJcEgsS0FBSyxDQUFDd1AsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUNyRCxJQUFJelAsT0FBTyxFQUFFO1FBQ1R1UCxNQUFNLENBQUN6RyxHQUFHLENBQUMsR0FBRyxFQUFFOUksT0FBTyxDQUFDeVAsUUFBUSxFQUFFLENBQUMsQ0FBQztLQUN2QztJQUNELE9BQU96SixHQUFHLENBQUM2QyxJQUFJLENBQUM7Q0FDbkI7QUFDRCxTQUFTd0QsWUFBWSxDQUFDLEtBQXlCLEVBQUU7UUFBekJ0TCxNQUFNLEdBQVIsS0FBeUIsQ0FBdkJBLE1BQU0sRUFBR3ZCLEdBQUcsR0FBZCxLQUF5QixDQUFkQSxHQUFHLEVBQUdTLEtBQUssR0FBdEIsS0FBeUIsQ0FBUkEsS0FBSztJQUN4QyxPQUFPLEVBQUMsQ0FBZ0JtUCxNQUFpQixDQUEvQnJPLE1BQU0sQ0FBQ3VPLElBQUksQ0FBcUIsQ0FBV3JQLE1BQUssQ0FBbENtUCxZQUFZLENBQUM1UCxHQUFHLENBQUMsRUFBQyxXQUFTLENBQVEsUUFBTlMsS0FBSyxDQUFFLENBQUM7Q0FDaEU7QUFDRCxTQUFTbU0sZ0JBQWdCLENBQUMsS0FBbUMsRUFBRTtRQUFuQ3JMLE1BQU0sR0FBUixLQUFtQyxDQUFqQ0EsTUFBTSxFQUFHdkIsR0FBRyxHQUFkLEtBQW1DLENBQXhCQSxHQUFHLEVBQUdTLEtBQUssR0FBdEIsS0FBbUMsQ0FBbEJBLEtBQUssRUFBR0QsT0FBTyxHQUFoQyxLQUFtQyxDQUFWQSxPQUFPO0lBQ3RELHNGQUFzRjtJQUN0RixJQUFNdVAsTUFBTSxHQUFHO1FBQ1gsUUFBUTtRQUNSLFNBQVM7UUFDVCxJQUFJLEdBQUd0UCxLQUFLO1FBQ1osSUFBSSxHQUFHLENBQUNELE9BQU8sSUFBSSxNQUFNLENBQUM7S0FDN0I7SUFDRCxJQUFNMFAsWUFBWSxHQUFHSCxNQUFNLENBQUM5SixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRztJQUMzQyxPQUFPLEVBQUMsQ0FBZ0JpSyxNQUFZLENBQTFCM08sTUFBTSxDQUFDdU8sSUFBSSxDQUFnQixDQUFFRixNQUFpQixDQUFoQ00sWUFBWSxDQUFxQixRQUFsQk4sWUFBWSxDQUFDNVAsR0FBRyxDQUFDLENBQUUsQ0FBQztDQUM5RDtBQUNELFNBQVM4TSxZQUFZLENBQUMsS0FBUSxFQUFFO1FBQVYsR0FBSyxHQUFMLEtBQVEsQ0FBTjlNLEdBQUc7SUFDdkIsTUFBTSxJQUFJZ0QsS0FBSyxDQUFDLGtCQUFpQixDQUFNLE1BQTJCLENBQS9CaEQsR0FBRyxFQUFDLDZCQUEyQixDQUFDLEdBQUkseUVBQXVFLENBQUUsQ0FBQztDQUNwSjtBQUNELFNBQVMwTSxhQUFhLENBQUMsS0FBbUMsRUFBRTtRQUFuQ25MLE1BQU0sR0FBUixLQUFtQyxDQUFqQ0EsTUFBTSxFQUFHdkIsR0FBRyxHQUFkLEtBQW1DLENBQXhCQSxHQUFHLEVBQUdTLEtBQUssR0FBdEIsS0FBbUMsQ0FBbEJBLEtBQUssRUFBR0QsT0FBTyxHQUFoQyxLQUFtQyxDQUFWQSxPQUFPO0lBQ25ELElBQUlvRixJQUFxQyxFQUFFO1FBQ3ZDLElBQU11SyxhQUFhLEdBQUcsRUFBRTtRQUN4Qix5REFBeUQ7UUFDekQsSUFBSSxDQUFDblEsR0FBRyxFQUFFbVEsYUFBYSxDQUFDOUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3BDLElBQUksQ0FBQzVNLEtBQUssRUFBRTBQLGFBQWEsQ0FBQzlDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN4QyxJQUFJOEMsYUFBYSxDQUFDbEosTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMxQixNQUFNLElBQUlqRSxLQUFLLENBQUMsbUNBQWtDLENBQTBIQyxNQUkxSyxDQUprRGtOLGFBQWEsQ0FBQ2xLLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBQyw2RkFBNkYsQ0FJdkssUUFKeUtoRCxJQUFJLENBQUNDLFNBQVMsQ0FBQztnQkFDdkxsRCxHQUFHLEVBQUhBLEdBQUc7Z0JBQ0hTLEtBQUssRUFBTEEsS0FBSztnQkFDTEQsT0FBTyxFQUFQQSxPQUFPO2FBQ1YsQ0FBQyxDQUFFLENBQUMsQ0FBQztTQUNUO1FBQ0QsSUFBSVIsR0FBRyxDQUFDd0QsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3RCLE1BQU0sSUFBSVIsS0FBSyxDQUFDLHVCQUFzQixDQUFNLE1BQXdHLENBQTVHaEQsR0FBRyxFQUFDLHdHQUF3RyxDQUFDLENBQUMsQ0FBQztTQUMxSjtRQUNELElBQUksQ0FBQ0EsR0FBRyxDQUFDd0QsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJakMsTUFBTSxDQUFDNk8sT0FBTyxFQUFFO1lBQ3hDLElBQUlDLFNBQVM7WUFDYixJQUFJO2dCQUNBQSxTQUFTLEdBQUcsSUFBSTVKLEdBQUcsQ0FBQ3pHLEdBQUcsQ0FBQyxDQUFDO2FBQzVCLENBQUMsT0FBTzBHLEdBQUcsRUFBRTtnQkFDVnVCLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDeEIsR0FBRyxDQUFDLENBQUM7Z0JBQ25CLE1BQU0sSUFBSTFELEtBQUssQ0FBQyx1QkFBc0IsQ0FBTSxNQUErSCxDQUFuSWhELEdBQUcsRUFBQywrSEFBK0gsQ0FBQyxDQUFDLENBQUM7YUFDakw7WUFDRCxJQUFJNEYsS0FBK0IsSUFBSSxDQUFDckUsTUFBTSxDQUFDNk8sT0FBTyxDQUFDdEssUUFBUSxDQUFDdUssU0FBUyxDQUFDQyxRQUFRLENBQUMsRUFBRTtnQkFDakYsTUFBTSxJQUFJdE4sS0FBSyxDQUFDLG9CQUFtQixDQUF1Q3FOLE1BQWtCLENBQXZEclEsR0FBRyxFQUFDLCtCQUErQixDQUFxQixPQUE2RCxDQUFoRnFRLFNBQVMsQ0FBQ0MsUUFBUSxFQUFDLDZEQUE2RCxDQUFDLEdBQUksOEVBQTRFLENBQUUsQ0FBQzthQUNqUDtTQUNKO0tBQ0o7SUFDRCxJQUFJdFEsR0FBRyxDQUFDdVEsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUNoUCxNQUFNLENBQUNpUCxtQkFBbUIsRUFBRTtRQUNyRCx5REFBeUQ7UUFDekQsK0NBQStDO1FBQy9DLE9BQU94USxHQUFHLENBQUM7S0FDZDtJQUNELE9BQU8sRUFBQyxDQUE4RXlRLE1BQXVCLENBQW5HLENBQUMsQ0FBQyxFQUFFM1EsdUJBQXVCLENBQUMsQ0FBQzRRLDBCQUEwQixDQUFDblAsTUFBTSxDQUFDdU8sSUFBSSxDQUFDLEVBQUMsT0FBSyxDQUEwQixDQUFLclAsTUFBSyxDQUFsQ2dRLGtCQUFrQixDQUFDelEsR0FBRyxDQUFDLEVBQUMsS0FBRyxDQUFRLENBQUtRLE1BQWEsQ0FBeEJDLEtBQUssRUFBQyxLQUFHLENBQWdCLFFBQWRELE9BQU8sSUFBSSxFQUFFLENBQUUsQ0FBQztDQUNqSjtBQUVELElBQUksT0FBT3ZCLE9BQU8sQ0FBQ0UsT0FBTyxLQUFLLFVBQVUsSUFBSyxPQUFPRixPQUFPLENBQUNFLE9BQU8sS0FBSyxRQUFRLElBQUlGLE9BQU8sQ0FBQ0UsT0FBTyxLQUFLLElBQUksRUFBRztJQUM5R0osTUFBTSxDQUFDcUosTUFBTSxDQUFDbkosT0FBTyxDQUFDRSxPQUFPLEVBQUVGLE9BQU8sQ0FBQyxDQUFDO0lBQ3hDMFIsTUFBTSxDQUFDMVIsT0FBTyxHQUFHQSxPQUFPLENBQUNFLE9BQU8sQ0FBQztDQUNsQyxDQUVELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbWFnZS5qcz84MmY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSW1hZ2U7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfaGVhZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaGVhZFwiKSk7XG52YXIgX2ltYWdlQ29uZmlnID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnXCIpO1xudmFyIF91c2VJbnRlcnNlY3Rpb24gPSByZXF1aXJlKFwiLi91c2UtaW50ZXJzZWN0aW9uXCIpO1xudmFyIF9pbWFnZUNvbmZpZ0NvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dFwiKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlsc1wiKTtcbnZhciBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaFwiKTtcbmZ1bmN0aW9uIEltYWdlKF9wYXJhbSkge1xuICAgIHZhciB7IHNyYyAsIHNpemVzICwgdW5vcHRpbWl6ZWQgPWZhbHNlICwgcHJpb3JpdHkgPWZhbHNlICwgbG9hZGluZyAsIGxhenlSb290ID1udWxsICwgbGF6eUJvdW5kYXJ5ID0nMjAwcHgnICwgY2xhc3NOYW1lICwgcXVhbGl0eSAsIHdpZHRoICwgaGVpZ2h0ICwgc3R5bGUgLCBvYmplY3RGaXQgLCBvYmplY3RQb3NpdGlvbiAsIG9uTG9hZGluZ0NvbXBsZXRlICwgb25FcnJvciAsIHBsYWNlaG9sZGVyID0nZW1wdHknICwgYmx1ckRhdGFVUkwgIH0gPSBfcGFyYW0sIGFsbCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcGFyYW0sIFtcbiAgICAgICAgXCJzcmNcIixcbiAgICAgICAgXCJzaXplc1wiLFxuICAgICAgICBcInVub3B0aW1pemVkXCIsXG4gICAgICAgIFwicHJpb3JpdHlcIixcbiAgICAgICAgXCJsb2FkaW5nXCIsXG4gICAgICAgIFwibGF6eVJvb3RcIixcbiAgICAgICAgXCJsYXp5Qm91bmRhcnlcIixcbiAgICAgICAgXCJjbGFzc05hbWVcIixcbiAgICAgICAgXCJxdWFsaXR5XCIsXG4gICAgICAgIFwid2lkdGhcIixcbiAgICAgICAgXCJoZWlnaHRcIixcbiAgICAgICAgXCJzdHlsZVwiLFxuICAgICAgICBcIm9iamVjdEZpdFwiLFxuICAgICAgICBcIm9iamVjdFBvc2l0aW9uXCIsXG4gICAgICAgIFwib25Mb2FkaW5nQ29tcGxldGVcIixcbiAgICAgICAgXCJvbkVycm9yXCIsXG4gICAgICAgIFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgXCJibHVyRGF0YVVSTFwiXG4gICAgXSk7XG4gICAgY29uc3QgY29uZmlnQ29udGV4dCA9ICgwLCBfcmVhY3QpLnVzZUNvbnRleHQoX2ltYWdlQ29uZmlnQ29udGV4dC5JbWFnZUNvbmZpZ0NvbnRleHQpO1xuICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBfcmVhY3QpLnVzZU1lbW8oKCk9PntcbiAgICAgICAgY29uc3QgYyA9IGNvbmZpZ0VudiB8fCBjb25maWdDb250ZXh0IHx8IF9pbWFnZUNvbmZpZy5pbWFnZUNvbmZpZ0RlZmF1bHQ7XG4gICAgICAgIGNvbnN0IGFsbFNpemVzID0gW1xuICAgICAgICAgICAgLi4uYy5kZXZpY2VTaXplcyxcbiAgICAgICAgICAgIC4uLmMuaW1hZ2VTaXplc1xuICAgICAgICBdLnNvcnQoKGEsIGIpPT5hIC0gYlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBkZXZpY2VTaXplcyA9IGMuZGV2aWNlU2l6ZXMuc29ydCgoYSwgYik9PmEgLSBiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBjLCB7XG4gICAgICAgICAgICBhbGxTaXplcyxcbiAgICAgICAgICAgIGRldmljZVNpemVzXG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgY29uZmlnQ29udGV4dFxuICAgIF0pO1xuICAgIGxldCByZXN0ID0gYWxsO1xuICAgIGxldCBsYXlvdXQgPSBzaXplcyA/ICdyZXNwb25zaXZlJyA6ICdpbnRyaW5zaWMnO1xuICAgIGlmICgnbGF5b3V0JyBpbiByZXN0KSB7XG4gICAgICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQgbGF5b3V0IGlmIHRoZSB1c2VyIHNwZWNpZmllZCBvbmU6XG4gICAgICAgIGlmIChyZXN0LmxheW91dCkgbGF5b3V0ID0gcmVzdC5sYXlvdXQ7XG4gICAgICAgIC8vIFJlbW92ZSBwcm9wZXJ0eSBzbyBpdCdzIG5vdCBzcHJlYWQgb24gPGltZz46XG4gICAgICAgIGRlbGV0ZSByZXN0LmxheW91dDtcbiAgICB9XG4gICAgbGV0IGxvYWRlciA9IGRlZmF1bHRJbWFnZUxvYWRlcjtcbiAgICBpZiAoJ2xvYWRlcicgaW4gcmVzdCkge1xuICAgICAgICBpZiAocmVzdC5sb2FkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUltYWdlTG9hZGVyID0gcmVzdC5sb2FkZXI7XG4gICAgICAgICAgICB2YXIgX3RtcDtcbiAgICAgICAgICAgIF90bXAgPSAob2JqKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29uZmlnOiBfICB9ID0gb2JqLCBvcHRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwgW1xuICAgICAgICAgICAgICAgICAgICBcImNvbmZpZ1wiXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbmZpZyBvYmplY3QgaXMgaW50ZXJuYWwgb25seSBzbyB3ZSBtdXN0XG4gICAgICAgICAgICAgICAgLy8gbm90IHBhc3MgaXQgdG8gdGhlIHVzZXItZGVmaW5lZCBsb2FkZXIoKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21JbWFnZUxvYWRlcihvcHRzKTtcbiAgICAgICAgICAgIH0sIGxvYWRlciA9IF90bXAsIF90bXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHByb3BlcnR5IHNvIGl0J3Mgbm90IHNwcmVhZCBvbiA8aW1nPlxuICAgICAgICBkZWxldGUgcmVzdC5sb2FkZXI7XG4gICAgfVxuICAgIGxldCBzdGF0aWNTcmMgPSAnJztcbiAgICBpZiAoaXNTdGF0aWNJbXBvcnQoc3JjKSkge1xuICAgICAgICBjb25zdCBzdGF0aWNJbWFnZURhdGEgPSBpc1N0YXRpY1JlcXVpcmUoc3JjKSA/IHNyYy5kZWZhdWx0IDogc3JjO1xuICAgICAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5zcmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBzcmMuIFJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoc3RhdGljSW1hZ2VEYXRhKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBibHVyRGF0YVVSTCA9IGJsdXJEYXRhVVJMIHx8IHN0YXRpY0ltYWdlRGF0YS5ibHVyRGF0YVVSTDtcbiAgICAgICAgc3RhdGljU3JjID0gc3RhdGljSW1hZ2VEYXRhLnNyYztcbiAgICAgICAgaWYgKCFsYXlvdXQgfHwgbGF5b3V0ICE9PSAnZmlsbCcpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCBzdGF0aWNJbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgd2lkdGggPSB3aWR0aCB8fCBzdGF0aWNJbWFnZURhdGEud2lkdGg7XG4gICAgICAgICAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5oZWlnaHQgfHwgIXN0YXRpY0ltYWdlRGF0YS53aWR0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBoZWlnaHQgYW5kIHdpZHRoLiBSZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHN0YXRpY0ltYWdlRGF0YSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3JjID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyBzcmMgOiBzdGF0aWNTcmM7XG4gICAgY29uc3Qgd2lkdGhJbnQgPSBnZXRJbnQod2lkdGgpO1xuICAgIGNvbnN0IGhlaWdodEludCA9IGdldEludChoZWlnaHQpO1xuICAgIGNvbnN0IHF1YWxpdHlJbnQgPSBnZXRJbnQocXVhbGl0eSk7XG4gICAgbGV0IGlzTGF6eSA9ICFwcmlvcml0eSAmJiAobG9hZGluZyA9PT0gJ2xhenknIHx8IHR5cGVvZiBsb2FkaW5nID09PSAndW5kZWZpbmVkJyk7XG4gICAgaWYgKHNyYy5zdGFydHNXaXRoKCdkYXRhOicpIHx8IHNyYy5zdGFydHNXaXRoKCdibG9iOicpKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUklzXG4gICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgaXNMYXp5ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBsb2FkZWRJbWFnZVVSTHMuaGFzKHNyYykpIHtcbiAgICAgICAgaXNMYXp5ID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IFtibHVyQ29tcGxldGUsIHNldEJsdXJDb21wbGV0ZV0gPSAoMCwgX3JlYWN0KS51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3NldEludGVyc2VjdGlvbiwgaXNJbnRlcnNlY3RlZCwgcmVzZXRJbnRlcnNlY3RlZF0gPSAoMCwgX3VzZUludGVyc2VjdGlvbikudXNlSW50ZXJzZWN0aW9uKHtcbiAgICAgICAgcm9vdFJlZjogbGF6eVJvb3QsXG4gICAgICAgIHJvb3RNYXJnaW46IGxhenlCb3VuZGFyeSxcbiAgICAgICAgZGlzYWJsZWQ6ICFpc0xhenlcbiAgICB9KTtcbiAgICBjb25zdCBpc1Zpc2libGUgPSAhaXNMYXp5IHx8IGlzSW50ZXJzZWN0ZWQ7XG4gICAgY29uc3Qgd3JhcHBlclN0eWxlID0ge1xuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICB3aWR0aDogJ2luaXRpYWwnLFxuICAgICAgICBoZWlnaHQ6ICdpbml0aWFsJyxcbiAgICAgICAgYmFja2dyb3VuZDogJ25vbmUnLFxuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgcGFkZGluZzogMFxuICAgIH07XG4gICAgY29uc3Qgc2l6ZXJTdHlsZSA9IHtcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgIHdpZHRoOiAnaW5pdGlhbCcsXG4gICAgICAgIGhlaWdodDogJ2luaXRpYWwnLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBwYWRkaW5nOiAwXG4gICAgfTtcbiAgICBsZXQgaGFzU2l6ZXIgPSBmYWxzZTtcbiAgICBsZXQgc2l6ZXJTdmdVcmw7XG4gICAgY29uc3QgbGF5b3V0U3R5bGUgPSB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgbWFyZ2luOiAnYXV0bycsXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIG1pbldpZHRoOiAnMTAwJScsXG4gICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgIG1pbkhlaWdodDogJzEwMCUnLFxuICAgICAgICBtYXhIZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgb2JqZWN0Rml0LFxuICAgICAgICBvYmplY3RQb3NpdGlvblxuICAgIH07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbGF5b3V0ICE9PSAncmF3JyAmJiBzdHlsZSkge31cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSBpcyBtaXNzaW5nIHJlcXVpcmVkIFwic3JjXCIgcHJvcGVydHkuIE1ha2Ugc3VyZSB5b3UgcGFzcyBcInNyY1wiIGluIHByb3BzIHRvIHRoZSBcXGBuZXh0L2ltYWdlXFxgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICBxdWFsaXR5XG4gICAgICAgICAgICB9KX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVZBTElEX0xBWU9VVF9WQUxVRVMuaW5jbHVkZXMobGF5b3V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwibGF5b3V0XCIgcHJvcGVydHkuIFByb3ZpZGVkIFwiJHtsYXlvdXR9XCIgc2hvdWxkIGJlIG9uZSBvZiAke1ZBTElEX0xBWU9VVF9WQUxVRVMubWFwKFN0cmluZykuam9pbignLCcpfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5b3V0ID09PSAncmF3JyAmJiAhZXhwZXJpbWVudGFsTGF5b3V0UmF3KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcInJhd1wiIGxheW91dCBpcyBjdXJyZW50bHkgZXhwZXJpbWVudGFsIGFuZCBtYXkgYmUgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzLiBUbyB1c2UgbGF5b3V0PVwicmF3XCIsIGluY2x1ZGUgXFxgZXhwZXJpbWVudGFsOiB7IGltYWdlczogeyBsYXlvdXRSYXc6IHRydWUgfSB9XFxgIGluIHlvdXIgbmV4dC5jb25maWcuanMgZmlsZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpZHRoSW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hTih3aWR0aEludCkgfHwgdHlwZW9mIGhlaWdodEludCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYU4oaGVpZ2h0SW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwid2lkdGhcIiBvciBcImhlaWdodFwiIHByb3BlcnR5LiBUaGVzZSBzaG91bGQgYmUgbnVtZXJpYyB2YWx1ZXMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxheW91dCA9PT0gJ2ZpbGwnICYmICh3aWR0aCB8fCBoZWlnaHQpKSB7XG4gICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBhbmQgXCJsYXlvdXQ9J2ZpbGwnXCIgaGFzIHVudXNlZCBwcm9wZXJ0aWVzIGFzc2lnbmVkLiBQbGVhc2UgcmVtb3ZlIFwid2lkdGhcIiBhbmQgXCJoZWlnaHRcIi5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVZBTElEX0xPQURJTkdfVkFMVUVTLmluY2x1ZGVzKGxvYWRpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGludmFsaWQgXCJsb2FkaW5nXCIgcHJvcGVydHkuIFByb3ZpZGVkIFwiJHtsb2FkaW5nfVwiIHNob3VsZCBiZSBvbmUgb2YgJHtWQUxJRF9MT0FESU5HX1ZBTFVFUy5tYXAoU3RyaW5nKS5qb2luKCcsJyl9LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmlvcml0eSAmJiBsb2FkaW5nID09PSAnbGF6eScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYm90aCBcInByaW9yaXR5XCIgYW5kIFwibG9hZGluZz0nbGF6eSdcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5b3V0ID09PSAncmF3JyAmJiAob2JqZWN0Rml0IHx8IG9iamVjdFBvc2l0aW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBcImxheW91dD0ncmF3J1wiIGFuZCAnb2JqZWN0Rml0JyBvciAnb2JqZWN0UG9zaXRpb24nLiBGb3IgcmF3IGltYWdlcywgdGhlc2UgYW5kIG90aGVyIHN0eWxlcyBzaG91bGQgYmUgc3BlY2lmaWVkIHVzaW5nIHRoZSAnc3R5bGUnIGF0dHJpYnV0ZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2l6ZXMgJiYgbGF5b3V0ICE9PSAnZmlsbCcgJiYgbGF5b3V0ICE9PSAncmVzcG9uc2l2ZScgJiYgbGF5b3V0ICE9PSAncmF3Jykge1xuICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIFwic2l6ZXNcIiBwcm9wZXJ0eSBidXQgaXQgd2lsbCBiZSBpZ25vcmVkLiBPbmx5IHVzZSBcInNpemVzXCIgd2l0aCBcImxheW91dD0nZmlsbCdcIiwgXCJsYXlvdXQ9J3Jlc3BvbnNpdmUnXCIsIG9yIFwibGF5b3V0PSdyYXcnYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSAnYmx1cicpIHtcbiAgICAgICAgICAgIGlmIChsYXlvdXQgIT09ICdmaWxsJyAmJiAod2lkdGhJbnQgfHwgMCkgKiAoaGVpZ2h0SW50IHx8IDApIDwgMTYwMCkge1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIHNtYWxsZXIgdGhhbiA0MHg0MC4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIFwicGxhY2Vob2xkZXI9J2JsdXInXCIgcHJvcGVydHkgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYmx1ckRhdGFVUkwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBWQUxJRF9CTFVSX0VYVCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ2pwZWcnLFxuICAgICAgICAgICAgICAgICAgICAncG5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ3dlYnAnLFxuICAgICAgICAgICAgICAgICAgICAnYXZpZidcbiAgICAgICAgICAgICAgICBdIC8vIHNob3VsZCBtYXRjaCBuZXh0LWltYWdlLWxvYWRlclxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIFwicGxhY2Vob2xkZXI9J2JsdXInXCIgcHJvcGVydHkgYnV0IGlzIG1pc3NpbmcgdGhlIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eS5cbiAgICAgICAgICBQb3NzaWJsZSBzb2x1dGlvbnM6XG4gICAgICAgICAgICAtIEFkZCBhIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eSwgdGhlIGNvbnRlbnRzIHNob3VsZCBiZSBhIHNtYWxsIERhdGEgVVJMIHRvIHJlcHJlc2VudCB0aGUgaW1hZ2VcbiAgICAgICAgICAgIC0gQ2hhbmdlIHRoZSBcInNyY1wiIHByb3BlcnR5IHRvIGEgc3RhdGljIGltcG9ydCB3aXRoIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZpbGUgdHlwZXM6ICR7VkFMSURfQkxVUl9FWFQuam9pbignLCcpfVxuICAgICAgICAgICAgLSBSZW1vdmUgdGhlIFwicGxhY2Vob2xkZXJcIiBwcm9wZXJ0eSwgZWZmZWN0aXZlbHkgbm8gYmx1ciBlZmZlY3RcbiAgICAgICAgICBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3BsYWNlaG9sZGVyLWJsdXItZGF0YS11cmxgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3JlZicgaW4gcmVzdCkge1xuICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgdXNpbmcgdW5zdXBwb3J0ZWQgXCJyZWZcIiBwcm9wZXJ0eS4gQ29uc2lkZXIgdXNpbmcgdGhlIFwib25Mb2FkaW5nQ29tcGxldGVcIiBwcm9wZXJ0eSBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgbG9hZGVyICE9PSBkZWZhdWx0SW1hZ2VMb2FkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybFN0ciA9IGxvYWRlcih7XG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGhJbnQgfHwgNDAwLFxuICAgICAgICAgICAgICAgIHF1YWxpdHk6IHF1YWxpdHlJbnQgfHwgNzVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHVybDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdXJsID0gbmV3IFVSTCh1cmxTdHIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgaWYgKHVybFN0ciA9PT0gc3JjIHx8IHVybCAmJiB1cmwucGF0aG5hbWUgPT09IHNyYyAmJiAhdXJsLnNlYXJjaCkge1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBhIFwibG9hZGVyXCIgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnQgd2lkdGguIFBsZWFzZSBpbXBsZW1lbnQgaXQgb3IgdXNlIHRoZSBcInVub3B0aW1pemVkXCIgcHJvcGVydHkgaW5zdGVhZC5gICsgYFxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS1taXNzaW5nLWxvYWRlci13aWR0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZSAmJiBsYXlvdXQgIT09ICdyYXcnKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcndyaXR0ZW5TdHlsZXMgPSBPYmplY3Qua2V5cyhzdHlsZSkuZmlsdGVyKChrZXkpPT5rZXkgaW4gbGF5b3V0U3R5bGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAob3ZlcndyaXR0ZW5TdHlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjICR7c3JjfSBpcyBhc3NpZ25lZCB0aGUgZm9sbG93aW5nIHN0eWxlcywgd2hpY2ggYXJlIG92ZXJ3cml0dGVuIGJ5IGF1dG9tYXRpY2FsbHktZ2VuZXJhdGVkIHN0eWxlczogJHtvdmVyd3JpdHRlblN0eWxlcy5qb2luKCcsICcpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhcGVyZk9ic2VydmVyICYmIHdpbmRvdy5QZXJmb3JtYW5jZU9ic2VydmVyKSB7XG4gICAgICAgICAgICBwZXJmT2JzZXJ2ZXIgPSBuZXcgUGVyZm9ybWFuY2VPYnNlcnZlcigoZW50cnlMaXN0KT0+e1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cnlMaXN0LmdldEVudHJpZXMoKSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWYxO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gbWlzc2luZyBcIkxhcmdlc3RDb250ZW50ZnVsUGFpbnRcIiBjbGFzcyB3aXRoIFwiZWxlbWVudFwiIHByb3BcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1nU3JjID0gKGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAocmVmMSA9IGVudHJ5LmVsZW1lbnQpID09PSBudWxsIHx8IHJlZjEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZjEuc3JjKSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGNwSW1hZ2UgPSBhbGxJbWdzLmdldChpbWdTcmMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGNwSW1hZ2UgJiYgIWxjcEltYWdlLnByaW9yaXR5ICYmIGxjcEltYWdlLnBsYWNlaG9sZGVyICE9PSAnYmx1cicgJiYgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKCdkYXRhOicpICYmICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aCgnYmxvYjonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93ZWIuZGV2L2xjcC8jbWVhc3VyZS1sY3AtaW4tamF2YXNjcmlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtsY3BJbWFnZS5zcmN9XCIgd2FzIGRldGVjdGVkIGFzIHRoZSBMYXJnZXN0IENvbnRlbnRmdWwgUGFpbnQgKExDUCkuIFBsZWFzZSBhZGQgdGhlIFwicHJpb3JpdHlcIiBwcm9wZXJ0eSBpZiB0aGlzIGltYWdlIGlzIGFib3ZlIHRoZSBmb2xkLmAgKyBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjcHJpb3JpdHlgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwZXJmT2JzZXJ2ZXIub2JzZXJ2ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsYXJnZXN0LWNvbnRlbnRmdWwtcGFpbnQnLFxuICAgICAgICAgICAgICAgICAgICBidWZmZXJlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9nIGVycm9yIGJ1dCBkb24ndCBjcmFzaCB0aGUgYXBwXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGltZ1N0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIGxheW91dCA9PT0gJ3JhdycgPyB7XG4gICAgICAgIGFzcGVjdFJhdGlvOiBgJHt3aWR0aEludH0gLyAke2hlaWdodEludH1gXG4gICAgfSA6IGxheW91dFN0eWxlKTtcbiAgICBjb25zdCBibHVyU3R5bGUgPSBwbGFjZWhvbGRlciA9PT0gJ2JsdXInICYmICFibHVyQ29tcGxldGUgPyB7XG4gICAgICAgIGZpbHRlcjogJ2JsdXIoMjBweCknLFxuICAgICAgICBiYWNrZ3JvdW5kU2l6ZTogb2JqZWN0Rml0IHx8ICdjb3ZlcicsXG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybChcIiR7Ymx1ckRhdGFVUkx9XCIpYCxcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBvYmplY3RQb3NpdGlvbiB8fCAnMCUgMCUnXG4gICAgfSA6IHt9O1xuICAgIGlmIChsYXlvdXQgPT09ICdmaWxsJykge1xuICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiBsYXlvdXQ9XCJmaWxsXCIgLz5cbiAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB3cmFwcGVyU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB3cmFwcGVyU3R5bGUudG9wID0gMDtcbiAgICAgICAgd3JhcHBlclN0eWxlLmxlZnQgPSAwO1xuICAgICAgICB3cmFwcGVyU3R5bGUuYm90dG9tID0gMDtcbiAgICAgICAgd3JhcHBlclN0eWxlLnJpZ2h0ID0gMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aWR0aEludCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGhlaWdodEludCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiAvPlxuICAgICAgICBjb25zdCBxdW90aWVudCA9IGhlaWdodEludCAvIHdpZHRoSW50O1xuICAgICAgICBjb25zdCBwYWRkaW5nVG9wID0gaXNOYU4ocXVvdGllbnQpID8gJzEwMCUnIDogYCR7cXVvdGllbnQgKiAxMDB9JWA7XG4gICAgICAgIGlmIChsYXlvdXQgPT09ICdyZXNwb25zaXZlJykge1xuICAgICAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiBsYXlvdXQ9XCJyZXNwb25zaXZlXCIgLz5cbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICBoYXNTaXplciA9IHRydWU7XG4gICAgICAgICAgICBzaXplclN0eWxlLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wO1xuICAgICAgICB9IGVsc2UgaWYgKGxheW91dCA9PT0gJ2ludHJpbnNpYycpIHtcbiAgICAgICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgbGF5b3V0PVwiaW50cmluc2ljXCIgLz5cbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLm1heFdpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgaGFzU2l6ZXIgPSB0cnVlO1xuICAgICAgICAgICAgc2l6ZXJTdHlsZS5tYXhXaWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgIHNpemVyU3ZnVXJsID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbCwlM2NzdmclMjB4bWxucz0lMjdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyUyNyUyMHZlcnNpb249JTI3MS4xJTI3JTIwd2lkdGg9JTI3JHt3aWR0aEludH0lMjclMjBoZWlnaHQ9JTI3JHtoZWlnaHRJbnR9JTI3LyUzZWA7XG4gICAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIGxheW91dD1cImZpeGVkXCIgLz5cbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLndpZHRoID0gd2lkdGhJbnQ7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0SW50O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgLz5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBtdXN0IHVzZSBcIndpZHRoXCIgYW5kIFwiaGVpZ2h0XCIgcHJvcGVydGllcyBvciBcImxheW91dD0nZmlsbCdcIiBwcm9wZXJ0eS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgaW1nQXR0cmlidXRlcyA9IHtcbiAgICAgICAgc3JjOiBlbXB0eURhdGFVUkwsXG4gICAgICAgIHNyY1NldDogdW5kZWZpbmVkLFxuICAgICAgICBzaXplczogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgICAgIGltZ0F0dHJpYnV0ZXMgPSBnZW5lcmF0ZUltZ0F0dHJzKHtcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoSW50LFxuICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCxcbiAgICAgICAgICAgIHNpemVzLFxuICAgICAgICAgICAgbG9hZGVyXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgc3JjU3RyaW5nID0gc3JjO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbGV0IGZ1bGxVcmw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZ1bGxVcmwgPSBuZXcgVVJMKGltZ0F0dHJpYnV0ZXMuc3JjKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYywgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsSW1ncy5zZXQoZnVsbFVybC5ocmVmLCB7XG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgaW1hZ2VTcmNTZXRQcm9wTmFtZSA9ICdpbWFnZXNyY3NldCc7XG4gICAgbGV0IGltYWdlU2l6ZXNQcm9wTmFtZSA9ICdpbWFnZXNpemVzJztcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1JFQUNUX1JPT1QpIHtcbiAgICAgICAgaW1hZ2VTcmNTZXRQcm9wTmFtZSA9ICdpbWFnZVNyY1NldCc7XG4gICAgICAgIGltYWdlU2l6ZXNQcm9wTmFtZSA9ICdpbWFnZVNpemVzJztcbiAgICB9XG4gICAgY29uc3QgbGlua1Byb3BzID0ge1xuICAgICAgICAvLyBOb3RlOiBpbWFnZXNyY3NldCBhbmQgaW1hZ2VzaXplcyBhcmUgbm90IGluIHRoZSBsaW5rIGVsZW1lbnQgdHlwZSB3aXRoIHJlYWN0IDE3LlxuICAgICAgICBbaW1hZ2VTcmNTZXRQcm9wTmFtZV06IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgICAgICBbaW1hZ2VTaXplc1Byb3BOYW1lXTogaW1nQXR0cmlidXRlcy5zaXplc1xuICAgIH07XG4gICAgY29uc3QgdXNlTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBfcmVhY3QuZGVmYXVsdC51c2VFZmZlY3QgOiBfcmVhY3QuZGVmYXVsdC51c2VMYXlvdXRFZmZlY3Q7XG4gICAgY29uc3Qgb25Mb2FkaW5nQ29tcGxldGVSZWYgPSAoMCwgX3JlYWN0KS51c2VSZWYob25Mb2FkaW5nQ29tcGxldGUpO1xuICAgIGNvbnN0IHByZXZpb3VzSW1hZ2VTcmMgPSAoMCwgX3JlYWN0KS51c2VSZWYoc3JjKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYuY3VycmVudCA9IG9uTG9hZGluZ0NvbXBsZXRlO1xuICAgIH0sIFtcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVcbiAgICBdKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKHByZXZpb3VzSW1hZ2VTcmMuY3VycmVudCAhPT0gc3JjKSB7XG4gICAgICAgICAgICByZXNldEludGVyc2VjdGVkKCk7XG4gICAgICAgICAgICBwcmV2aW91c0ltYWdlU3JjLmN1cnJlbnQgPSBzcmM7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHJlc2V0SW50ZXJzZWN0ZWQsXG4gICAgICAgIHNyY1xuICAgIF0pO1xuICAgIGNvbnN0IGltZ0VsZW1lbnRBcmdzID0gX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGlzTGF6eSxcbiAgICAgICAgaW1nQXR0cmlidXRlcyxcbiAgICAgICAgaGVpZ2h0SW50LFxuICAgICAgICB3aWR0aEludCxcbiAgICAgICAgcXVhbGl0eUludCxcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIGltZ1N0eWxlLFxuICAgICAgICBibHVyU3R5bGUsXG4gICAgICAgIGxvYWRpbmcsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICBsb2FkZXIsXG4gICAgICAgIHNyY1N0cmluZyxcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgICAgc2V0SW50ZXJzZWN0aW9uLFxuICAgICAgICBpc1Zpc2libGVcbiAgICB9LCByZXN0KTtcbiAgICByZXR1cm4oLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBsYXlvdXQgPT09ICdyYXcnID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEltYWdlRWxlbWVudCwgT2JqZWN0LmFzc2lnbih7fSwgaW1nRWxlbWVudEFyZ3MpKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBzdHlsZTogd3JhcHBlclN0eWxlXG4gICAgfSwgaGFzU2l6ZXIgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgc3R5bGU6IHNpemVyU3R5bGVcbiAgICB9LCBzaXplclN2Z1VybCA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIHdpZHRoOiAnaW5pdGlhbCcsXG4gICAgICAgICAgICBoZWlnaHQ6ICdpbml0aWFsJyxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGFsdDogXCJcIixcbiAgICAgICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgICAgICBzcmM6IHNpemVyU3ZnVXJsXG4gICAgfSkgOiBudWxsKSA6IG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChJbWFnZUVsZW1lbnQsIE9iamVjdC5hc3NpZ24oe30sIGltZ0VsZW1lbnRBcmdzKSkpLCBwcmlvcml0eSA/IC8vIE5vdGUgaG93IHdlIG9taXQgdGhlIGBocmVmYCBhdHRyaWJ1dGUsIGFzIGl0IHdvdWxkIG9ubHkgYmUgcmVsZXZhbnRcbiAgICAvLyBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBgaW1hZ2VzcmNzZXRgLCBhbmQgaW4gdGhvc2UgY2FzZXNcbiAgICAvLyBpdCB3b3VsZCBsaWtlbHkgY2F1c2UgdGhlIGluY29ycmVjdCBpbWFnZSB0byBiZSBwcmVsb2FkZWQuXG4gICAgLy9cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCNhdHRyLWxpbmstaW1hZ2VzcmNzZXRcbiAgICAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hlYWQuZGVmYXVsdCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibGlua1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAga2V5OiAnX19uaW1nLScgKyBpbWdBdHRyaWJ1dGVzLnNyYyArIGltZ0F0dHJpYnV0ZXMuc3JjU2V0ICsgaW1nQXR0cmlidXRlcy5zaXplcyxcbiAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgYXM6IFwiaW1hZ2VcIixcbiAgICAgICAgaHJlZjogaW1nQXR0cmlidXRlcy5zcmNTZXQgPyB1bmRlZmluZWQgOiBpbWdBdHRyaWJ1dGVzLnNyY1xuICAgIH0sIGxpbmtQcm9wcykpKSA6IG51bGwpKTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7XG4gICAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXdPYmogPSB7fTtcbiAgICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBvYmope1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgICB2YXIga2V5LCBpO1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG4gICAgZm9yKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG52YXIgcmVmO1xuY29uc3QgZXhwZXJpbWVudGFsTGF5b3V0UmF3ID0gKHJlZiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5leHBlcmltZW50YWxMYXlvdXRSYXc7XG5jb25zdCBjb25maWdFbnYgPSBwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUztcbmNvbnN0IGxvYWRlZEltYWdlVVJMcyA9IG5ldyBTZXQoKTtcbmNvbnN0IGFsbEltZ3MgPSBuZXcgTWFwKCk7XG5sZXQgcGVyZk9ic2VydmVyO1xuY29uc3QgZW1wdHlEYXRhVVJMID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBNyc7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBnbG9iYWwuX19ORVhUX0lNQUdFX0lNUE9SVEVEID0gdHJ1ZTtcbn1cbmNvbnN0IFZBTElEX0xPQURJTkdfVkFMVUVTID0gW1xuICAgICdsYXp5JyxcbiAgICAnZWFnZXInLFxuICAgIHVuZGVmaW5lZFxuXTtcbmNvbnN0IGxvYWRlcnMgPSBuZXcgTWFwKFtcbiAgICBbXG4gICAgICAgICdkZWZhdWx0JyxcbiAgICAgICAgZGVmYXVsdExvYWRlclxuICAgIF0sXG4gICAgW1xuICAgICAgICAnaW1naXgnLFxuICAgICAgICBpbWdpeExvYWRlclxuICAgIF0sXG4gICAgW1xuICAgICAgICAnY2xvdWRpbmFyeScsXG4gICAgICAgIGNsb3VkaW5hcnlMb2FkZXJcbiAgICBdLFxuICAgIFtcbiAgICAgICAgJ2FrYW1haScsXG4gICAgICAgIGFrYW1haUxvYWRlclxuICAgIF0sXG4gICAgW1xuICAgICAgICAnY3VzdG9tJyxcbiAgICAgICAgY3VzdG9tTG9hZGVyXG4gICAgXSwgXG5dKTtcbmNvbnN0IFZBTElEX0xBWU9VVF9WQUxVRVMgPSBbXG4gICAgJ2ZpbGwnLFxuICAgICdmaXhlZCcsXG4gICAgJ2ludHJpbnNpYycsXG4gICAgJ3Jlc3BvbnNpdmUnLFxuICAgICdyYXcnLFxuICAgIHVuZGVmaW5lZCwgXG5dO1xuZnVuY3Rpb24gaXNTdGF0aWNSZXF1aXJlKHNyYykge1xuICAgIHJldHVybiBzcmMuZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNTdGF0aWNJbWFnZURhdGEoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5zcmMgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzU3RhdGljSW1wb3J0KHNyYykge1xuICAgIHJldHVybiB0eXBlb2Ygc3JjID09PSAnb2JqZWN0JyAmJiAoaXNTdGF0aWNSZXF1aXJlKHNyYykgfHwgaXNTdGF0aWNJbWFnZURhdGEoc3JjKSk7XG59XG5mdW5jdGlvbiBnZXRXaWR0aHMoeyBkZXZpY2VTaXplcyAsIGFsbFNpemVzICB9LCB3aWR0aCwgbGF5b3V0LCBzaXplcykge1xuICAgIGlmIChzaXplcyAmJiAobGF5b3V0ID09PSAnZmlsbCcgfHwgbGF5b3V0ID09PSAncmVzcG9uc2l2ZScgfHwgbGF5b3V0ID09PSAncmF3JykpIHtcbiAgICAgICAgLy8gRmluZCBhbGwgdGhlIFwidndcIiBwZXJjZW50IHNpemVzIHVzZWQgaW4gdGhlIHNpemVzIHByb3BcbiAgICAgICAgY29uc3Qgdmlld3BvcnRXaWR0aFJlID0gLyhefFxccykoMT9cXGQ/XFxkKXZ3L2c7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRTaXplcyA9IFtdO1xuICAgICAgICBmb3IobGV0IG1hdGNoOyBtYXRjaCA9IHZpZXdwb3J0V2lkdGhSZS5leGVjKHNpemVzKTsgbWF0Y2gpe1xuICAgICAgICAgICAgcGVyY2VudFNpemVzLnB1c2gocGFyc2VJbnQobWF0Y2hbMl0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVyY2VudFNpemVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc21hbGxlc3RSYXRpbyA9IE1hdGgubWluKC4uLnBlcmNlbnRTaXplcykgKiAwLjAxO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aHM6IGFsbFNpemVzLmZpbHRlcigocyk9PnMgPj0gZGV2aWNlU2l6ZXNbMF0gKiBzbWFsbGVzdFJhdGlvXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBraW5kOiAndydcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoczogYWxsU2l6ZXMsXG4gICAgICAgICAgICBraW5kOiAndydcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicgfHwgbGF5b3V0ID09PSAnZmlsbCcgfHwgbGF5b3V0ID09PSAncmVzcG9uc2l2ZScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoczogZGV2aWNlU2l6ZXMsXG4gICAgICAgICAgICBraW5kOiAndydcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGhzID0gW1xuICAgICAgICAuLi5uZXcgU2V0KC8vID4gVGhpcyBtZWFucyB0aGF0IG1vc3QgT0xFRCBzY3JlZW5zIHRoYXQgc2F5IHRoZXkgYXJlIDN4IHJlc29sdXRpb24sXG4gICAgICAgIC8vID4gYXJlIGFjdHVhbGx5IDN4IGluIHRoZSBncmVlbiBjb2xvciwgYnV0IG9ubHkgMS41eCBpbiB0aGUgcmVkIGFuZFxuICAgICAgICAvLyA+IGJsdWUgY29sb3JzLiBTaG93aW5nIGEgM3ggcmVzb2x1dGlvbiBpbWFnZSBpbiB0aGUgYXBwIHZzIGEgMnhcbiAgICAgICAgLy8gPiByZXNvbHV0aW9uIGltYWdlIHdpbGwgYmUgdmlzdWFsbHkgdGhlIHNhbWUsIHRob3VnaCB0aGUgM3ggaW1hZ2VcbiAgICAgICAgLy8gPiB0YWtlcyBzaWduaWZpY2FudGx5IG1vcmUgZGF0YS4gRXZlbiB0cnVlIDN4IHJlc29sdXRpb24gc2NyZWVucyBhcmVcbiAgICAgICAgLy8gPiB3YXN0ZWZ1bCBhcyB0aGUgaHVtYW4gZXllIGNhbm5vdCBzZWUgdGhhdCBsZXZlbCBvZiBkZXRhaWwgd2l0aG91dFxuICAgICAgICAvLyA+IHNvbWV0aGluZyBsaWtlIGEgbWFnbmlmeWluZyBnbGFzcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9ibG9nLnR3aXR0ZXIuY29tL2VuZ2luZWVyaW5nL2VuX3VzL3RvcGljcy9pbmZyYXN0cnVjdHVyZS8yMDE5L2NhcHBpbmctaW1hZ2UtZmlkZWxpdHktb24tdWx0cmEtaGlnaC1yZXNvbHV0aW9uLWRldmljZXMuaHRtbFxuICAgICAgICBbXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIHdpZHRoICogMiAvKiwgd2lkdGggKiAzKi8gXG4gICAgICAgIF0ubWFwKCh3KT0+YWxsU2l6ZXMuZmluZCgocCk9PnAgPj0gd1xuICAgICAgICAgICAgKSB8fCBhbGxTaXplc1thbGxTaXplcy5sZW5ndGggLSAxXVxuICAgICAgICApKSwgXG4gICAgXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aHMsXG4gICAgICAgIGtpbmQ6ICd4J1xuICAgIH07XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltZ0F0dHJzKHsgY29uZmlnICwgc3JjICwgdW5vcHRpbWl6ZWQgLCBsYXlvdXQgLCB3aWR0aCAsIHF1YWxpdHkgLCBzaXplcyAsIGxvYWRlciAgfSkge1xuICAgIGlmICh1bm9wdGltaXplZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgc3JjU2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaXplczogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHsgd2lkdGhzICwga2luZCAgfSA9IGdldFdpZHRocyhjb25maWcsIHdpZHRoLCBsYXlvdXQsIHNpemVzKTtcbiAgICBjb25zdCBsYXN0ID0gd2lkdGhzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZXM6ICFzaXplcyAmJiBraW5kID09PSAndycgPyAnMTAwdncnIDogc2l6ZXMsXG4gICAgICAgIHNyY1NldDogd2lkdGhzLm1hcCgodywgaSk9PmAke2xvYWRlcih7XG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICBxdWFsaXR5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3XG4gICAgICAgICAgICB9KX0gJHtraW5kID09PSAndycgPyB3IDogaSArIDF9JHtraW5kfWBcbiAgICAgICAgKS5qb2luKCcsICcpLFxuICAgICAgICAvLyBJdCdzIGludGVuZGVkIHRvIGtlZXAgYHNyY2AgdGhlIGxhc3QgYXR0cmlidXRlIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgICAgICAvLyBhdHRyaWJ1dGVzIGluIG9yZGVyLiBJZiB3ZSBrZWVwIGBzcmNgIHRoZSBmaXJzdCBvbmUsIFNhZmFyaSB3aWxsXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IHN0YXJ0IHRvIGZldGNoIGBzcmNgLCBiZWZvcmUgYHNpemVzYCBhbmQgYHNyY1NldGAgYXJlIGV2ZW5cbiAgICAgICAgLy8gdXBkYXRlZCBieSBSZWFjdC4gVGhhdCBjYXVzZXMgbXVsdGlwbGUgdW5uZWNlc3NhcnkgcmVxdWVzdHMgaWYgYHNyY1NldGBcbiAgICAgICAgLy8gYW5kIGBzaXplc2AgYXJlIGRlZmluZWQuXG4gICAgICAgIC8vIFRoaXMgYnVnIGNhbm5vdCBiZSByZXByb2R1Y2VkIGluIENocm9tZSBvciBGaXJlZm94LlxuICAgICAgICBzcmM6IGxvYWRlcih7XG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICBxdWFsaXR5LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoc1tsYXN0XVxuICAgICAgICB9KVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRJbnQoeCkge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHgsIDEwKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRJbWFnZUxvYWRlcihsb2FkZXJQcm9wcykge1xuICAgIHZhciByZWYyO1xuICAgIGNvbnN0IGxvYWRlcktleSA9ICgocmVmMiA9IGxvYWRlclByb3BzLmNvbmZpZykgPT09IG51bGwgfHwgcmVmMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmMi5sb2FkZXIpIHx8ICdkZWZhdWx0JztcbiAgICBjb25zdCBsb2FkID0gbG9hZGVycy5nZXQobG9hZGVyS2V5KTtcbiAgICBpZiAobG9hZCkge1xuICAgICAgICByZXR1cm4gbG9hZChsb2FkZXJQcm9wcyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBcImxvYWRlclwiIGZvdW5kIGluIFwibmV4dC5jb25maWcuanNcIi4gRXhwZWN0ZWQ6ICR7X2ltYWdlQ29uZmlnLlZBTElEX0xPQURFUlMuam9pbignLCAnKX0uIFJlY2VpdmVkOiAke2xvYWRlcktleX1gKTtcbn1cbi8vIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzk3Nzc4MzMvMjY2NTM1IGZvciB3aHkgd2UgdXNlIHRoaXMgcmVmXG4vLyBoYW5kbGVyIGluc3RlYWQgb2YgdGhlIGltZydzIG9uTG9hZCBhdHRyaWJ1dGUuXG5mdW5jdGlvbiBoYW5kbGVMb2FkaW5nKGltZywgc3JjLCBsYXlvdXQsIHBsYWNlaG9sZGVyLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlKSB7XG4gICAgaWYgKCFpbWcgfHwgaW1nLnNyYyA9PT0gZW1wdHlEYXRhVVJMIHx8IGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPT09IHNyYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPSBzcmM7XG4gICAgY29uc3QgcCA9ICdkZWNvZGUnIGluIGltZyA/IGltZy5kZWNvZGUoKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHAuY2F0Y2goKCk9Pnt9KS50aGVuKCgpPT57XG4gICAgICAgIGlmICghaW1nLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaW4gY2FzZSBvZiByYWNlIGNvbmRpdGlvbjpcbiAgICAgICAgICAgIC8vIC0gb25sb2FkKCkgaXMgY2FsbGVkXG4gICAgICAgICAgICAvLyAtIGRlY29kZSgpIGlzIGNhbGxlZCBidXQgaW5jb21wbGV0ZVxuICAgICAgICAgICAgLy8gLSB1bm1vdW50IGlzIGNhbGxlZFxuICAgICAgICAgICAgLy8gLSBkZWNvZGUoKSBjb21wbGV0ZXNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZWRJbWFnZVVSTHMuYWRkKHNyYyk7XG4gICAgICAgIGlmIChwbGFjZWhvbGRlciA9PT0gJ2JsdXInKSB7XG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTG9hZGluZ0NvbXBsZXRlUmVmID09PSBudWxsIHx8IG9uTG9hZGluZ0NvbXBsZXRlUmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hdHVyYWxXaWR0aCAsIG5hdHVyYWxIZWlnaHQgIH0gPSBpbWc7XG4gICAgICAgICAgICAvLyBQYXNzIGJhY2sgcmVhZC1vbmx5IHByaW1pdGl2ZSB2YWx1ZXMgYnV0IG5vdCB0aGVcbiAgICAgICAgICAgIC8vIHVuZGVybHlpbmcgRE9NIGVsZW1lbnQgYmVjYXVzZSBpdCBjb3VsZCBiZSBtaXN1c2VkLlxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYuY3VycmVudCh7XG4gICAgICAgICAgICAgICAgbmF0dXJhbFdpZHRoLFxuICAgICAgICAgICAgICAgIG5hdHVyYWxIZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgcmVmMztcbiAgICAgICAgICAgIGlmICgocmVmMyA9IGltZy5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCByZWYzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYzLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBnZXRDb21wdXRlZFN0eWxlKGltZy5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50LnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHBhcmVudCBoYXMgbm90IGJlZW4gcmVuZGVyZWQgdG8gdGhlIGRvbSB5ZXQgYW5kIHRoZXJlZm9yZSBpdCBoYXMgbm8gcG9zaXRpb24uIFNraXAgdGhlIHdhcm5pbmdzIGZvciBzdWNoIGNhc2VzLlxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSAncmVzcG9uc2l2ZScgJiYgcGFyZW50LmRpc3BsYXkgPT09ICdmbGV4Jykge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBtYXkgbm90IHJlbmRlciBwcm9wZXJseSBhcyBhIGNoaWxkIG9mIGEgZmxleCBjb250YWluZXIuIENvbnNpZGVyIHdyYXBwaW5nIHRoZSBpbWFnZSB3aXRoIGEgZGl2IHRvIGNvbmZpZ3VyZSB0aGUgd2lkdGguYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXlvdXQgPT09ICdmaWxsJyAmJiBwYXJlbnQucG9zaXRpb24gIT09ICdyZWxhdGl2ZScgJiYgcGFyZW50LnBvc2l0aW9uICE9PSAnZml4ZWQnICYmIHBhcmVudC5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJykge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBtYXkgbm90IHJlbmRlciBwcm9wZXJseSB3aXRoIGEgcGFyZW50IHVzaW5nIHBvc2l0aW9uOlwiJHtwYXJlbnQucG9zaXRpb259XCIuIENvbnNpZGVyIGNoYW5naW5nIHRoZSBwYXJlbnQgc3R5bGUgdG8gcG9zaXRpb246XCJyZWxhdGl2ZVwiIHdpdGggYSB3aWR0aCBhbmQgaGVpZ2h0LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgSW1hZ2VFbGVtZW50ID0gKF9wYXJhbSk9PntcbiAgICB2YXIgeyBpbWdBdHRyaWJ1dGVzICwgaGVpZ2h0SW50ICwgd2lkdGhJbnQgLCBxdWFsaXR5SW50ICwgbGF5b3V0ICwgY2xhc3NOYW1lICwgaW1nU3R5bGUgLCBibHVyU3R5bGUgLCBpc0xhenkgLCBwbGFjZWhvbGRlciAsIGxvYWRpbmcgLCBzcmNTdHJpbmcgLCBjb25maWcgLCB1bm9wdGltaXplZCAsIGxvYWRlciAsIG9uTG9hZGluZ0NvbXBsZXRlUmVmICwgc2V0Qmx1ckNvbXBsZXRlICwgc2V0SW50ZXJzZWN0aW9uICwgb25FcnJvciAsIGlzVmlzaWJsZSAgfSA9IF9wYXJhbSwgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcGFyYW0sIFtcbiAgICAgICAgXCJpbWdBdHRyaWJ1dGVzXCIsXG4gICAgICAgIFwiaGVpZ2h0SW50XCIsXG4gICAgICAgIFwid2lkdGhJbnRcIixcbiAgICAgICAgXCJxdWFsaXR5SW50XCIsXG4gICAgICAgIFwibGF5b3V0XCIsXG4gICAgICAgIFwiY2xhc3NOYW1lXCIsXG4gICAgICAgIFwiaW1nU3R5bGVcIixcbiAgICAgICAgXCJibHVyU3R5bGVcIixcbiAgICAgICAgXCJpc0xhenlcIixcbiAgICAgICAgXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICBcImxvYWRpbmdcIixcbiAgICAgICAgXCJzcmNTdHJpbmdcIixcbiAgICAgICAgXCJjb25maWdcIixcbiAgICAgICAgXCJ1bm9wdGltaXplZFwiLFxuICAgICAgICBcImxvYWRlclwiLFxuICAgICAgICBcIm9uTG9hZGluZ0NvbXBsZXRlUmVmXCIsXG4gICAgICAgIFwic2V0Qmx1ckNvbXBsZXRlXCIsXG4gICAgICAgIFwic2V0SW50ZXJzZWN0aW9uXCIsXG4gICAgICAgIFwib25FcnJvclwiLFxuICAgICAgICBcImlzVmlzaWJsZVwiXG4gICAgXSk7XG4gICAgcmV0dXJuKC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIE9iamVjdC5hc3NpZ24oe30sIHJlc3QsIGltZ0F0dHJpYnV0ZXMsIGxheW91dCA9PT0gJ3JhdycgJiYgIWltZ0F0dHJpYnV0ZXMuc2l6ZXMgPyB7XG4gICAgICAgIGhlaWdodDogaGVpZ2h0SW50LFxuICAgICAgICB3aWR0aDogd2lkdGhJbnRcbiAgICB9IDoge30sIHtcbiAgICAgICAgZGVjb2Rpbmc6IFwiYXN5bmNcIixcbiAgICAgICAgXCJkYXRhLW5pbWdcIjogbGF5b3V0LFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoe30sIGltZ1N0eWxlLCBibHVyU3R5bGUpLFxuICAgICAgICByZWY6ICgwLCBfcmVhY3QpLnVzZUNhbGxiYWNrKChpbWcpPT57XG4gICAgICAgICAgICBzZXRJbnRlcnNlY3Rpb24oaW1nKTtcbiAgICAgICAgICAgIGlmIChpbWcgPT09IG51bGwgfHwgaW1nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbWcuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVMb2FkaW5nKGltZywgc3JjU3RyaW5nLCBsYXlvdXQsIHBsYWNlaG9sZGVyLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW1xuICAgICAgICAgICAgc2V0SW50ZXJzZWN0aW9uLFxuICAgICAgICAgICAgc3JjU3RyaW5nLFxuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSwgXG4gICAgICAgIF0pLFxuICAgICAgICBvbkxvYWQ6IChldmVudCk9PntcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBoYW5kbGVMb2FkaW5nKGltZywgc3JjU3RyaW5nLCBsYXlvdXQsIHBsYWNlaG9sZGVyLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogKGV2ZW50KT0+e1xuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSAnYmx1cicpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVhbCBpbWFnZSBmYWlscyB0byBsb2FkLCB0aGlzIHdpbGwgc3RpbGwgcmVtb3ZlIHRoZSBwbGFjZWhvbGRlci5cbiAgICAgICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkpLCAoaXNMYXp5IHx8IHBsYWNlaG9sZGVyID09PSAnYmx1cicpICYmIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcIm5vc2NyaXB0XCIsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLCBPYmplY3QuYXNzaWduKHt9LCByZXN0LCBnZW5lcmF0ZUltZ0F0dHJzKHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBzcmM6IHNyY1N0cmluZyxcbiAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgd2lkdGg6IHdpZHRoSW50LFxuICAgICAgICBxdWFsaXR5OiBxdWFsaXR5SW50LFxuICAgICAgICBzaXplczogaW1nQXR0cmlidXRlcy5zaXplcyxcbiAgICAgICAgbG9hZGVyXG4gICAgfSksIGxheW91dCA9PT0gJ3JhdycgJiYgIWltZ0F0dHJpYnV0ZXMuc2l6ZXMgPyB7XG4gICAgICAgIGhlaWdodDogaGVpZ2h0SW50LFxuICAgICAgICB3aWR0aDogd2lkdGhJbnRcbiAgICB9IDoge30sIHtcbiAgICAgICAgZGVjb2Rpbmc6IFwiYXN5bmNcIixcbiAgICAgICAgXCJkYXRhLW5pbWdcIjogbGF5b3V0LFxuICAgICAgICBzdHlsZTogaW1nU3R5bGUsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICAvLyBAdHMtaWdub3JlIC0gVE9ETzogdXBncmFkZSB0byBgQHR5cGVzL3JlYWN0QDE3YFxuICAgICAgICBsb2FkaW5nOiBsb2FkaW5nIHx8ICdsYXp5J1xuICAgIH0pKSkpKTtcbn07XG5mdW5jdGlvbiBub3JtYWxpemVTcmMoc3JjKSB7XG4gICAgcmV0dXJuIHNyY1swXSA9PT0gJy8nID8gc3JjLnNsaWNlKDEpIDogc3JjO1xufVxuZnVuY3Rpb24gaW1naXhMb2FkZXIoeyBjb25maWcgLCBzcmMgLCB3aWR0aCAsIHF1YWxpdHkgIH0pIHtcbiAgICAvLyBEZW1vOiBodHRwczovL3N0YXRpYy5pbWdpeC5uZXQvZGFpc3kucG5nP2F1dG89Zm9ybWF0JmZpdD1tYXgmdz0zMDBcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke2NvbmZpZy5wYXRofSR7bm9ybWFsaXplU3JjKHNyYyl9YCk7XG4gICAgY29uc3QgcGFyYW1zID0gdXJsLnNlYXJjaFBhcmFtcztcbiAgICBwYXJhbXMuc2V0KCdhdXRvJywgcGFyYW1zLmdldCgnYXV0bycpIHx8ICdmb3JtYXQnKTtcbiAgICBwYXJhbXMuc2V0KCdmaXQnLCBwYXJhbXMuZ2V0KCdmaXQnKSB8fCAnbWF4Jyk7XG4gICAgcGFyYW1zLnNldCgndycsIHBhcmFtcy5nZXQoJ3cnKSB8fCB3aWR0aC50b1N0cmluZygpKTtcbiAgICBpZiAocXVhbGl0eSkge1xuICAgICAgICBwYXJhbXMuc2V0KCdxJywgcXVhbGl0eS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybC5ocmVmO1xufVxuZnVuY3Rpb24gYWthbWFpTG9hZGVyKHsgY29uZmlnICwgc3JjICwgd2lkdGggIH0pIHtcbiAgICByZXR1cm4gYCR7Y29uZmlnLnBhdGh9JHtub3JtYWxpemVTcmMoc3JjKX0/aW13aWR0aD0ke3dpZHRofWA7XG59XG5mdW5jdGlvbiBjbG91ZGluYXJ5TG9hZGVyKHsgY29uZmlnICwgc3JjICwgd2lkdGggLCBxdWFsaXR5ICB9KSB7XG4gICAgLy8gRGVtbzogaHR0cHM6Ly9yZXMuY2xvdWRpbmFyeS5jb20vZGVtby9pbWFnZS91cGxvYWQvd18zMDAsY19saW1pdCxxX2F1dG8vdHVydGxlcy5qcGdcbiAgICBjb25zdCBwYXJhbXMgPSBbXG4gICAgICAgICdmX2F1dG8nLFxuICAgICAgICAnY19saW1pdCcsXG4gICAgICAgICd3XycgKyB3aWR0aCxcbiAgICAgICAgJ3FfJyArIChxdWFsaXR5IHx8ICdhdXRvJylcbiAgICBdO1xuICAgIGNvbnN0IHBhcmFtc1N0cmluZyA9IHBhcmFtcy5qb2luKCcsJykgKyAnLyc7XG4gICAgcmV0dXJuIGAke2NvbmZpZy5wYXRofSR7cGFyYW1zU3RyaW5nfSR7bm9ybWFsaXplU3JjKHNyYyl9YDtcbn1cbmZ1bmN0aW9uIGN1c3RvbUxvYWRlcih7IHNyYyAgfSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyBtaXNzaW5nIFwibG9hZGVyXCIgcHJvcC5gICsgYFxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS1taXNzaW5nLWxvYWRlcmApO1xufVxuZnVuY3Rpb24gZGVmYXVsdExvYWRlcih7IGNvbmZpZyAsIHNyYyAsIHdpZHRoICwgcXVhbGl0eSAgfSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdWYWx1ZXMgPSBbXTtcbiAgICAgICAgLy8gdGhlc2Ugc2hvdWxkIGFsd2F5cyBiZSBwcm92aWRlZCBidXQgbWFrZSBzdXJlIHRoZXkgYXJlXG4gICAgICAgIGlmICghc3JjKSBtaXNzaW5nVmFsdWVzLnB1c2goJ3NyYycpO1xuICAgICAgICBpZiAoIXdpZHRoKSBtaXNzaW5nVmFsdWVzLnB1c2goJ3dpZHRoJyk7XG4gICAgICAgIGlmIChtaXNzaW5nVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTmV4dCBJbWFnZSBPcHRpbWl6YXRpb24gcmVxdWlyZXMgJHttaXNzaW5nVmFsdWVzLmpvaW4oJywgJyl9IHRvIGJlIHByb3ZpZGVkLiBNYWtlIHN1cmUgeW91IHBhc3MgdGhlbSBhcyBwcm9wcyB0byB0aGUgXFxgbmV4dC9pbWFnZVxcYCBjb21wb25lbnQuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgcXVhbGl0eVxuICAgICAgICAgICAgfSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzcmMgXCIke3NyY31cIiBvbiBcXGBuZXh0L2ltYWdlXFxgLCBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgKC8vKSBtdXN0IGJlIGNoYW5nZWQgdG8gYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3JjLnN0YXJ0c1dpdGgoJy8nKSAmJiBjb25maWcuZG9tYWlucykge1xuICAgICAgICAgICAgbGV0IHBhcnNlZFNyYztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkU3JjID0gbmV3IFVSTChzcmMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHNyYyBcIiR7c3JjfVwiIG9uIFxcYG5leHQvaW1hZ2VcXGAsIGlmIHVzaW5nIHJlbGF0aXZlIGltYWdlIGl0IG11c3Qgc3RhcnQgd2l0aCBhIGxlYWRpbmcgc2xhc2ggXCIvXCIgb3IgYmUgYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiYgIWNvbmZpZy5kb21haW5zLmluY2x1ZGVzKHBhcnNlZFNyYy5ob3N0bmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3JjIHByb3AgKCR7c3JjfSkgb24gXFxgbmV4dC9pbWFnZVxcYCwgaG9zdG5hbWUgXCIke3BhcnNlZFNyYy5ob3N0bmFtZX1cIiBpcyBub3QgY29uZmlndXJlZCB1bmRlciBpbWFnZXMgaW4geW91ciBcXGBuZXh0LmNvbmZpZy5qc1xcYFxcbmAgKyBgU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS11bmNvbmZpZ3VyZWQtaG9zdGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzcmMuZW5kc1dpdGgoJy5zdmcnKSAmJiAhY29uZmlnLmRhbmdlcm91c2x5QWxsb3dTVkcpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIG1ha2Ugc3ZnIHNlcnZlIGFzLWlzIHRvIGF2b2lkIHByb3h5aW5nXG4gICAgICAgIC8vIHRocm91Z2ggdGhlIGJ1aWx0LWluIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxuICAgIHJldHVybiBgJHsoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGNvbmZpZy5wYXRoKX0/dXJsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHNyYyl9Jnc9JHt3aWR0aH0mcT0ke3F1YWxpdHkgfHwgNzV9YDtcbn1cblxuaWYgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpIHtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIkltYWdlIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX2hlYWQiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2ltYWdlQ29uZmlnIiwiX3VzZUludGVyc2VjdGlvbiIsIl9pbWFnZUNvbmZpZ0NvbnRleHQiLCJfdXRpbHMiLCJfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCIsIl9wYXJhbSIsInNyYyIsInNpemVzIiwidW5vcHRpbWl6ZWQiLCJwcmlvcml0eSIsImxvYWRpbmciLCJsYXp5Um9vdCIsImxhenlCb3VuZGFyeSIsImNsYXNzTmFtZSIsInF1YWxpdHkiLCJ3aWR0aCIsImhlaWdodCIsInN0eWxlIiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJvbkxvYWRpbmdDb21wbGV0ZSIsIm9uRXJyb3IiLCJwbGFjZWhvbGRlciIsImJsdXJEYXRhVVJMIiwiYWxsIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiY29uZmlnQ29udGV4dCIsInVzZUNvbnRleHQiLCJJbWFnZUNvbmZpZ0NvbnRleHQiLCJjb25maWciLCJ1c2VNZW1vIiwiYyIsImNvbmZpZ0VudiIsImltYWdlQ29uZmlnRGVmYXVsdCIsImFsbFNpemVzIiwiZGV2aWNlU2l6ZXMiLCJpbWFnZVNpemVzIiwic29ydCIsImEiLCJiIiwiX29iamVjdFNwcmVhZCIsInJlc3QiLCJsYXlvdXQiLCJsb2FkZXIiLCJkZWZhdWx0SW1hZ2VMb2FkZXIiLCJjdXN0b21JbWFnZUxvYWRlciIsIl90bXAiLCJvYmoiLCJfIiwib3B0cyIsInN0YXRpY1NyYyIsImlzU3RhdGljSW1wb3J0Iiwic3RhdGljSW1hZ2VEYXRhIiwiaXNTdGF0aWNSZXF1aXJlIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwid2lkdGhJbnQiLCJnZXRJbnQiLCJoZWlnaHRJbnQiLCJxdWFsaXR5SW50IiwiaXNMYXp5Iiwic3RhcnRzV2l0aCIsImxvYWRlZEltYWdlVVJMcyIsImhhcyIsInVzZVN0YXRlIiwiYmx1ckNvbXBsZXRlIiwic2V0Qmx1ckNvbXBsZXRlIiwidXNlSW50ZXJzZWN0aW9uIiwicm9vdFJlZiIsInJvb3RNYXJnaW4iLCJkaXNhYmxlZCIsInNldEludGVyc2VjdGlvbiIsImlzSW50ZXJzZWN0ZWQiLCJyZXNldEludGVyc2VjdGVkIiwiaXNWaXNpYmxlIiwid3JhcHBlclN0eWxlIiwiYm94U2l6aW5nIiwiZGlzcGxheSIsIm92ZXJmbG93IiwiYmFja2dyb3VuZCIsIm9wYWNpdHkiLCJib3JkZXIiLCJtYXJnaW4iLCJwYWRkaW5nIiwic2l6ZXJTdHlsZSIsImhhc1NpemVyIiwic2l6ZXJTdmdVcmwiLCJsYXlvdXRTdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsImJvdHRvbSIsInJpZ2h0IiwibWluV2lkdGgiLCJtYXhXaWR0aCIsIm1pbkhlaWdodCIsIm1heEhlaWdodCIsInByb2Nlc3MiLCJWQUxJRF9MQVlPVVRfVkFMVUVTIiwiaW5jbHVkZXMiLCJtYXAiLCJTdHJpbmciLCJqb2luIiwiZXhwZXJpbWVudGFsTGF5b3V0UmF3IiwiaXNOYU4iLCJ3YXJuT25jZSIsIlZBTElEX0xPQURJTkdfVkFMVUVTIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJ1cmwiLCJVUkwiLCJlcnIiLCJwYXRobmFtZSIsInNlYXJjaCIsIm92ZXJ3cml0dGVuU3R5bGVzIiwia2V5cyIsImZpbHRlciIsImtleSIsImxlbmd0aCIsInBlcmZPYnNlcnZlciIsIndpbmRvdyIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJnZXRFbnRyaWVzIiwiZW50cnkiLCJyZWYxIiwiaW1nU3JjIiwiZWxlbWVudCIsImxjcEltYWdlIiwiYWxsSW1ncyIsImdldCIsIm9ic2VydmUiLCJ0eXBlIiwiYnVmZmVyZWQiLCJjb25zb2xlIiwiZXJyb3IiLCJpbWdTdHlsZSIsImFzc2lnbiIsImFzcGVjdFJhdGlvIiwiYmx1clN0eWxlIiwiYmFja2dyb3VuZFNpemUiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJxdW90aWVudCIsInBhZGRpbmdUb3AiLCJpbWdBdHRyaWJ1dGVzIiwiZW1wdHlEYXRhVVJMIiwic3JjU2V0IiwidW5kZWZpbmVkIiwiZ2VuZXJhdGVJbWdBdHRycyIsInNyY1N0cmluZyIsImZ1bGxVcmwiLCJlIiwibG9jYXRpb24iLCJocmVmIiwic2V0IiwiaW1hZ2VTcmNTZXRQcm9wTmFtZSIsImltYWdlU2l6ZXNQcm9wTmFtZSIsImVudiIsIl9fTkVYVF9SRUFDVF9ST09UIiwibGlua1Byb3BzIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0Iiwib25Mb2FkaW5nQ29tcGxldGVSZWYiLCJ1c2VSZWYiLCJwcmV2aW91c0ltYWdlU3JjIiwiY3VycmVudCIsImltZ0VsZW1lbnRBcmdzIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwiSW1hZ2VFbGVtZW50IiwiYWx0IiwicmVsIiwiYXMiLCJfZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX2VzTW9kdWxlIiwibmV3T2JqIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInRhcmdldCIsInNvdXJjZSIsImFyZ3VtZW50cyIsImkiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiY29uY2F0Iiwic3ltIiwiZm9yRWFjaCIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJzb3VyY2VTeW1ib2xLZXlzIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwic291cmNlS2V5cyIsInJlZiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwiU2V0IiwiTWFwIiwiZ2xvYmFsIiwiX19ORVhUX0lNQUdFX0lNUE9SVEVEIiwibG9hZGVycyIsImRlZmF1bHRMb2FkZXIiLCJpbWdpeExvYWRlciIsImNsb3VkaW5hcnlMb2FkZXIiLCJha2FtYWlMb2FkZXIiLCJjdXN0b21Mb2FkZXIiLCJpc1N0YXRpY0ltYWdlRGF0YSIsImdldFdpZHRocyIsInZpZXdwb3J0V2lkdGhSZSIsInBlcmNlbnRTaXplcyIsIm1hdGNoIiwiZXhlYyIsInB1c2giLCJwYXJzZUludCIsIk1hdGgiLCJzbWFsbGVzdFJhdGlvIiwibWluIiwid2lkdGhzIiwicyIsImtpbmQiLCJ3IiwiZmluZCIsInAiLCJsYXN0IiwieCIsImxvYWRlclByb3BzIiwicmVmMiIsImxvYWRlcktleSIsImxvYWQiLCJWQUxJRF9MT0FERVJTIiwiaGFuZGxlTG9hZGluZyIsImltZyIsImRlY29kZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2F0Y2giLCJ0aGVuIiwicGFyZW50Tm9kZSIsImFkZCIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaHQiLCJyZWYzIiwicGFyZW50RWxlbWVudCIsInBhcmVudCIsImdldENvbXB1dGVkU3R5bGUiLCJkZWNvZGluZyIsInVzZUNhbGxiYWNrIiwiY29tcGxldGUiLCJvbkxvYWQiLCJldmVudCIsImN1cnJlbnRUYXJnZXQiLCJub3JtYWxpemVTcmMiLCJzbGljZSIsInBhdGgiLCJwYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJ0b1N0cmluZyIsInBhcmFtc1N0cmluZyIsIm1pc3NpbmdWYWx1ZXMiLCJkb21haW5zIiwicGFyc2VkU3JjIiwiaG9zdG5hbWUiLCJlbmRzV2l0aCIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJlbmNvZGVVUklDb21wb25lbnQiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/image.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s1, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s1 = _i.next()).done); _n = true){\n            _arr.push(_s1.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useIntersection = useIntersection;\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\nvar hasIntersectionObserver = typeof IntersectionObserver !== \"undefined\";\nfunction useIntersection(param) {\n    var rootRef = param.rootRef, rootMargin = param.rootMargin, disabled = param.disabled;\n    _s();\n    var isDisabled = disabled || !hasIntersectionObserver;\n    var unobserve = (0, _react).useRef();\n    var ref = _slicedToArray((0, _react).useState(false), 2), visible = ref[0], setVisible = ref[1];\n    var ref1 = _slicedToArray((0, _react).useState(rootRef ? rootRef.current : null), 2), root = ref1[0], setRoot = ref1[1];\n    var setRef = (0, _react).useCallback(function(el) {\n        if (unobserve.current) {\n            unobserve.current();\n            unobserve.current = undefined;\n        }\n        if (isDisabled || visible) return;\n        if (el && el.tagName) {\n            unobserve.current = observe(el, function(isVisible) {\n                return isVisible && setVisible(isVisible);\n            }, {\n                root: root,\n                rootMargin: rootMargin\n            });\n        }\n    }, [\n        isDisabled,\n        root,\n        rootMargin,\n        visible\n    ]);\n    var resetVisible = (0, _react).useCallback(function() {\n        setVisible(false);\n    }, []);\n    (0, _react).useEffect(function() {\n        if (!hasIntersectionObserver) {\n            if (!visible) {\n                var idleCallback = (0, _requestIdleCallback).requestIdleCallback(function() {\n                    return setVisible(true);\n                });\n                return function() {\n                    return (0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n                };\n            }\n        }\n    }, [\n        visible\n    ]);\n    (0, _react).useEffect(function() {\n        if (rootRef) setRoot(rootRef.current);\n    }, [\n        rootRef\n    ]);\n    return [\n        setRef,\n        visible,\n        resetVisible\n    ];\n}\n_s(useIntersection, \"v899qx2Oxsy68lv6LR1+qv/1rnU=\");\nfunction observe(element, callback, options) {\n    var ref = createObserver(options), id = ref.id, observer = ref.observer, elements = ref.elements;\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            var index = idList.findIndex(function(obj) {\n                return obj.root === id.root && obj.margin === id.margin;\n            });\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nvar observers = new Map();\nvar idList = [];\nfunction createObserver(options) {\n    var id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    var existing = idList.find(function(obj) {\n        return obj.root === id.root && obj.margin === id.margin;\n    });\n    var instance;\n    if (existing) {\n        instance = observers.get(existing);\n    } else {\n        instance = observers.get(id);\n        idList.push(id);\n    }\n    if (instance) {\n        return instance;\n    }\n    var elements = new Map();\n    var observer = new IntersectionObserver(function(entries) {\n        entries.forEach(function(entry) {\n            var callback = elements.get(entry.target);\n            var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    observers.set(id, instance = {\n        id: id,\n        observer: observer,\n        elements: elements\n    });\n    return instance;\n}\nif (typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) {\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDYkEsOENBQTZDO0lBQ3pDRyxLQUFLLEVBQUUsSUFBSTtDQUNkLEVBQUMsQ0FBQztBQUNIRCx1QkFBdUIsR0FBR0UsZUFBZSxDQUFDO0FBQzFDLElBQUlDLE1BQU0sR0FBR0MsbUJBQU8sQ0FBQyw0Q0FBTyxDQUFDO0FBQzdCLElBQUlDLG9CQUFvQixHQUFHRCxtQkFBTyxDQUFDLHlGQUF5QixDQUFDO0FBQzdELElBQU1FLHVCQUF1QixHQUFHLE9BQU9DLG9CQUFvQixLQUFLLFdBQVc7QUFDM0UsU0FBU0wsZUFBZSxDQUFDLEtBQW9DLEVBQUU7UUFBcENNLE9BQU8sR0FBVCxLQUFvQyxDQUFsQ0EsT0FBTyxFQUFHQyxVQUFVLEdBQXRCLEtBQW9DLENBQXhCQSxVQUFVLEVBQUdDLFFBQVEsR0FBakMsS0FBb0MsQ0FBWEEsUUFBUTs7SUFDdEQsSUFBTUMsVUFBVSxHQUFHRCxRQUFRLElBQUksQ0FBQ0osdUJBQXVCO0lBQ3ZELElBQU1NLFNBQVMsR0FBRyxDQUFDLENBQUMsRUFBRVQsTUFBTSxDQUFDLENBQUNVLE1BQU0sRUFBRTtJQUN0QyxJQUE4QixHQUEyQixrQkFBM0IsQ0FBQyxDQUFDLEVBQUVWLE1BQU0sQ0FBQyxDQUFDVyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQWxEQyxPQUFPLEdBQWdCLEdBQTJCLEdBQTNDLEVBQUVDLFVBQVUsR0FBSSxHQUEyQixHQUEvQjtJQUMxQixJQUF3QixJQUFzRCxrQkFBdEQsQ0FBQyxDQUFDLEVBQUViLE1BQU0sQ0FBQyxDQUFDVyxRQUFRLENBQUNOLE9BQU8sR0FBR0EsT0FBTyxDQUFDUyxPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQXZFQyxJQUFJLEdBQWEsSUFBc0QsR0FBbkUsRUFBRUMsT0FBTyxHQUFJLElB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TWYsUUFBUSxHQUFHLElBQUlZLEdBQUcsRUFBRTtJQUMxQixJQUFNYixRQUFRLEdBQUcsSUFBSTlCLG9CQUFvQixDQUFDLFNBQUNpRCxPQUFPLEVBQUc7UUFDakRBLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLFNBQUNDLEtBQUssRUFBRztZQUNyQixJQUFNekIsUUFBUSxHQUFHSyxRQUFRLENBQUNnQixHQUFHLENBQUNJLEtBQUssQ0FBQ0MsTUFBTSxDQUFDO1lBQzNDLElBQU1qQyxTQUFTLEdBQUdnQyxLQUFLLENBQUNFLGNBQWMsSUFBSUYsS0FBSyxDQUFDRyxpQkFBaUIsR0FBRyxDQUFDO1lBQ3JFLElBQUk1QixRQUFRLElBQUlQLFNBQVMsRUFBRTtnQkFDdkJPLFFBQVEsQ0FBQ1AsU0FBUyxDQUFDLENBQUM7YUFDdkI7U0FDSixDQUFDLENBQUM7S0FDTixFQUFFUSxPQUFPLENBQUM7SUFDWFMsU0FBUyxDQUFDSixHQUFHLENBQUNILEVBQUUsRUFBRWlCLFFBQVEsR0FBRztRQUN6QmpCLEVBQUUsRUFBRkEsRUFBRTtRQUNGQyxRQUFRLEVBQVJBLFFBQVE7UUFDUkMsUUFBUSxFQUFSQSxRQUFRO0tBQ1gsQ0FBQyxDQUFDO0lBQ0gsT0FBT2UsUUFBUSxDQUFDO0NBQ25CO0FBRUQsSUFBSSxPQUFPckQsT0FBTyxDQUFDOEQsT0FBTyxLQUFLLFVBQVUsSUFBSyxPQUFPOUQsT0FBTyxDQUFDOEQsT0FBTyxLQUFLLFFBQVEsSUFBSTlELE9BQU8sQ0FBQzhELE9BQU8sS0FBSyxJQUFJLEVBQUc7SUFDOUdoRSxNQUFNLENBQUNpRSxNQUFNLENBQUMvRCxPQUFPLENBQUM4RCxPQUFPLEVBQUU5RCxPQUFPLENBQUMsQ0FBQztJQUN4Q2dFLE1BQU0sQ0FBQ2hFLE9BQU8sR0FBR0EsT0FBTyxDQUFDOEQsT0FBTyxDQUFDO0NBQ2xDLENBRUQsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanM/ZmQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudXNlSW50ZXJzZWN0aW9uID0gdXNlSW50ZXJzZWN0aW9uO1xudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBfcmVxdWVzdElkbGVDYWxsYmFjayA9IHJlcXVpcmUoXCIuL3JlcXVlc3QtaWRsZS1jYWxsYmFja1wiKTtcbmNvbnN0IGhhc0ludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcbmZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbih7IHJvb3RSZWYgLCByb290TWFyZ2luICwgZGlzYWJsZWQgIH0pIHtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIGNvbnN0IHVub2JzZXJ2ZSA9ICgwLCBfcmVhY3QpLnVzZVJlZigpO1xuICAgIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9ICgwLCBfcmVhY3QpLnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbcm9vdCwgc2V0Um9vdF0gPSAoMCwgX3JlYWN0KS51c2VTdGF0ZShyb290UmVmID8gcm9vdFJlZi5jdXJyZW50IDogbnVsbCk7XG4gICAgY29uc3Qgc2V0UmVmID0gKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKGVsKT0+e1xuICAgICAgICBpZiAodW5vYnNlcnZlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50KCk7XG4gICAgICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEaXNhYmxlZCB8fCB2aXNpYmxlKSByZXR1cm47XG4gICAgICAgIGlmIChlbCAmJiBlbC50YWdOYW1lKSB7XG4gICAgICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IG9ic2VydmUoZWwsIChpc1Zpc2libGUpPT5pc1Zpc2libGUgJiYgc2V0VmlzaWJsZShpc1Zpc2libGUpXG4gICAgICAgICAgICAsIHtcbiAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgIHJvb3RNYXJnaW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICByb290LFxuICAgICAgICByb290TWFyZ2luLFxuICAgICAgICB2aXNpYmxlXG4gICAgXSk7XG4gICAgY29uc3QgcmVzZXRWaXNpYmxlID0gKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgfSwgW10pO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZGxlQ2FsbGJhY2sgPSAoMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLnJlcXVlc3RJZGxlQ2FsbGJhY2soKCk9PnNldFZpc2libGUodHJ1ZSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKT0+KDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5jYW5jZWxJZGxlQ2FsbGJhY2soaWRsZUNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgdmlzaWJsZVxuICAgIF0pO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAocm9vdFJlZikgc2V0Um9vdChyb290UmVmLmN1cnJlbnQpO1xuICAgIH0sIFtcbiAgICAgICAgcm9vdFJlZlxuICAgIF0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNldFJlZixcbiAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgcmVzZXRWaXNpYmxlXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGlkICwgb2JzZXJ2ZXIgLCBlbGVtZW50cyAgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpO1xuICAgIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCkge1xuICAgICAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgICAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBpZExpc3QuZmluZEluZGV4KChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGlkTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IG9ic2VydmVycyA9IG5ldyBNYXAoKTtcbmNvbnN0IGlkTGlzdCA9IFtdO1xuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucykge1xuICAgIGNvbnN0IGlkID0ge1xuICAgICAgICByb290OiBvcHRpb25zLnJvb3QgfHwgbnVsbCxcbiAgICAgICAgbWFyZ2luOiBvcHRpb25zLnJvb3RNYXJnaW4gfHwgJydcbiAgICB9O1xuICAgIGxldCBleGlzdGluZyA9IGlkTGlzdC5maW5kKChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW5cbiAgICApO1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYnNlcnZlcnMuZ2V0KGV4aXN0aW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZSA9IG9ic2VydmVycy5nZXQoaWQpO1xuICAgICAgICBpZExpc3QucHVzaChpZCk7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKT0+e1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KT0+e1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBlbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMDtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBpc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpc1Zpc2libGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBvcHRpb25zKTtcbiAgICBvYnNlcnZlcnMuc2V0KGlkLCBpbnN0YW5jZSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIG9ic2VydmVyLFxuICAgICAgICBlbGVtZW50c1xuICAgIH0pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cblxuaWYgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpIHtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWludGVyc2VjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJfcmVhY3QiLCJyZXF1aXJlIiwiX3JlcXVlc3RJZGxlQ2FsbGJhY2siLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwicm9vdFJlZiIsInJvb3RNYXJnaW4iLCJkaXNhYmxlZCIsImlzRGlzYWJsZWQiLCJ1bm9ic2VydmUiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInZpc2libGUiLCJzZXRWaXNpYmxlIiwiY3VycmVudCIsInJvb3QiLCJzZXRSb290Iiwic2V0UmVmIiwidXNlQ2FsbGJhY2siLCJlbCIsInVuZGVmaW5lZCIsInRhZ05hbWUiLCJvYnNlcnZlIiwiaXNWaXNpYmxlIiwicmVzZXRWaXNpYmxlIiwidXNlRWZmZWN0IiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsImVsZW1lbnQiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJjcmVhdGVPYnNlcnZlciIsImlkIiwib2JzZXJ2ZXIiLCJlbGVtZW50cyIsInNldCIsImRlbGV0ZSIsInNpemUiLCJkaXNjb25uZWN0Iiwib2JzZXJ2ZXJzIiwiaW5kZXgiLCJpZExpc3QiLCJmaW5kSW5kZXgiLCJvYmoiLCJtYXJnaW4iLCJzcGxpY2UiLCJNYXAiLCJleGlzdGluZyIsImZpbmQiLCJpbnN0YW5jZSIsImdldCIsInB1c2giLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwidGFyZ2V0IiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3Rpb25SYXRpbyIsImRlZmF1bHQiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-intersection.js\n");

/***/ }),

/***/ "./pages/index.tsx":
/*!*************************!*\
  !*** ./pages/index.tsx ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @chakra-ui/react */ \"./node_modules/@chakra-ui/react/dist/chakra-ui-react.esm.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_AppBar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/AppBar */ \"./components/AppBar.tsx\");\n/* harmony import */ var _components_MovieList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/MovieList */ \"./components/MovieList.tsx\");\n/* harmony import */ var _components_Form__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Form */ \"./components/Form.tsx\");\n/* harmony import */ var _styles_Home_module_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../styles/Home.module.css */ \"./styles/Home.module.css\");\n/* harmony import */ var _styles_Home_module_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_5__);\nvar _this = undefined;\n\n\n\n\n\n\n\nvar Home = function() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_5___default().App),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                    children: \"Movie Reviews\"\n                }, void 0, false, {\n                    fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/pages/index.tsx\",\n                    lineNumber: 14,\n                    columnNumber: 9\n                }, _this)\n            }, void 0, false, {\n                fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/pages/index.tsx\",\n                lineNumber: 13,\n                columnNumber: 7\n            }, _this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_AppBar__WEBPACK_IMPORTED_MODULE_2__.AppBar, {}, void 0, false, {\n                fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/pages/index.tsx\",\n                lineNumber: 16,\n                columnNumber: 7\n            }, _this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.Center, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.Box, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.Heading, {\n                            as: \"h1\",\n                            size: \"l\",\n                            color: \"white\",\n                            ml: 4,\n                            mt: 8,\n                            children: \"Add a review\"\n                        }, void 0, false, {\n                            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/pages/index.tsx\",\n                            lineNumber: 19,\n                            columnNumber: 11\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Form__WEBPACK_IMPORTED_MODULE_4__.Form, {}, void 0, false, {\n                            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/pages/index.tsx\",\n                            lineNumber: 22,\n                            columnNumber: 11\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.Heading, {\n                            as: \"h1\",\n                            size: \"l\",\n                            color: \"white\",\n                            ml: 4,\n                            mt: 8,\n                            children: \"Existing Reviews\"\n                        }, void 0, false, {\n                            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/pages/index.tsx\",\n                            lineNumber: 23,\n                            columnNumber: 11\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_MovieList__WEBPACK_IMPORTED_MODULE_3__.MovieList, {}, void 0, false, {\n                            fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/pages/index.tsx\",\n                            lineNumber: 26,\n                            columnNumber: 11\n                        }, _this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/pages/index.tsx\",\n                    lineNumber: 18,\n                    columnNumber: 9\n                }, _this)\n            }, void 0, false, {\n                fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/pages/index.tsx\",\n                lineNumber: 17,\n                columnNumber: 7\n            }, _this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/matheus/Code/fac/current/blockchain/solana/movie-fe/pages/index.tsx\",\n        lineNumber: 12,\n        columnNumber: 5\n    }, _this);\n};\n_c = Home;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Home);\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFDQTs7QUFBdUQ7QUFFM0I7QUFDaUI7QUFDTTtBQUNWO0FBQ0s7QUFFOUMsSUFBTVEsSUFBSSxHQUFhLFdBQU07SUFDM0IscUJBQ0UsOERBQUNDLEtBQUc7UUFBQ0MsU0FBUyxFQUFFSCxvRUFBVTs7MEJBQ3hCLDhEQUFDSixrREFBSTswQkFDSCw0RUFBQ1MsT0FBSzs4QkFBQyxlQUFhOzs7Ozt5QkFBUTs7Ozs7cUJBQ3ZCOzBCQUNQLDhEQUFDUixzREFBTTs7OztxQkFBRzswQkFDViw4REFBQ0osb0RBQU07MEJBQ0wsNEVBQUNDLGlEQUFHOztzQ0FDRiw4REFBQ0MscURBQU87NEJBQUNXLEVBQUUsRUFBQyxJQUFJOzRCQUFDQyxJQUFJLEVBQUMsR0FBRzs0QkFBQ0MsS0FBSyxFQUFDLE9BQU87NEJBQUNDLEVBQUUsRUFBRSxDQUFDOzRCQUFFQyxFQUFFLEVBQUUsQ0FBQztzQ0FBRSxjQUV0RDs7Ozs7aUNBQVU7c0NBQ1YsOERBQUNYLGtEQUFJOzs7O2lDQUFHO3NDQUNSLDhEQUFDSixxREFBTzs0QkFBQ1csRUFBRSxFQUFDLElBQUk7NEJBQUNDLElBQUksRUFBQyxHQUFHOzRCQUFDQyxLQUFLLEVBQUMsT0FBTzs0QkFBQ0MsRUFBRSxFQUFFLENBQUM7NEJBQUVDLEVBQUUsRUFBRSxDQUFDO3NDQUFFLGtCQUV0RDs7Ozs7aUNBQVU7c0NBQ1YsOERBQUNaLDREQUFTOzs7O2lDQUFHOzs7Ozs7eUJBQ1Q7Ozs7O3FCQUNDOzs7Ozs7YUFDTCxDQUNQO0NBQ0Y7QUFyQktHLEtBQUFBLElBQUk7QUF1QlYsK0RBQWVBLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvaW5kZXgudHN4PzA3ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBDZW50ZXIsIEJveCwgSGVhZGluZyB9IGZyb20gJ0BjaGFrcmEtdWkvcmVhY3QnXG5pbXBvcnQgdHlwZSB7IE5leHRQYWdlIH0gZnJvbSAnbmV4dCdcbmltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCdcbmltcG9ydCB7IEFwcEJhciB9IGZyb20gJy4uL2NvbXBvbmVudHMvQXBwQmFyJ1xuaW1wb3J0IHsgTW92aWVMaXN0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9Nb3ZpZUxpc3QnXG5pbXBvcnQgeyBGb3JtIH0gZnJvbSAnLi4vY29tcG9uZW50cy9Gb3JtJ1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuLi9zdHlsZXMvSG9tZS5tb2R1bGUuY3NzJ1xuXG5jb25zdCBIb21lOiBOZXh0UGFnZSA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLkFwcH0+XG4gICAgICA8SGVhZD5cbiAgICAgICAgPHRpdGxlPk1vdmllIFJldmlld3M8L3RpdGxlPlxuICAgICAgPC9IZWFkPlxuICAgICAgPEFwcEJhciAvPlxuICAgICAgPENlbnRlcj5cbiAgICAgICAgPEJveD5cbiAgICAgICAgICA8SGVhZGluZyBhcz1cImgxXCIgc2l6ZT1cImxcIiBjb2xvcj1cIndoaXRlXCIgbWw9ezR9IG10PXs4fT5cbiAgICAgICAgICAgIEFkZCBhIHJldmlld1xuICAgICAgICAgIDwvSGVhZGluZz5cbiAgICAgICAgICA8Rm9ybSAvPlxuICAgICAgICAgIDxIZWFkaW5nIGFzPVwiaDFcIiBzaXplPVwibFwiIGNvbG9yPVwid2hpdGVcIiBtbD17NH0gbXQ9ezh9PlxuICAgICAgICAgICAgRXhpc3RpbmcgUmV2aWV3c1xuICAgICAgICAgIDwvSGVhZGluZz5cbiAgICAgICAgICA8TW92aWVMaXN0IC8+XG4gICAgICAgIDwvQm94PlxuICAgICAgPC9DZW50ZXI+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgSG9tZVxuIl0sIm5hbWVzIjpbIkNlbnRlciIsIkJveCIsIkhlYWRpbmciLCJIZWFkIiwiQXBwQmFyIiwiTW92aWVMaXN0IiwiRm9ybSIsInN0eWxlcyIsIkhvbWUiLCJkaXYiLCJjbGFzc05hbWUiLCJBcHAiLCJ0aXRsZSIsImFzIiwic2l6ZSIsImNvbG9yIiwibWwiLCJtdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/index.tsx\n");

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n");

/***/ }),

/***/ "./node_modules/next/image.js":
/*!************************************!*\
  !*** ./node_modules/next/image.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./dist/client/image */ \"./node_modules/next/dist/client/image.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyR0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvaW1hZ2UuanM/MDUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvaW1hZ2UnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/image.js\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=%2Fhome%2Fmatheus%2FCode%2Ffac%2Fcurrent%2Fblockchain%2Fsolana%2Fmovie-fe%2Fpages%2Findex.tsx!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);